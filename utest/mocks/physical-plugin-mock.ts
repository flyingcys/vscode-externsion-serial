/**
 * 物理文件Mock策略 - 用于解决深层次的require()拦截问题
 * 
 * 创建实际的临时插件文件，让PluginLoader能够直接require到真实文件
 * 而不是依赖复杂的Node.js require拦截机制
 */

import { vi, beforeEach, afterEach } from 'vitest';
import * as path from 'path';
import * as os from 'os';
import { PluginManifest } from '../../src/extension/plugins/types';
import { PluginManifestFactory } from './plugins-mock-factory';

// 使用真实的fs，不受mock影响 - 在mock生效之前保存真实引用
import * as realFs from 'fs/promises';
const fs = realFs;

/**
 * 物理插件Mock管理器
 */
export class PhysicalPluginMockManager {
  private tempDirs: string[] = [];
  private createdFiles: string[] = [];
  private uniqueId: string;

  constructor() {
    // 🎯 绝对唯一路径策略: 时间戳 + 随机数 + 进程ID
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    const processId = process.pid;
    this.uniqueId = `${timestamp}-${random}-${processId}`;
  }

  /**
   * 🎯 生成绝对唯一的插件路径
   * 确保每个测试实例使用完全不同的路径，避免并发冲突
   */
  generateUniquePluginPath(baseName: string = 'plugin'): string {
    const uniquePath = `${os.tmpdir()}/unique-${baseName}-${this.uniqueId}`;
    return uniquePath;
  }

  /**
   * 🎯 创建标准测试插件（替代原有的固定路径插件）
   */
  async createStandardTestPlugin(type: 'main' | 'index' | 'plugin' | 'custom' = 'main'): Promise<string> {
    let manifest = PluginManifestFactory.createValid();
    let mainEntry: string;
    let moduleContent: string;
    let uniquePath: string;

    switch (type) {
      case 'main':
        mainEntry = 'custom-entry.js';
        uniquePath = this.generateUniquePluginPath('test-main');
        manifest = { ...manifest, main: 'custom-entry.js' };
        moduleContent = `
module.exports = {
  activate: async function(context) {
    return { customEntry: true };
  },
  deactivate: async function() {},
  customExport: true
};`;
        break;

      case 'index':
        mainEntry = 'index.js';
        uniquePath = this.generateUniquePluginPath('test-index');
        // 删除main字段，让PluginLoader使用默认入口点
        const indexManifest = { ...manifest };
        delete (indexManifest as any).main;
        manifest = indexManifest;
        moduleContent = `
module.exports = {
  activate: async function(context) {
    return { initialized: true };
  },
  deactivate: async function() {},
  drivers: [],
  widgets: [],
  parsers: []
};`;
        break;

      case 'plugin':
        mainEntry = 'plugin.js';
        uniquePath = this.generateUniquePluginPath('test-plugin-entry');
        // 删除main字段，让PluginLoader尝试默认入口点，但只创建plugin.js
        const pluginManifest = { ...manifest };
        delete (pluginManifest as any).main;
        manifest = pluginManifest;
        moduleContent = `
module.exports = {
  activate: async function(context) {
    return { entryPoint: 'plugin.js' };
  },
  deactivate: async function() {},
  entryPoint: 'plugin.js'
};`;
        break;

      case 'custom':
        mainEntry = 'custom-entry.js';
        uniquePath = this.generateUniquePluginPath('test-custom');
        manifest = { ...manifest, main: 'custom-entry.js' };
        moduleContent = `
module.exports = {
  activate: async function(context) {
    return { initialized: true };
  },
  deactivate: async function() {},
  customExport: true
};`;
        break;
    }

    return await this.createPluginFiles({
      pluginPath: uniquePath,
      manifest,
      moduleContent,
      mainEntry
    });
  }

  /**
   * 创建临时插件目录和文件
   */
  async createPluginFiles(config: {
    pluginPath: string;
    manifest: PluginManifest;
    moduleContent?: string;
    mainEntry?: string;
  }): Promise<string> {
    const { pluginPath, manifest, moduleContent, mainEntry } = config;
    
    // 确保目录存在
    await fs.mkdir(pluginPath, { recursive: true });
    this.tempDirs.push(pluginPath);
    
    // 创建plugin.json（直接拼接路径避免path.join mock问题）
    const manifestPath = `${pluginPath}/plugin.json`;
    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2));
    this.createdFiles.push(manifestPath);
    
    // 创建主入口文件
    const entryFileName = mainEntry || manifest.main || 'index.js';
    const entryPath = `${pluginPath}/${entryFileName}`;
    
    const defaultModuleContent = `
// Mock plugin module generated by PhysicalPluginMockManager
module.exports = {
  activate: async function(context) {
    // Mock activation
    return { initialized: true };
  },
  
  deactivate: async function() {
    // Mock deactivation
  },
  
  // Mock contributions based on manifest
  ${manifest.contributes?.drivers ? `drivers: [
    {
      id: 'test-driver',
      name: 'Test Driver',
      protocol: 'test',
      driverClass: function TestDriver() {}
    }
  ],` : ''}
  
  ${manifest.contributes?.widgets ? `widgets: [
    {
      id: 'test-widget',
      name: 'Test Widget',
      type: 'dataset',
      component: function TestWidget() {}
    }
  ],` : ''}
  
  ${manifest.contributes?.parsers ? `parsers: [
    {
      id: 'test-parser',
      name: 'Test Parser',
      parserClass: function TestParser() {}
    }
  ],` : ''}
  
  // Additional mock exports
  validators: [],
  transformers: [],
  exportFormats: [],
  themes: []
};
`;
    
    await fs.writeFile(entryPath, moduleContent || defaultModuleContent);
    this.createdFiles.push(entryPath);
    
    return pluginPath;
  }

  /**
   * 创建会产生错误的插件文件
   */
  async createErrorPlugin(config: {
    pluginPath?: string;
    manifest?: PluginManifest;
    errorType: 'syntax' | 'missing-exports' | 'activation-failure';
  }): Promise<string> {
    // 🎯 使用唯一路径策略
    const pluginPath = config.pluginPath || this.generateUniquePluginPath(`error-${config.errorType}`);
    const manifest = config.manifest || PluginManifestFactory.createValid();
    const { errorType } = config;
    
    await fs.mkdir(pluginPath, { recursive: true });
    this.tempDirs.push(pluginPath);
    
    // 创建plugin.json
    const manifestPath = `${pluginPath}/plugin.json`;
    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2));
    this.createdFiles.push(manifestPath);
    
    // 根据错误类型创建不同的模块文件
    const entryPath = `${pluginPath}/${manifest.main || 'index.js'}`;
    let moduleContent = '';
    
    switch (errorType) {
      case 'syntax':
        moduleContent = `
// 故意的语法错误
module.exports = {
  activate: function(context) {
    // 缺少闭合括号
    if (true {
      return true;
    }
  }
`;
        break;
        
      case 'missing-exports':
        moduleContent = `
// 缺少必要的导出
module.exports = {
  // 没有activate函数
  // 没有声明的贡献导出
};
`;
        break;
        
      case 'activation-failure':
        moduleContent = `
module.exports = {
  activate: function(context) {
    throw new Error('Plugin activation failed');
  },
  
  deactivate: function() {}
};
`;
        break;
    }
    
    await fs.writeFile(entryPath, moduleContent);
    this.createdFiles.push(entryPath);
    
    return pluginPath;
  }

  /**
   * 创建自定义入口文件
   */
  async createCustomEntryPlugin(config: {
    pluginPath?: string;
    manifest?: PluginManifest;
    customEntryName: string;
    moduleContent?: string;
  }): Promise<string> {
    // 🎯 使用唯一路径策略
    const pluginPath = config.pluginPath || this.generateUniquePluginPath(`custom-${config.customEntryName.replace('.js', '')}`);
    const manifest = config.manifest || PluginManifestFactory.createValid();
    
    await fs.mkdir(pluginPath, { recursive: true });
    this.tempDirs.push(pluginPath);
    
    // 创建plugin.json with custom main
    const customManifest = {
      ...manifest,
      main: customEntryName
    };
    const manifestPath = `${pluginPath}/plugin.json`;
    await fs.writeFile(manifestPath, JSON.stringify(customManifest, null, 2));
    this.createdFiles.push(manifestPath);
    
    // 创建自定义入口文件
    const entryPath = `${pluginPath}/${customEntryName}`;
    const defaultContent = `
module.exports = {
  activate: async function(context) {
    return { customEntry: true };
  },
  
  deactivate: async function() {},
  
  customExport: true,
  widgets: []
};
`;
    
    await fs.writeFile(entryPath, moduleContent || defaultContent);
    this.createdFiles.push(entryPath);
    
    return pluginPath;
  }

  /**
   * 创建多个默认入口点测试场景
   */
  async createMultipleEntryPoints(config: {
    basePluginPath?: string;
    manifest?: PluginManifest;
    availableEntries: string[]; // 例如: ['index.js', 'main.js', 'plugin.js']
    workingEntry: string;
  }): Promise<string> {
    // 🎯 使用唯一路径策略
    const basePluginPath = config.basePluginPath || this.generateUniquePluginPath(`multi-entry-${config.workingEntry.replace('.js', '')}`);
    const manifest = config.manifest || PluginManifestFactory.createValid();
    
    await fs.mkdir(basePluginPath, { recursive: true });
    this.tempDirs.push(basePluginPath);
    
    // 创建没有main字段的manifest
    const manifestWithoutMain = { ...manifest };
    delete (manifestWithoutMain as any).main;
    
    const manifestPath = `${basePluginPath}/plugin.json`;
    await fs.writeFile(manifestPath, JSON.stringify(manifestWithoutMain, null, 2));
    this.createdFiles.push(manifestPath);
    
    // 创建指定的入口文件
    for (const entry of availableEntries) {
      const entryPath = `${basePluginPath}/${entry}`;
      
      if (entry === workingEntry) {
        // 创建工作的入口
        const moduleContent = `
module.exports = {
  activate: async function(context) {
    return { entryPoint: '${entry}' };
  },
  
  deactivate: async function() {},
  
  drivers: [],
  widgets: [],
  parsers: []
};
`;
        await fs.writeFile(entryPath, moduleContent);
      } else {
        // 创建无效的入口（或者不创建文件让它产生ENOENT）
        // 这里我们选择不创建文件，让PluginLoader自己处理文件不存在的情况
      }
      
      this.createdFiles.push(entryPath);
    }
    
    // 确保工作的入口存在
    const workingEntryPath = `${basePluginPath}/${workingEntry}`;
    if (!availableEntries.includes(workingEntry)) {
      const moduleContent = `
module.exports = {
  activate: async function(context) {
    return { entryPoint: '${workingEntry}' };
  },
  
  deactivate: async function() {},
  
  drivers: [],
  widgets: [],
  parsers: []
};
`;
      await fs.writeFile(workingEntryPath, moduleContent);
      this.createdFiles.push(workingEntryPath);
    }
    
    return basePluginPath;
  }

  /**
   * 清理所有创建的文件和目录
   */
  async cleanup(): Promise<void> {
    // 删除文件
    for (const filePath of this.createdFiles) {
      try {
        await fs.unlink(filePath);
      } catch (error) {
        // 忽略删除错误
      }
    }
    
    // 删除目录
    for (const dirPath of this.tempDirs) {
      try {
        await fs.rmdir(dirPath, { recursive: true });
      } catch (error) {
        // 忽略删除错误
      }
    }
    
    this.createdFiles = [];
    this.tempDirs = [];
  }

  /**
   * 创建临时目录
   */
  async createTempDir(prefix: string = 'plugin-test-'): Promise<string> {
    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), prefix));
    this.tempDirs.push(tempDir);
    return tempDir;
  }
}

// 全局实例
let globalManager: PhysicalPluginMockManager | null = null;

/**
 * 获取全局物理插件Mock管理器
 */
export function getPhysicalPluginMockManager(): PhysicalPluginMockManager {
  if (!globalManager) {
    globalManager = new PhysicalPluginMockManager();
  }
  return globalManager;
}

/**
 * 设置测试钩子
 */
export function setupPhysicalPluginMocks() {
  beforeEach(() => {
    globalManager = new PhysicalPluginMockManager();
  });
  
  afterEach(async () => {
    if (globalManager) {
      await globalManager.cleanup();
      globalManager = null;
    }
  });
}