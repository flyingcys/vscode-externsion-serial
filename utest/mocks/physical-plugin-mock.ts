/**
 * ç‰©ç†æ–‡ä»¶Mockç­–ç•¥ - ç”¨äºè§£å†³æ·±å±‚æ¬¡çš„require()æ‹¦æˆªé—®é¢˜
 * 
 * åˆ›å»ºå®é™…çš„ä¸´æ—¶æ’ä»¶æ–‡ä»¶ï¼Œè®©PluginLoaderèƒ½å¤Ÿç›´æ¥requireåˆ°çœŸå®æ–‡ä»¶
 * è€Œä¸æ˜¯ä¾èµ–å¤æ‚çš„Node.js requireæ‹¦æˆªæœºåˆ¶
 */

import { vi, beforeEach, afterEach } from 'vitest';
import * as path from 'path';
import * as os from 'os';
import { PluginManifest } from '../../src/extension/plugins/types';
import { PluginManifestFactory } from './plugins-mock-factory';

// ä½¿ç”¨çœŸå®çš„fsï¼Œä¸å—mockå½±å“ - åœ¨mockç”Ÿæ•ˆä¹‹å‰ä¿å­˜çœŸå®å¼•ç”¨
import * as realFs from 'fs/promises';
const fs = realFs;

/**
 * ç‰©ç†æ’ä»¶Mockç®¡ç†å™¨
 */
export class PhysicalPluginMockManager {
  private tempDirs: string[] = [];
  private createdFiles: string[] = [];
  private uniqueId: string;

  constructor() {
    // ğŸ¯ ç»å¯¹å”¯ä¸€è·¯å¾„ç­–ç•¥: æ—¶é—´æˆ³ + éšæœºæ•° + è¿›ç¨‹ID
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    const processId = process.pid;
    this.uniqueId = `${timestamp}-${random}-${processId}`;
  }

  /**
   * ğŸ¯ ç”Ÿæˆç»å¯¹å”¯ä¸€çš„æ’ä»¶è·¯å¾„
   * ç¡®ä¿æ¯ä¸ªæµ‹è¯•å®ä¾‹ä½¿ç”¨å®Œå…¨ä¸åŒçš„è·¯å¾„ï¼Œé¿å…å¹¶å‘å†²çª
   */
  generateUniquePluginPath(baseName: string = 'plugin'): string {
    const uniquePath = `${os.tmpdir()}/unique-${baseName}-${this.uniqueId}`;
    return uniquePath;
  }

  /**
   * ğŸ¯ åˆ›å»ºæ ‡å‡†æµ‹è¯•æ’ä»¶ï¼ˆæ›¿ä»£åŸæœ‰çš„å›ºå®šè·¯å¾„æ’ä»¶ï¼‰
   */
  async createStandardTestPlugin(type: 'main' | 'index' | 'plugin' | 'custom' = 'main'): Promise<string> {
    let manifest = PluginManifestFactory.createValid();
    let mainEntry: string;
    let moduleContent: string;
    let uniquePath: string;

    switch (type) {
      case 'main':
        mainEntry = 'custom-entry.js';
        uniquePath = this.generateUniquePluginPath('test-main');
        manifest = { ...manifest, main: 'custom-entry.js' };
        moduleContent = `
module.exports = {
  activate: async function(context) {
    return { customEntry: true };
  },
  deactivate: async function() {},
  customExport: true
};`;
        break;

      case 'index':
        mainEntry = 'index.js';
        uniquePath = this.generateUniquePluginPath('test-index');
        // åˆ é™¤mainå­—æ®µï¼Œè®©PluginLoaderä½¿ç”¨é»˜è®¤å…¥å£ç‚¹
        const indexManifest = { ...manifest };
        delete (indexManifest as any).main;
        manifest = indexManifest;
        moduleContent = `
module.exports = {
  activate: async function(context) {
    return { initialized: true };
  },
  deactivate: async function() {},
  drivers: [],
  widgets: [],
  parsers: []
};`;
        break;

      case 'plugin':
        mainEntry = 'plugin.js';
        uniquePath = this.generateUniquePluginPath('test-plugin-entry');
        // åˆ é™¤mainå­—æ®µï¼Œè®©PluginLoaderå°è¯•é»˜è®¤å…¥å£ç‚¹ï¼Œä½†åªåˆ›å»ºplugin.js
        const pluginManifest = { ...manifest };
        delete (pluginManifest as any).main;
        manifest = pluginManifest;
        moduleContent = `
module.exports = {
  activate: async function(context) {
    return { entryPoint: 'plugin.js' };
  },
  deactivate: async function() {},
  entryPoint: 'plugin.js'
};`;
        break;

      case 'custom':
        mainEntry = 'custom-entry.js';
        uniquePath = this.generateUniquePluginPath('test-custom');
        manifest = { ...manifest, main: 'custom-entry.js' };
        moduleContent = `
module.exports = {
  activate: async function(context) {
    return { initialized: true };
  },
  deactivate: async function() {},
  customExport: true
};`;
        break;
    }

    return await this.createPluginFiles({
      pluginPath: uniquePath,
      manifest,
      moduleContent,
      mainEntry
    });
  }

  /**
   * åˆ›å»ºä¸´æ—¶æ’ä»¶ç›®å½•å’Œæ–‡ä»¶
   */
  async createPluginFiles(config: {
    pluginPath: string;
    manifest: PluginManifest;
    moduleContent?: string;
    mainEntry?: string;
  }): Promise<string> {
    const { pluginPath, manifest, moduleContent, mainEntry } = config;
    
    // ç¡®ä¿ç›®å½•å­˜åœ¨
    await fs.mkdir(pluginPath, { recursive: true });
    this.tempDirs.push(pluginPath);
    
    // åˆ›å»ºplugin.jsonï¼ˆç›´æ¥æ‹¼æ¥è·¯å¾„é¿å…path.join mocké—®é¢˜ï¼‰
    const manifestPath = `${pluginPath}/plugin.json`;
    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2));
    this.createdFiles.push(manifestPath);
    
    // åˆ›å»ºä¸»å…¥å£æ–‡ä»¶
    const entryFileName = mainEntry || manifest.main || 'index.js';
    const entryPath = `${pluginPath}/${entryFileName}`;
    
    const defaultModuleContent = `
// Mock plugin module generated by PhysicalPluginMockManager
module.exports = {
  activate: async function(context) {
    // Mock activation
    return { initialized: true };
  },
  
  deactivate: async function() {
    // Mock deactivation
  },
  
  // Mock contributions based on manifest
  ${manifest.contributes?.drivers ? `drivers: [
    {
      id: 'test-driver',
      name: 'Test Driver',
      protocol: 'test',
      driverClass: function TestDriver() {}
    }
  ],` : ''}
  
  ${manifest.contributes?.widgets ? `widgets: [
    {
      id: 'test-widget',
      name: 'Test Widget',
      type: 'dataset',
      component: function TestWidget() {}
    }
  ],` : ''}
  
  ${manifest.contributes?.parsers ? `parsers: [
    {
      id: 'test-parser',
      name: 'Test Parser',
      parserClass: function TestParser() {}
    }
  ],` : ''}
  
  // Additional mock exports
  validators: [],
  transformers: [],
  exportFormats: [],
  themes: []
};
`;
    
    await fs.writeFile(entryPath, moduleContent || defaultModuleContent);
    this.createdFiles.push(entryPath);
    
    return pluginPath;
  }

  /**
   * åˆ›å»ºä¼šäº§ç”Ÿé”™è¯¯çš„æ’ä»¶æ–‡ä»¶
   */
  async createErrorPlugin(config: {
    pluginPath?: string;
    manifest?: PluginManifest;
    errorType: 'syntax' | 'missing-exports' | 'activation-failure';
  }): Promise<string> {
    // ğŸ¯ ä½¿ç”¨å”¯ä¸€è·¯å¾„ç­–ç•¥
    const pluginPath = config.pluginPath || this.generateUniquePluginPath(`error-${config.errorType}`);
    const manifest = config.manifest || PluginManifestFactory.createValid();
    const { errorType } = config;
    
    await fs.mkdir(pluginPath, { recursive: true });
    this.tempDirs.push(pluginPath);
    
    // åˆ›å»ºplugin.json
    const manifestPath = `${pluginPath}/plugin.json`;
    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2));
    this.createdFiles.push(manifestPath);
    
    // æ ¹æ®é”™è¯¯ç±»å‹åˆ›å»ºä¸åŒçš„æ¨¡å—æ–‡ä»¶
    const entryPath = `${pluginPath}/${manifest.main || 'index.js'}`;
    let moduleContent = '';
    
    switch (errorType) {
      case 'syntax':
        moduleContent = `
// æ•…æ„çš„è¯­æ³•é”™è¯¯
module.exports = {
  activate: function(context) {
    // ç¼ºå°‘é—­åˆæ‹¬å·
    if (true {
      return true;
    }
  }
`;
        break;
        
      case 'missing-exports':
        moduleContent = `
// ç¼ºå°‘å¿…è¦çš„å¯¼å‡º
module.exports = {
  // æ²¡æœ‰activateå‡½æ•°
  // æ²¡æœ‰å£°æ˜çš„è´¡çŒ®å¯¼å‡º
};
`;
        break;
        
      case 'activation-failure':
        moduleContent = `
module.exports = {
  activate: function(context) {
    throw new Error('Plugin activation failed');
  },
  
  deactivate: function() {}
};
`;
        break;
    }
    
    await fs.writeFile(entryPath, moduleContent);
    this.createdFiles.push(entryPath);
    
    return pluginPath;
  }

  /**
   * åˆ›å»ºè‡ªå®šä¹‰å…¥å£æ–‡ä»¶
   */
  async createCustomEntryPlugin(config: {
    pluginPath?: string;
    manifest?: PluginManifest;
    customEntryName: string;
    moduleContent?: string;
  }): Promise<string> {
    // ğŸ¯ ä½¿ç”¨å”¯ä¸€è·¯å¾„ç­–ç•¥
    const pluginPath = config.pluginPath || this.generateUniquePluginPath(`custom-${config.customEntryName.replace('.js', '')}`);
    const manifest = config.manifest || PluginManifestFactory.createValid();
    
    await fs.mkdir(pluginPath, { recursive: true });
    this.tempDirs.push(pluginPath);
    
    // åˆ›å»ºplugin.json with custom main
    const customManifest = {
      ...manifest,
      main: customEntryName
    };
    const manifestPath = `${pluginPath}/plugin.json`;
    await fs.writeFile(manifestPath, JSON.stringify(customManifest, null, 2));
    this.createdFiles.push(manifestPath);
    
    // åˆ›å»ºè‡ªå®šä¹‰å…¥å£æ–‡ä»¶
    const entryPath = `${pluginPath}/${customEntryName}`;
    const defaultContent = `
module.exports = {
  activate: async function(context) {
    return { customEntry: true };
  },
  
  deactivate: async function() {},
  
  customExport: true,
  widgets: []
};
`;
    
    await fs.writeFile(entryPath, moduleContent || defaultContent);
    this.createdFiles.push(entryPath);
    
    return pluginPath;
  }

  /**
   * åˆ›å»ºå¤šä¸ªé»˜è®¤å…¥å£ç‚¹æµ‹è¯•åœºæ™¯
   */
  async createMultipleEntryPoints(config: {
    basePluginPath?: string;
    manifest?: PluginManifest;
    availableEntries: string[]; // ä¾‹å¦‚: ['index.js', 'main.js', 'plugin.js']
    workingEntry: string;
  }): Promise<string> {
    // ğŸ¯ ä½¿ç”¨å”¯ä¸€è·¯å¾„ç­–ç•¥
    const basePluginPath = config.basePluginPath || this.generateUniquePluginPath(`multi-entry-${config.workingEntry.replace('.js', '')}`);
    const manifest = config.manifest || PluginManifestFactory.createValid();
    
    await fs.mkdir(basePluginPath, { recursive: true });
    this.tempDirs.push(basePluginPath);
    
    // åˆ›å»ºæ²¡æœ‰mainå­—æ®µçš„manifest
    const manifestWithoutMain = { ...manifest };
    delete (manifestWithoutMain as any).main;
    
    const manifestPath = `${basePluginPath}/plugin.json`;
    await fs.writeFile(manifestPath, JSON.stringify(manifestWithoutMain, null, 2));
    this.createdFiles.push(manifestPath);
    
    // åˆ›å»ºæŒ‡å®šçš„å…¥å£æ–‡ä»¶
    for (const entry of availableEntries) {
      const entryPath = `${basePluginPath}/${entry}`;
      
      if (entry === workingEntry) {
        // åˆ›å»ºå·¥ä½œçš„å…¥å£
        const moduleContent = `
module.exports = {
  activate: async function(context) {
    return { entryPoint: '${entry}' };
  },
  
  deactivate: async function() {},
  
  drivers: [],
  widgets: [],
  parsers: []
};
`;
        await fs.writeFile(entryPath, moduleContent);
      } else {
        // åˆ›å»ºæ— æ•ˆçš„å…¥å£ï¼ˆæˆ–è€…ä¸åˆ›å»ºæ–‡ä»¶è®©å®ƒäº§ç”ŸENOENTï¼‰
        // è¿™é‡Œæˆ‘ä»¬é€‰æ‹©ä¸åˆ›å»ºæ–‡ä»¶ï¼Œè®©PluginLoaderè‡ªå·±å¤„ç†æ–‡ä»¶ä¸å­˜åœ¨çš„æƒ…å†µ
      }
      
      this.createdFiles.push(entryPath);
    }
    
    // ç¡®ä¿å·¥ä½œçš„å…¥å£å­˜åœ¨
    const workingEntryPath = `${basePluginPath}/${workingEntry}`;
    if (!availableEntries.includes(workingEntry)) {
      const moduleContent = `
module.exports = {
  activate: async function(context) {
    return { entryPoint: '${workingEntry}' };
  },
  
  deactivate: async function() {},
  
  drivers: [],
  widgets: [],
  parsers: []
};
`;
      await fs.writeFile(workingEntryPath, moduleContent);
      this.createdFiles.push(workingEntryPath);
    }
    
    return basePluginPath;
  }

  /**
   * æ¸…ç†æ‰€æœ‰åˆ›å»ºçš„æ–‡ä»¶å’Œç›®å½•
   */
  async cleanup(): Promise<void> {
    // åˆ é™¤æ–‡ä»¶
    for (const filePath of this.createdFiles) {
      try {
        await fs.unlink(filePath);
      } catch (error) {
        // å¿½ç•¥åˆ é™¤é”™è¯¯
      }
    }
    
    // åˆ é™¤ç›®å½•
    for (const dirPath of this.tempDirs) {
      try {
        await fs.rmdir(dirPath, { recursive: true });
      } catch (error) {
        // å¿½ç•¥åˆ é™¤é”™è¯¯
      }
    }
    
    this.createdFiles = [];
    this.tempDirs = [];
  }

  /**
   * åˆ›å»ºä¸´æ—¶ç›®å½•
   */
  async createTempDir(prefix: string = 'plugin-test-'): Promise<string> {
    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), prefix));
    this.tempDirs.push(tempDir);
    return tempDir;
  }
}

// å…¨å±€å®ä¾‹
let globalManager: PhysicalPluginMockManager | null = null;

/**
 * è·å–å…¨å±€ç‰©ç†æ’ä»¶Mockç®¡ç†å™¨
 */
export function getPhysicalPluginMockManager(): PhysicalPluginMockManager {
  if (!globalManager) {
    globalManager = new PhysicalPluginMockManager();
  }
  return globalManager;
}

/**
 * è®¾ç½®æµ‹è¯•é’©å­
 */
export function setupPhysicalPluginMocks() {
  beforeEach(() => {
    globalManager = new PhysicalPluginMockManager();
  });
  
  afterEach(async () => {
    if (globalManager) {
      await globalManager.cleanup();
      globalManager = null;
    }
  });
}