# 数据导出模块单元测试方案

## 1. 模块概述

数据导出模块是Serial-Studio VSCode插件的数据处理支持模块，负责将可视化数据导出为多种格式的文件。模块支持CSV、JSON、Excel、XML、TXT、Binary等6种主要格式，具有数据过滤、转换、压缩和流式导出等高级功能，为用户提供灵活的数据分析和存档能力。

### 1.1 模块架构

```
┌─────────────────────────────────────────────────────────────┐
│                    数据导出模块架构                          │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   导出管理器     │  │   格式转换器     │  │  数据过滤器   │ │
│  │ - ExportManager │  │ - FormatConverter│  │ - DataFilter │ │
│  │ - 任务调度       │  │ - 6种格式支持    │  │ - 条件筛选    │ │
│  │ - 进度管理       │  │ - 自定义格式     │  │ - 数据转换    │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  流式导出器      │  │  压缩处理器      │  │  用户界面     │ │
│  │ - StreamExporter│  │ - ZIP压缩       │  │ - 导出对话框  │ │
│  │ - 大数据支持     │  │ - 数据压缩       │  │ - 进度显示    │ │
│  │ - 分块处理       │  │ - 文件打包       │  │ - 预览功能    │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 测试目标

- **格式支持**：验证6种导出格式的正确性和完整性
- **数据完整性**：确保导出数据与原始数据一致
- **性能指标**：导出速度≥1000条记录/秒，支持≥100MB数据集
- **用户体验**：友好的导出界面和进度反馈
- **错误处理**：各种异常情况的正确处理和恢复

## 2. 测试覆盖率目标

| 测试类型 | 覆盖率目标 | 优先级 | 说明 |
|---------|-----------|--------|------|
| 行覆盖率 | ≥92% | P2 | 辅助功能，中等优先级 |
| 分支覆盖率 | ≥85% | P2 | 包含所有格式转换分支 |
| 函数覆盖率 | ≥95% | P2 | 所有导出接口必须测试 |
| 语句覆盖率 | ≥92% | P2 | 确保导出逻辑完全验证 |

## 3. 详细测试用例设计

### 3.1 导出管理器测试

```typescript
// tests/export/export-manager.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { ExportManager } from '@/export/export-manager';
import { ExportFormat, ExportOptions, ExportResult } from '@/types/export';
import { Dataset } from '@/types/data';

describe('导出管理器测试', () => {
  let exportManager: ExportManager;
  let mockDataset: Dataset[];

  beforeEach(() => {
    exportManager = new ExportManager();
    
    mockDataset = [
      {
        id: 'temperature',
        title: 'Temperature',
        value: 25.6,
        timestamp: 1703001600000, // 2023-12-19 12:00:00
        units: '°C',
        metadata: { sensor: 'DS18B20', location: 'Room A' }
      },
      {
        id: 'humidity',
        title: 'Humidity',
        value: 65.2,
        timestamp: 1703001660000, // 2023-12-19 12:01:00
        units: '%',
        metadata: { sensor: 'DHT22', location: 'Room A' }
      },
      {
        id: 'pressure',
        title: 'Pressure',
        value: 1013.25,
        timestamp: 1703001720000, // 2023-12-19 12:02:00
        units: 'hPa',
        metadata: { sensor: 'BME280', location: 'Room A' }
      }
    ];

    // Mock file system operations
    global.require = vi.fn().mockImplementation((module) => {
      if (module === 'fs') {
        return {
          writeFileSync: vi.fn(),
          createWriteStream: vi.fn().mockReturnValue({
            write: vi.fn(),
            end: vi.fn(),
            on: vi.fn()
          }),
          existsSync: vi.fn().mockReturnValue(true),
          mkdirSync: vi.fn()
        };
      }
      return {};
    });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('导出任务管理', () => {
    test('应该创建导出任务', () => {
      const options: ExportOptions = {
        format: ExportFormat.CSV,
        filePath: '/tmp/export.csv',
        includeMetadata: true,
        dateFormat: 'ISO'
      };

      const taskId = exportManager.createExportTask(mockDataset, options);

      expect(taskId).toBeDefined();
      expect(typeof taskId).toBe('string');
      expect(exportManager.getTask(taskId)).toBeDefined();
    });

    test('应该执行导出任务', async () => {
      const options: ExportOptions = {
        format: ExportFormat.CSV,
        filePath: '/tmp/export.csv'
      };

      const taskId = exportManager.createExportTask(mockDataset, options);
      const result = await exportManager.executeTask(taskId);

      expect(result.success).toBe(true);
      expect(result.filePath).toBe('/tmp/export.csv');
      expect(result.recordsExported).toBe(3);
      expect(result.fileSize).toBeGreaterThan(0);
    });

    test('应该处理并发导出任务', async () => {
      const tasks = [];

      for (let i = 0; i < 5; i++) {
        const options: ExportOptions = {
          format: ExportFormat.JSON,
          filePath: `/tmp/export${i}.json`
        };
        
        const taskId = exportManager.createExportTask(mockDataset, options);
        tasks.push(exportManager.executeTask(taskId));
      }

      const results = await Promise.all(tasks);

      results.forEach((result, index) => {
        expect(result.success).toBe(true);
        expect(result.filePath).toBe(`/tmp/export${index}.json`);
      });
    });

    test('应该取消导出任务', async () => {
      const options: ExportOptions = {
        format: ExportFormat.EXCEL,
        filePath: '/tmp/large-export.xlsx'
      };

      const taskId = exportManager.createExportTask(mockDataset, options);
      
      // 开始执行任务
      const taskPromise = exportManager.executeTask(taskId);
      
      // 延迟后取消任务
      setTimeout(() => {
        exportManager.cancelTask(taskId);
      }, 100);

      const result = await taskPromise;

      expect(result.success).toBe(false);
      expect(result.error).toContain('cancelled');
    });

    test('应该监控导出进度', async () => {
      const progressEvents: number[] = [];
      
      exportManager.on('progress', (taskId, progress) => {
        progressEvents.push(progress);
      });

      const options: ExportOptions = {
        format: ExportFormat.CSV,
        filePath: '/tmp/export.csv'
      };

      const taskId = exportManager.createExportTask(mockDataset, options);
      await exportManager.executeTask(taskId);

      expect(progressEvents.length).toBeGreaterThan(0);
      expect(progressEvents[progressEvents.length - 1]).toBe(100);
    });
  });

  describe('导出选项验证', () => {
    test('应该验证必需的导出选项', () => {
      const invalidOptions = {
        format: ExportFormat.CSV
        // 缺少 filePath
      } as ExportOptions;

      expect(() => {
        exportManager.createExportTask(mockDataset, invalidOptions);
      }).toThrow('filePath is required');
    });

    test('应该验证文件路径格式', () => {
      const invalidOptions: ExportOptions = {
        format: ExportFormat.CSV,
        filePath: 'invalid-path-without-extension'
      };

      expect(() => {
        exportManager.createExportTask(mockDataset, invalidOptions);
      }).toThrow('Invalid file path');
    });

    test('应该验证导出格式兼容性', () => {
      const invalidOptions: ExportOptions = {
        format: ExportFormat.BINARY,
        filePath: '/tmp/export.csv', // CSV扩展名与Binary格式不匹配
        encoding: 'utf8' // Binary格式不支持文本编码
      };

      expect(() => {
        exportManager.createExportTask(mockDataset, invalidOptions);
      }).toThrow('Format and file extension mismatch');
    });

    test('应该提供默认导出选项', () => {
      const options: ExportOptions = {
        format: ExportFormat.JSON,
        filePath: '/tmp/export.json'
      };

      const taskId = exportManager.createExportTask(mockDataset, options);
      const task = exportManager.getTask(taskId);

      expect(task.options.includeMetadata).toBe(true); // 默认值
      expect(task.options.dateFormat).toBe('ISO'); // 默认值
      expect(task.options.encoding).toBe('utf8'); // 默认值
    });
  });

  describe('错误处理', () => {
    test('应该处理文件写入错误', async () => {
      const mockFS = vi.mocked(require('fs'));
      mockFS.writeFileSync.mockImplementation(() => {
        throw new Error('Permission denied');
      });

      const options: ExportOptions = {
        format: ExportFormat.TXT,
        filePath: '/readonly/export.txt'
      };

      const taskId = exportManager.createExportTask(mockDataset, options);
      const result = await exportManager.executeTask(taskId);

      expect(result.success).toBe(false);
      expect(result.error).toContain('Permission denied');
    });

    test('应该处理无效数据', async () => {
      const invalidData = [
        {
          id: 'invalid',
          value: undefined, // 无效值
          timestamp: 'not-a-number' // 无效时间戳
        }
      ] as Dataset[];

      const options: ExportOptions = {
        format: ExportFormat.CSV,
        filePath: '/tmp/invalid-export.csv',
        skipInvalidRecords: true
      };

      const taskId = exportManager.createExportTask(invalidData, options);
      const result = await exportManager.executeTask(taskId);

      expect(result.success).toBe(true);
      expect(result.recordsExported).toBe(0);
      expect(result.skippedRecords).toBe(1);
    });

    test('应该处理磁盘空间不足', async () => {
      const mockFS = vi.mocked(require('fs'));
      mockFS.writeFileSync.mockImplementation(() => {
        throw new Error('ENOSPC: no space left on device');
      });

      const options: ExportOptions = {
        format: ExportFormat.EXCEL,
        filePath: '/tmp/large-export.xlsx'
      };

      const taskId = exportManager.createExportTask(mockDataset, options);
      const result = await exportManager.executeTask(taskId);

      expect(result.success).toBe(false);
      expect(result.error).toContain('no space left');
    });

    test('应该清理失败的导出文件', async () => {
      const mockFS = vi.mocked(require('fs'));
      const unlinkSpy = vi.fn();
      mockFS.unlinkSync = unlinkSpy;

      mockFS.writeFileSync.mockImplementation(() => {
        throw new Error('Write failed');
      });

      const options: ExportOptions = {
        format: ExportFormat.JSON,
        filePath: '/tmp/failed-export.json',
        cleanupOnFailure: true
      };

      const taskId = exportManager.createExportTask(mockDataset, options);
      await exportManager.executeTask(taskId);

      expect(unlinkSpy).toHaveBeenCalledWith('/tmp/failed-export.json');
    });
  });

  describe('数据预处理', () => {
    test('应该过滤数据', () => {
      const filterOptions: ExportOptions = {
        format: ExportFormat.JSON,
        filePath: '/tmp/filtered.json',
        filter: {
          dateRange: {
            start: new Date('2023-12-19T12:00:30Z'),
            end: new Date('2023-12-19T12:01:30Z')
          },
          valueRange: {
            min: 20,
            max: 70
          }
        }
      };

      const taskId = exportManager.createExportTask(mockDataset, filterOptions);
      const task = exportManager.getTask(taskId);
      const filteredData = exportManager.applyFilters(mockDataset, filterOptions.filter);

      expect(filteredData).toHaveLength(2); // temperature 和 humidity 满足条件
      expect(filteredData.map(d => d.id)).toEqual(['temperature', 'humidity']);
    });

    test('应该转换数据格式', () => {
      const transformOptions: ExportOptions = {
        format: ExportFormat.CSV,
        filePath: '/tmp/transformed.csv',
        transforms: {
          roundDecimals: 1,
          convertUnits: {
            temperature: { from: 'C', to: 'F' },
            pressure: { from: 'hPa', to: 'mmHg' }
          }
        }
      };

      const taskId = exportManager.createExportTask(mockDataset, transformOptions);
      const transformedData = exportManager.applyTransforms(mockDataset, transformOptions.transforms);

      expect(transformedData[0].value).toBeCloseTo(78.1, 1); // 25.6°C -> 78.1°F
      expect(transformedData[2].value).toBeCloseTo(759.9, 1); // 1013.25hPa -> 759.9mmHg
    });

    test('应该聚合数据', () => {
      const aggregateOptions: ExportOptions = {
        format: ExportFormat.JSON,
        filePath: '/tmp/aggregated.json',
        aggregation: {
          method: 'average',
          interval: '1m', // 1分钟间隔
          fields: ['value']
        }
      };

      const taskId = exportManager.createExportTask(mockDataset, aggregateOptions);
      const aggregatedData = exportManager.applyAggregation(mockDataset, aggregateOptions.aggregation);

      expect(aggregatedData).toHaveLength(3); // 3个不同的时间间隔
    });

    test('应该排序数据', () => {
      const sortOptions: ExportOptions = {
        format: ExportFormat.CSV,
        filePath: '/tmp/sorted.csv',
        sort: {
          field: 'value',
          order: 'desc'
        }
      };

      const taskId = exportManager.createExportTask(mockDataset, sortOptions);
      const sortedData = exportManager.applySorting(mockDataset, sortOptions.sort);

      expect(sortedData[0].id).toBe('pressure'); // 最大值
      expect(sortedData[1].id).toBe('humidity');
      expect(sortedData[2].id).toBe('temperature'); // 最小值
    });
  });
});
```

### 3.2 格式转换器测试

```typescript
// tests/export/format-converters.test.ts
import { describe, test, expect, vi, beforeEach } from 'vitest';
import { CSVConverter } from '@/export/converters/csv-converter';
import { JSONConverter } from '@/export/converters/json-converter';
import { ExcelConverter } from '@/export/converters/excel-converter';
import { XMLConverter } from '@/export/converters/xml-converter';
import { Dataset } from '@/types/data';

describe('格式转换器测试', () => {
  let mockDataset: Dataset[];

  beforeEach(() => {
    mockDataset = [
      {
        id: 'temp',
        title: 'Temperature',
        value: 25.6,
        timestamp: 1703001600000,
        units: '°C',
        metadata: { location: 'Room A' }
      },
      {
        id: 'humidity',
        title: 'Humidity', 
        value: 65.2,
        timestamp: 1703001660000,
        units: '%',
        metadata: { location: 'Room A' }
      }
    ];
  });

  describe('CSV转换器测试', () => {
    test('应该正确转换为CSV格式', () => {
      const converter = new CSVConverter();
      const csvData = converter.convert(mockDataset);

      const lines = csvData.split('\n');
      expect(lines[0]).toBe('id,title,value,timestamp,units');
      expect(lines[1]).toBe('temp,Temperature,25.6,2023-12-19T12:00:00.000Z,°C');
      expect(lines[2]).toBe('humidity,Humidity,65.2,2023-12-19T12:01:00.000Z,%');
    });

    test('应该支持自定义分隔符', () => {
      const converter = new CSVConverter({ delimiter: ';' });
      const csvData = converter.convert(mockDataset);

      expect(csvData).toContain('id;title;value;timestamp;units');
      expect(csvData).toContain('temp;Temperature;25.6');
    });

    test('应该处理包含特殊字符的数据', () => {
      const specialData: Dataset[] = [
        {
          id: 'test',
          title: 'Test "with quotes"',
          value: 123,
          timestamp: Date.now(),
          units: 'units,with,commas',
          metadata: { note: 'Line\nbreak' }
        }
      ];

      const converter = new CSVConverter({ includeMetadata: true });
      const csvData = converter.convert(specialData);

      expect(csvData).toContain('"Test ""with quotes"""');
      expect(csvData).toContain('"units,with,commas"');
      expect(csvData).toContain('"Line\nbreak"');
    });

    test('应该支持包含元数据', () => {
      const converter = new CSVConverter({ includeMetadata: true });
      const csvData = converter.convert(mockDataset);

      expect(csvData).toContain('metadata.location');
      expect(csvData).toContain('Room A');
    });

    test('应该支持自定义日期格式', () => {
      const converter = new CSVConverter({ 
        dateFormat: 'YYYY-MM-DD HH:mm:ss' 
      });
      const csvData = converter.convert(mockDataset);

      expect(csvData).toContain('2023-12-19 12:00:00');
      expect(csvData).toContain('2023-12-19 12:01:00');
    });

    test('应该处理空数据', () => {
      const converter = new CSVConverter();
      const csvData = converter.convert([]);

      expect(csvData).toBe('');
    });

    test('应该处理数值精度', () => {
      const precisionData: Dataset[] = [
        {
          id: 'precise',
          value: 3.1415926535,
          timestamp: Date.now()
        }
      ];

      const converter = new CSVConverter({ decimalPlaces: 2 });
      const csvData = converter.convert(precisionData);

      expect(csvData).toContain('3.14');
    });
  });

  describe('JSON转换器测试', () => {
    test('应该正确转换为JSON格式', () => {
      const converter = new JSONConverter();
      const jsonData = converter.convert(mockDataset);
      const parsed = JSON.parse(jsonData);

      expect(Array.isArray(parsed)).toBe(true);
      expect(parsed).toHaveLength(2);
      expect(parsed[0]).toMatchObject({
        id: 'temp',
        title: 'Temperature',
        value: 25.6,
        units: '°C'
      });
    });

    test('应该支持美化输出', () => {
      const converter = new JSONConverter({ pretty: true });
      const jsonData = converter.convert(mockDataset);

      expect(jsonData).toContain('  '); // 包含缩进
      expect(jsonData).toContain('\n'); // 包含换行
    });

    test('应该支持嵌套结构', () => {
      const converter = new JSONConverter({ nested: true });
      const jsonData = converter.convert(mockDataset);
      const parsed = JSON.parse(jsonData);

      expect(parsed).toHaveProperty('data');
      expect(parsed).toHaveProperty('metadata');
      expect(parsed.data).toHaveLength(2);
      expect(parsed.metadata).toHaveProperty('exportTime');
      expect(parsed.metadata).toHaveProperty('recordCount');
    });

    test('应该支持自定义字段映射', () => {
      const converter = new JSONConverter({
        fieldMapping: {
          id: 'identifier',
          value: 'measurement',
          timestamp: 'time'
        }
      });
      const jsonData = converter.convert(mockDataset);
      const parsed = JSON.parse(jsonData);

      expect(parsed[0]).toHaveProperty('identifier');
      expect(parsed[0]).toHaveProperty('measurement');
      expect(parsed[0]).toHaveProperty('time');
      expect(parsed[0]).not.toHaveProperty('id');
    });

    test('应该处理循环引用', () => {
      const circularData = {
        id: 'circular',
        value: 123,
        timestamp: Date.now()
      };
      circularData.self = circularData; // 创建循环引用

      const converter = new JSONConverter();
      
      expect(() => {
        converter.convert([circularData as Dataset]);
      }).not.toThrow();
    });

    test('应该支持JSON Schema验证', () => {
      const converter = new JSONConverter({
        validateSchema: true,
        schema: {
          type: 'array',
          items: {
            type: 'object',
            required: ['id', 'value', 'timestamp'],
            properties: {
              id: { type: 'string' },
              value: { type: 'number' },
              timestamp: { type: 'number' }
            }
          }
        }
      });

      expect(() => {
        converter.convert(mockDataset);
      }).not.toThrow();
    });
  });

  describe('Excel转换器测试', () => {
    test('应该正确转换为Excel格式', async () => {
      const converter = new ExcelConverter();
      const excelBuffer = await converter.convert(mockDataset);

      expect(excelBuffer).toBeInstanceOf(Buffer);
      expect(excelBuffer.length).toBeGreaterThan(0);
    });

    test('应该支持多个工作表', async () => {
      const converter = new ExcelConverter({
        multiSheet: true,
        groupBy: 'units'
      });

      const excelBuffer = await converter.convert(mockDataset);
      
      // 使用exceljs读取验证
      const ExcelJS = require('exceljs');
      const workbook = new ExcelJS.Workbook();
      await workbook.xlsx.load(excelBuffer);

      expect(workbook.worksheets.length).toBe(2); // °C 和 % 两个工作表
    });

    test('应该支持样式设置', async () => {
      const converter = new ExcelConverter({
        styling: {
          headerStyle: {
            font: { bold: true },
            fill: { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFCCCCCC' } }
          },
          dataStyle: {
            alignment: { horizontal: 'center' }
          }
        }
      });

      const excelBuffer = await converter.convert(mockDataset);
      expect(excelBuffer.length).toBeGreaterThan(1000); // 样式会增加文件大小
    });

    test('应该支持图表生成', async () => {
      const converter = new ExcelConverter({
        includeChart: true,
        chartType: 'line',
        chartConfig: {
          title: 'Sensor Data',
          xAxis: 'timestamp',
          yAxis: 'value'
        }
      });

      const excelBuffer = await converter.convert(mockDataset);
      expect(excelBuffer.length).toBeGreaterThan(2000); // 图表会显著增加文件大小
    });

    test('应该处理大数据集', async () => {
      const largeDataset = Array.from({ length: 10000 }, (_, i) => ({
        id: `sensor${i}`,
        value: Math.random() * 100,
        timestamp: Date.now() + i * 1000
      })) as Dataset[];

      const converter = new ExcelConverter({ streamingMode: true });
      const excelBuffer = await converter.convert(largeDataset);

      expect(excelBuffer).toBeInstanceOf(Buffer);
      expect(excelBuffer.length).toBeGreaterThan(100000); // 大文件
    });
  });

  describe('XML转换器测试', () => {
    test('应该正确转换为XML格式', () => {
      const converter = new XMLConverter();
      const xmlData = converter.convert(mockDataset);

      expect(xmlData).toContain('<?xml version="1.0" encoding="UTF-8"?>');
      expect(xmlData).toContain('<data>');
      expect(xmlData).toContain('<record>');
      expect(xmlData).toContain('<id>temp</id>');
      expect(xmlData).toContain('<value>25.6</value>');
    });

    test('应该支持自定义根元素', () => {
      const converter = new XMLConverter({ 
        rootElement: 'sensorData',
        recordElement: 'measurement'
      });
      const xmlData = converter.convert(mockDataset);

      expect(xmlData).toContain('<sensorData>');
      expect(xmlData).toContain('<measurement>');
    });

    test('应该支持属性模式', () => {
      const converter = new XMLConverter({ 
        useAttributes: true 
      });
      const xmlData = converter.convert(mockDataset);

      expect(xmlData).toContain('<record id="temp" value="25.6"');
      expect(xmlData).toContain('timestamp="2023-12-19T12:00:00.000Z"');
    });

    test('应该处理特殊字符转义', () => {
      const specialData: Dataset[] = [
        {
          id: 'special',
          title: 'Test <>&"\'',
          value: 123,
          timestamp: Date.now()
        }
      ];

      const converter = new XMLConverter();
      const xmlData = converter.convert(specialData);

      expect(xmlData).toContain('&lt;&gt;&amp;&quot;&#39;');
    });

    test('应该支持命名空间', () => {
      const converter = new XMLConverter({
        namespace: 'http://serialstudio.io/export',
        namespacePrefix: 'ss'
      });
      const xmlData = converter.convert(mockDataset);

      expect(xmlData).toContain('xmlns:ss="http://serialstudio.io/export"');
      expect(xmlData).toContain('<ss:data>');
    });

    test('应该支持CDATA节', () => {
      const converter = new XMLConverter({
        useCDATA: ['title', 'metadata']
      });
      
      const cdataData: Dataset[] = [
        {
          id: 'test',
          title: 'Text with <special> characters',
          value: 123,
          timestamp: Date.now(),
          metadata: { note: 'HTML content: <p>Hello</p>' }
        }
      ];

      const xmlData = converter.convert(cdataData);

      expect(xmlData).toContain('<![CDATA[Text with <special> characters]]>');
      expect(xmlData).toContain('<![CDATA[HTML content: <p>Hello</p>]]>');
    });
  });

  describe('转换器性能测试', () => {
    test('CSV转换器性能', () => {
      const largeDataset = Array.from({ length: 10000 }, (_, i) => ({
        id: `item${i}`,
        value: Math.random() * 100,
        timestamp: Date.now() + i * 1000
      })) as Dataset[];

      const converter = new CSVConverter();
      const startTime = performance.now();
      
      const csvData = converter.convert(largeDataset);
      
      const duration = performance.now() - startTime;
      const recordsPerSecond = largeDataset.length / (duration / 1000);

      expect(recordsPerSecond).toBeGreaterThan(1000); // >1000 records/second
      expect(csvData.length).toBeGreaterThan(100000);
    });

    test('JSON转换器性能', () => {
      const largeDataset = Array.from({ length: 5000 }, (_, i) => ({
        id: `item${i}`,
        value: Math.random() * 100,
        timestamp: Date.now() + i * 1000,
        metadata: { index: i, random: Math.random() }
      })) as Dataset[];

      const converter = new JSONConverter();
      const startTime = performance.now();
      
      const jsonData = converter.convert(largeDataset);
      
      const duration = performance.now() - startTime;
      expect(duration).toBeLessThan(1000); // <1 second for 5k records

      const parsed = JSON.parse(jsonData);
      expect(parsed).toHaveLength(5000);
    });

    test('Excel转换器性能', async () => {
      const mediumDataset = Array.from({ length: 1000 }, (_, i) => ({
        id: `item${i}`,
        value: Math.random() * 100,
        timestamp: Date.now() + i * 1000
      })) as Dataset[];

      const converter = new ExcelConverter();
      const startTime = performance.now();
      
      const excelBuffer = await converter.convert(mediumDataset);
      
      const duration = performance.now() - startTime;
      expect(duration).toBeLessThan(5000); // <5 seconds for 1k records
      expect(excelBuffer.length).toBeGreaterThan(10000);
    });
  });
});
```

### 3.3 流式导出器测试

```typescript
// tests/export/stream-exporter.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { StreamExporter } from '@/export/stream-exporter';
import { Readable, Writable } from 'stream';

describe('流式导出器测试', () => {
  let streamExporter: StreamExporter;
  let mockWriteStream: any;
  let mockReadStream: any;

  beforeEach(() => {
    mockWriteStream = {
      write: vi.fn(),
      end: vi.fn(),
      on: vi.fn(),
      once: vi.fn(),
      emit: vi.fn()
    };

    mockReadStream = {
      pipe: vi.fn().mockReturnValue(mockWriteStream),
      on: vi.fn(),
      read: vi.fn(),
      push: vi.fn(),
      destroy: vi.fn()
    };

    streamExporter = new StreamExporter();

    // Mock fs.createWriteStream
    vi.doMock('fs', () => ({
      createWriteStream: vi.fn().mockReturnValue(mockWriteStream),
      createReadStream: vi.fn().mockReturnValue(mockReadStream)
    }));
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('流式数据导出', () => {
    test('应该创建数据流', async () => {
      const dataGenerator = async function* () {
        for (let i = 0; i < 100; i++) {
          yield {
            id: `item${i}`,
            value: i,
            timestamp: Date.now() + i * 1000
          };
        }
      };

      const stream = streamExporter.createDataStream(dataGenerator());

      expect(stream).toBeInstanceOf(Readable);
    });

    test('应该分批处理数据', async () => {
      const batchProcessor = vi.fn();
      
      const dataGenerator = async function* () {
        for (let i = 0; i < 1000; i++) {
          yield { id: `item${i}`, value: i };
        }
      };

      await streamExporter.processBatches(
        dataGenerator(),
        batchProcessor,
        { batchSize: 100 }
      );

      expect(batchProcessor).toHaveBeenCalledTimes(10); // 1000/100 = 10 batches
    });

    test('应该处理背压', async () => {
      const slowWriteStream = {
        write: vi.fn().mockImplementation((chunk, callback) => {
          // 模拟慢写入
          setTimeout(() => callback(), 100);
        }),
        end: vi.fn(),
        on: vi.fn()
      };

      const dataStream = new Readable({
        objectMode: true,
        read() {
          for (let i = 0; i < 10; i++) {
            this.push({ id: `item${i}`, value: i });
          }
          this.push(null);
        }
      });

      const startTime = Date.now();
      
      await streamExporter.pipeWithBackpressure(dataStream, slowWriteStream);
      
      const duration = Date.now() - startTime;
      expect(duration).toBeGreaterThan(500); // 应该等待慢写入完成
    });

    test('应该支持数据转换流', async () => {
      const transformStream = streamExporter.createTransformStream({
        objectMode: true,
        transform: (chunk, encoding, callback) => {
          // 转换数据格式
          const transformed = {
            ...chunk,
            value: chunk.value * 2,
            processed: true
          };
          callback(null, transformed);
        }
      });

      const inputData = [
        { id: 'test1', value: 10 },
        { id: 'test2', value: 20 }
      ];

      const outputData: any[] = [];
      
      transformStream.on('data', (chunk) => {
        outputData.push(chunk);
      });

      for (const data of inputData) {
        transformStream.write(data);
      }
      transformStream.end();

      await new Promise(resolve => transformStream.on('end', resolve));

      expect(outputData).toHaveLength(2);
      expect(outputData[0].value).toBe(20);
      expect(outputData[0].processed).toBe(true);
    });

    test('应该监控流式导出进度', async () => {
      const progressEvents: number[] = [];
      
      streamExporter.on('progress', (progress) => {
        progressEvents.push(progress);
      });

      const totalRecords = 1000;
      const dataGenerator = async function* () {
        for (let i = 0; i < totalRecords; i++) {
          yield { id: `item${i}`, value: i };
        }
      };

      await streamExporter.exportWithProgress(
        dataGenerator(),
        '/tmp/export.json',
        { totalRecords }
      );

      expect(progressEvents.length).toBeGreaterThan(0);
      expect(progressEvents[progressEvents.length - 1]).toBe(100);
    });
  });

  describe('大数据集处理', () => {
    test('应该处理超大数据集', async () => {
      const hugeDataGenerator = async function* () {
        for (let i = 0; i < 1000000; i++) { // 100万条记录
          yield {
            id: `record${i}`,
            value: Math.random() * 100,
            timestamp: Date.now() + i * 1000
          };
        }
      };

      const memoryBefore = process.memoryUsage().heapUsed;
      
      await streamExporter.exportLargeDataset(
        hugeDataGenerator(),
        '/tmp/huge-export.csv',
        { 
          format: 'csv',
          chunkSize: 10000,
          memoryLimit: '500MB'
        }
      );

      const memoryAfter = process.memoryUsage().heapUsed;
      const memoryIncrease = memoryAfter - memoryBefore;

      // 内存增长应该保持在合理范围内
      expect(memoryIncrease).toBeLessThan(100 * 1024 * 1024); // <100MB
    });

    test('应该支持分块并行处理', async () => {
      const processChunk = vi.fn().mockResolvedValue(undefined);
      
      const largeDataArray = Array.from({ length: 10000 }, (_, i) => ({
        id: `item${i}`,
        value: i
      }));

      await streamExporter.processChunksParallel(
        largeDataArray,
        processChunk,
        {
          chunkSize: 1000,
          maxParallel: 4
        }
      );

      expect(processChunk).toHaveBeenCalledTimes(10); // 10000/1000 = 10 chunks
    });

    test('应该处理内存限制', async () => {
      streamExporter.setMemoryLimit('50MB');

      const memoryCheckSpy = vi.spyOn(streamExporter, 'checkMemoryUsage');

      const dataGenerator = async function* () {
        for (let i = 0; i < 100000; i++) {
          yield { id: `item${i}`, data: 'x'.repeat(1000) }; // 大数据对象
        }
      };

      await streamExporter.exportWithMemoryManagement(
        dataGenerator(),
        '/tmp/memory-limited.json'
      );

      expect(memoryCheckSpy).toHaveBeenCalled();
    });

    test('应该支持暂停和恢复', async () => {
      const exportPromise = streamExporter.startExport({
        dataSource: createLargeDataGenerator(),
        destination: '/tmp/pausable-export.csv',
        format: 'csv'
      });

      // 导出开始后暂停
      setTimeout(() => {
        streamExporter.pauseExport();
      }, 100);

      // 1秒后恢复
      setTimeout(() => {
        streamExporter.resumeExport();
      }, 1100);

      const result = await exportPromise;

      expect(result.success).toBe(true);
      expect(result.paused).toBe(true); // 曾经被暂停过
    });
  });

  describe('错误处理和恢复', () => {
    test('应该处理流错误', async () => {
      const errorStream = new Readable({
        read() {
          this.emit('error', new Error('Stream error'));
        }
      });

      await expect(
        streamExporter.handleStreamError(errorStream, '/tmp/error-test.csv')
      ).rejects.toThrow('Stream error');
    });

    test('应该支持断点续传', async () => {
      const partialFile = '/tmp/partial-export.csv';
      
      // 模拟部分导出文件存在
      vi.doMock('fs', () => ({
        existsSync: vi.fn().mockReturnValue(true),
        statSync: vi.fn().mockReturnValue({ size: 5000 }),
        createWriteStream: vi.fn().mockReturnValue(mockWriteStream)
      }));

      const resumeResult = await streamExporter.resumeExport(partialFile, {
        totalRecords: 10000,
        lastProcessedRecord: 2500
      });

      expect(resumeResult.resumed).toBe(true);
      expect(resumeResult.startFromRecord).toBe(2501);
    });

    test('应该处理磁盘写入错误', async () => {
      mockWriteStream.write.mockImplementation(() => {
        throw new Error('ENOSPC: no space left on device');
      });

      const dataGenerator = async function* () {
        yield { id: 'test', value: 123 };
      };

      await expect(
        streamExporter.exportStream(dataGenerator(), '/tmp/no-space.csv')
      ).rejects.toThrow('no space left');
    });

    test('应该自动重试失败的操作', async () => {
      let attemptCount = 0;
      const flakyWriteStream = {
        write: vi.fn().mockImplementation(() => {
          attemptCount++;
          if (attemptCount < 3) {
            throw new Error('Temporary failure');
          }
          return true;
        }),
        end: vi.fn(),
        on: vi.fn()
      };

      const result = await streamExporter.exportWithRetry(
        [{ id: 'test', value: 123 }],
        flakyWriteStream,
        { maxRetries: 3, retryDelay: 100 }
      );

      expect(result.success).toBe(true);
      expect(result.retryCount).toBe(2);
      expect(attemptCount).toBe(3);
    });
  });

  describe('性能优化', () => {
    test('应该使用对象池减少GC压力', async () => {
      const objectPool = streamExporter.createObjectPool(
        () => ({ id: '', value: 0, timestamp: 0 }),
        (obj) => {
          obj.id = '';
          obj.value = 0;
          obj.timestamp = 0;
        }
      );

      const gcCountBefore = global.gc ? global.gc() : 0;

      for (let i = 0; i < 10000; i++) {
        const obj = objectPool.acquire();
        obj.id = `item${i}`;
        obj.value = i;
        obj.timestamp = Date.now();
        
        // 使用对象...
        
        objectPool.release(obj);
      }

      const gcCountAfter = global.gc ? global.gc() : 0;

      expect(objectPool.getPoolSize()).toBeGreaterThan(0);
      // GC调用次数应该较少
    });

    test('应该优化字符串操作', () => {
      const stringBuilder = streamExporter.createStringBuilder();

      for (let i = 0; i < 1000; i++) {
        stringBuilder.append(`item${i},${i},${Date.now()}\n`);
      }

      const result = stringBuilder.toString();
      
      expect(result.length).toBeGreaterThan(10000);
      expect(result.split('\n')).toHaveLength(1000);
    });

    test('应该支持压缩输出', async () => {
      const compressedStream = streamExporter.createCompressedStream({
        format: 'gzip',
        level: 6
      });

      const testData = 'x'.repeat(10000); // 高度可压缩的数据
      compressedStream.write(testData);
      compressedStream.end();

      const chunks: Buffer[] = [];
      compressedStream.on('data', (chunk) => chunks.push(chunk));
      
      await new Promise(resolve => compressedStream.on('end', resolve));

      const compressedSize = Buffer.concat(chunks).length;
      expect(compressedSize).toBeLessThan(testData.length / 10); // 压缩率 >90%
    });
  });

  function createLargeDataGenerator() {
    return async function* () {
      for (let i = 0; i < 50000; i++) {
        yield {
          id: `record${i}`,
          value: Math.random() * 100,
          timestamp: Date.now() + i * 1000
        };
      }
    };
  }
});
```

### 3.4 用户界面测试

```typescript
// tests/export/export-dialog.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { mount, VueWrapper } from '@vue/test-utils';
import { nextTick } from 'vue';
import ExportDialog from '@/components/export/ExportDialog.vue';
import { ExportFormat } from '@/types/export';

describe('导出对话框测试', () => {
  let wrapper: VueWrapper<any>;
  let mockDataset: any[];

  beforeEach(() => {
    mockDataset = [
      {
        id: 'temperature',
        title: 'Temperature',
        value: 25.6,
        timestamp: Date.now(),
        units: '°C'
      }
    ];

    wrapper = mount(ExportDialog, {
      props: {
        visible: true,
        dataset: mockDataset
      },
      global: {
        stubs: {
          'el-dialog': true,
          'el-form': true,
          'el-form-item': true,
          'el-select': true,
          'el-option': true,
          'el-input': true,
          'el-checkbox': true,
          'el-button': true,
          'el-progress': true
        }
      }
    });
  });

  afterEach(() => {
    wrapper?.unmount();
    vi.clearAllMocks();
  });

  describe('对话框渲染', () => {
    test('应该正确渲染导出表单', () => {
      expect(wrapper.find('[data-testid="export-format-select"]').exists()).toBe(true);
      expect(wrapper.find('[data-testid="file-path-input"]').exists()).toBe(true);
      expect(wrapper.find('[data-testid="export-options"]').exists()).toBe(true);
    });

    test('应该显示数据集信息', () => {
      const datasetInfo = wrapper.find('[data-testid="dataset-info"]');
      expect(datasetInfo.exists()).toBe(true);
      expect(datasetInfo.text()).toContain('1 records');
    });

    test('应该根据格式显示相应选项', async () => {
      // 选择CSV格式
      await wrapper.setData({ exportFormat: ExportFormat.CSV });
      await nextTick();

      expect(wrapper.find('[data-testid="csv-delimiter"]').exists()).toBe(true);
      expect(wrapper.find('[data-testid="include-header"]').exists()).toBe(true);

      // 选择Excel格式
      await wrapper.setData({ exportFormat: ExportFormat.EXCEL });
      await nextTick();

      expect(wrapper.find('[data-testid="excel-sheet-name"]').exists()).toBe(true);
      expect(wrapper.find('[data-testid="include-chart"]').exists()).toBe(true);
    });

    test('应该显示预览数据', async () => {
      await wrapper.find('[data-testid="preview-button"]').trigger('click');
      await nextTick();

      const preview = wrapper.find('[data-testid="data-preview"]');
      expect(preview.exists()).toBe(true);
      expect(preview.text()).toContain('temperature');
      expect(preview.text()).toContain('25.6');
    });
  });

  describe('表单验证', () => {
    test('应该验证必填字段', async () => {
      await wrapper.setData({ filePath: '' });
      await wrapper.find('[data-testid="export-button"]').trigger('click');
      await nextTick();

      const errorMessage = wrapper.find('[data-testid="error-message"]');
      expect(errorMessage.exists()).toBe(true);
      expect(errorMessage.text()).toContain('File path is required');
    });

    test('应该验证文件扩展名', async () => {
      await wrapper.setData({ 
        exportFormat: ExportFormat.CSV,
        filePath: '/tmp/export.json' // 错误的扩展名
      });

      await wrapper.find('[data-testid="export-button"]').trigger('click');
      await nextTick();

      const errorMessage = wrapper.find('[data-testid="error-message"]');
      expect(errorMessage.text()).toContain('File extension must be .csv');
    });

    test('应该验证数值范围', async () => {
      await wrapper.setData({
        exportOptions: {
          filter: {
            valueRange: {
              min: 100,
              max: 50 // min > max
            }
          }
        }
      });

      await wrapper.find('[data-testid="export-button"]').trigger('click');
      await nextTick();

      const errorMessage = wrapper.find('[data-testid="error-message"]');
      expect(errorMessage.text()).toContain('Min value must be less than max');
    });

    test('应该实时验证文件路径', async () => {
      const pathInput = wrapper.find('[data-testid="file-path-input"]');
      
      await pathInput.setValue('/invalid/path');
      await nextTick();

      const pathError = wrapper.find('[data-testid="path-error"]');
      expect(pathError.exists()).toBe(true);
    });
  });

  describe('导出执行', () => {
    test('应该开始导出过程', async () => {
      await wrapper.setData({
        exportFormat: ExportFormat.JSON,
        filePath: '/tmp/export.json'
      });

      await wrapper.find('[data-testid="export-button"]').trigger('click');

      expect(wrapper.emitted('export-started')).toBeTruthy();
      expect(wrapper.vm.isExporting).toBe(true);
    });

    test('应该显示导出进度', async () => {
      await wrapper.setData({ isExporting: true, exportProgress: 45 });
      await nextTick();

      const progressBar = wrapper.find('[data-testid="export-progress"]');
      expect(progressBar.exists()).toBe(true);
      expect(progressBar.attributes('percentage')).toBe('45');
    });

    test('应该处理导出成功', async () => {
      await wrapper.vm.handleExportSuccess({
        filePath: '/tmp/export.json',
        recordsExported: 100,
        fileSize: 2048
      });

      expect(wrapper.emitted('export-completed')).toBeTruthy();
      expect(wrapper.vm.isExporting).toBe(false);
      
      const successMessage = wrapper.find('[data-testid="success-message"]');
      expect(successMessage.text()).toContain('Export completed');
      expect(successMessage.text()).toContain('100 records');
    });

    test('应该处理导出错误', async () => {
      await wrapper.vm.handleExportError(new Error('Export failed'));

      expect(wrapper.vm.isExporting).toBe(false);
      
      const errorMessage = wrapper.find('[data-testid="error-message"]');
      expect(errorMessage.text()).toContain('Export failed');
    });

    test('应该支持取消导出', async () => {
      await wrapper.setData({ isExporting: true });
      await nextTick();

      await wrapper.find('[data-testid="cancel-button"]').trigger('click');

      expect(wrapper.emitted('export-cancelled')).toBeTruthy();
    });
  });

  describe('高级选项', () => {
    test('应该配置数据过滤', async () => {
      await wrapper.find('[data-testid="show-advanced"]').trigger('click');
      await nextTick();

      const dateRangeStart = wrapper.find('[data-testid="date-range-start"]');
      const dateRangeEnd = wrapper.find('[data-testid="date-range-end"]');

      await dateRangeStart.setValue('2023-01-01');
      await dateRangeEnd.setValue('2023-12-31');

      expect(wrapper.vm.exportOptions.filter.dateRange.start).toEqual(
        new Date('2023-01-01')
      );
    });

    test('应该配置数据转换', async () => {
      await wrapper.find('[data-testid="show-advanced"]').trigger('click');
      await nextTick();

      const roundDecimals = wrapper.find('[data-testid="round-decimals"]');
      await roundDecimals.setValue('2');

      expect(wrapper.vm.exportOptions.transforms.roundDecimals).toBe(2);
    });

    test('应该预估文件大小', async () => {
      await wrapper.setData({
        exportFormat: ExportFormat.CSV,
        dataset: Array.from({ length: 1000 }, (_, i) => ({
          id: `item${i}`,
          value: i
        }))
      });

      await wrapper.vm.estimateFileSize();
      await nextTick();

      const sizeEstimate = wrapper.find('[data-testid="size-estimate"]');
      expect(sizeEstimate.text()).toContain('KB');
    });

    test('应该支持导出模板', async () => {
      const templates = wrapper.vm.getExportTemplates();
      
      expect(templates).toContain('sensor-data-csv');
      expect(templates).toContain('time-series-json');
      expect(templates).toContain('excel-report');

      await wrapper.vm.applyTemplate('sensor-data-csv');

      expect(wrapper.vm.exportFormat).toBe(ExportFormat.CSV);
      expect(wrapper.vm.exportOptions.includeMetadata).toBe(true);
    });
  });

  describe('用户体验', () => {
    test('应该保存用户设置', async () => {
      const mockLocalStorage = {
        setItem: vi.fn(),
        getItem: vi.fn(),
        removeItem: vi.fn()
      };

      global.localStorage = mockLocalStorage as any;

      await wrapper.setData({
        exportFormat: ExportFormat.EXCEL,
        exportOptions: { includeMetadata: false }
      });

      await wrapper.vm.saveUserPreferences();

      expect(mockLocalStorage.setItem).toHaveBeenCalledWith(
        'serialstudio.export.preferences',
        JSON.stringify({
          format: ExportFormat.EXCEL,
          options: { includeMetadata: false }
        })
      );
    });

    test('应该恢复用户设置', () => {
      const mockPreferences = {
        format: ExportFormat.XML,
        options: { includeMetadata: true }
      };

      const mockLocalStorage = {
        getItem: vi.fn().mockReturnValue(JSON.stringify(mockPreferences)),
        setItem: vi.fn(),
        removeItem: vi.fn()
      };

      global.localStorage = mockLocalStorage as any;

      wrapper.vm.restoreUserPreferences();

      expect(wrapper.vm.exportFormat).toBe(ExportFormat.XML);
      expect(wrapper.vm.exportOptions.includeMetadata).toBe(true);
    });

    test('应该提供键盘快捷键', async () => {
      await wrapper.trigger('keydown', { key: 'Enter', ctrlKey: true });

      expect(wrapper.emitted('export-started')).toBeTruthy();
    });

    test('应该支持拖拽设置文件路径', async () => {
      const dropEvent = {
        preventDefault: vi.fn(),
        stopPropagation: vi.fn(),
        dataTransfer: {
          files: [{ path: '/tmp/dropped-export.csv' }]
        }
      };

      await wrapper.find('[data-testid="file-path-input"]').trigger('drop', dropEvent);

      expect(wrapper.vm.filePath).toBe('/tmp/dropped-export.csv');
    });
  });
});
```

## 4. 性能基准测试

```typescript
// tests/export/performance.bench.ts
import { bench, describe } from 'vitest';
import { CSVConverter } from '@/export/converters/csv-converter';
import { JSONConverter } from '@/export/converters/json-converter';
import { ExcelConverter } from '@/export/converters/excel-converter';
import { StreamExporter } from '@/export/stream-exporter';

describe('数据导出模块性能基准测试', () => {
  const createTestData = (size: number) => {
    return Array.from({ length: size }, (_, i) => ({
      id: `item${i}`,
      value: Math.random() * 100,
      timestamp: Date.now() + i * 1000,
      metadata: { index: i }
    }));
  };

  bench('CSV转换性能 - 1K记录', () => {
    const converter = new CSVConverter();
    const data = createTestData(1000);
    converter.convert(data);
  });

  bench('JSON转换性能 - 1K记录', () => {
    const converter = new JSONConverter();
    const data = createTestData(1000);
    converter.convert(data);
  });

  bench('Excel转换性能 - 500记录', async () => {
    const converter = new ExcelConverter();
    const data = createTestData(500);
    await converter.convert(data);
  });

  bench('流式导出性能 - 10K记录', async () => {
    const exporter = new StreamExporter();
    const data = createTestData(10000);
    
    const generator = async function* () {
      for (const item of data) {
        yield item;
      }
    };

    await exporter.exportStream(generator(), '/tmp/benchmark.json');
  });

  bench('大数据集内存使用 - 100K记录', () => {
    const data = createTestData(100000);
    const converter = new CSVConverter();
    
    const memoryBefore = process.memoryUsage().heapUsed;
    converter.convert(data);
    const memoryAfter = process.memoryUsage().heapUsed;
    
    const memoryIncrease = memoryAfter - memoryBefore;
    console.log(`Memory increase: ${memoryIncrease / 1024 / 1024}MB`);
  });
});
```

这个详细的数据导出模块单元测试方案涵盖了导出管理、格式转换、流式处理、用户界面等各个核心组件，确保数据导出功能的可靠性和高性能表现。