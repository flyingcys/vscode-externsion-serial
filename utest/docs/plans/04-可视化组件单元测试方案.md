# 可视化组件单元测试方案

## 1. 模块概述

可视化组件模块是Serial-Studio VSCode插件的用户界面核心，基于Vue3 + Element Plus实现13种不同类型的数据可视化组件。模块采用Composition API设计模式，支持20Hz实时数据更新，具有高性能渲染和丰富交互功能要求。

### 1.1 模块架构

```
┌─────────────────────────────────────────────────────────────┐
│                    可视化组件架构                            │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   基础组件      │  │   图表组件       │  │  3D渲染组件   │ │
│  │ - BaseWidget    │  │ - PlotWidget     │  │ - Plot3D     │ │
│  │ - 通用接口       │  │ - MultiPlot      │  │ - WebGL渲染   │ │
│  │ - 生命周期       │  │ - Chart.js集成   │  │ - Three.js    │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   仪表组件      │  │   地图组件       │  │  数据组件     │ │
│  │ - GaugeWidget   │  │ - GPSWidget      │  │ - DataGrid   │ │
│  │ - BarWidget     │  │ - Leaflet集成    │  │ - TerminalWidget │ │
│  │ - LEDPanel      │  │ - 地理数据       │  │ - FFTWidget   │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 测试目标

- **功能完整性**：验证13种组件的渲染和交互功能
- **性能指标**：20Hz数据更新，60fps渲染帧率
- **Vue3兼容性**：Composition API和响应式系统正确性
- **用户交互**：鼠标、键盘、触摸等交互事件处理
- **主题适配**：多主题支持和动态切换

## 2. 测试覆盖率目标

| 测试类型 | 覆盖率目标 | 优先级 | 说明 |
|---------|-----------|--------|------|
| 行覆盖率 | ≥95% | P0 | 用户体验核心模块 |
| 分支覆盖率 | ≥88% | P0 | 包含所有交互分支 |
| 函数覆盖率 | ≥98% | P0 | 所有组件接口必须测试 |
| 语句覆盖率 | ≥95% | P0 | 确保渲染逻辑完全验证 |

## 3. 详细测试用例设计

### 3.1 基础组件框架测试

```typescript
// tests/visualization/base-widget.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { mount, VueWrapper } from '@vue/test-utils';
import { nextTick } from 'vue';
import { BaseWidget } from '@/components/visualization/BaseWidget.vue';
import { Dataset, WidgetConfig } from '@/types';

describe('BaseWidget基础组件测试', () => {
  let wrapper: VueWrapper<any>;
  let mockDataset: Dataset;
  let mockConfig: WidgetConfig;

  beforeEach(() => {
    mockDataset = {
      id: 'test-dataset',
      title: 'Test Dataset',
      value: 42,
      timestamp: Date.now(),
      units: 'V',
      graph: true,
      fftPlot: false,
      ledPanel: false
    };

    mockConfig = {
      title: 'Test Widget',
      showTitle: true,
      exportable: true,
      resizable: true,
      refreshRate: 20
    };
  });

  afterEach(() => {
    wrapper?.unmount();
    vi.clearAllMocks();
  });

  describe('组件初始化和Props', () => {
    test('应该正确接收和验证Props', () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: mockConfig,
          widgetType: 'gauge'
        }
      });

      expect(wrapper.props('dataset')).toEqual(mockDataset);
      expect(wrapper.props('config')).toEqual(mockConfig);
      expect(wrapper.props('widgetType')).toBe('gauge');
    });

    test('应该提供默认配置', () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          widgetType: 'gauge'
        }
      });

      const defaultConfig = wrapper.vm.mergedConfig;
      expect(defaultConfig.showTitle).toBe(true);
      expect(defaultConfig.exportable).toBe(true);
      expect(defaultConfig.resizable).toBe(true);
    });

    test('应该验证必需的Props', () => {
      // 测试缺少dataset的情况
      expect(() => {
        mount(BaseWidget, {
          props: {
            widgetType: 'gauge'
          }
        });
      }).toThrow();
    });

    test('应该正确合并默认配置和用户配置', () => {
      const partialConfig = {
        title: 'Custom Title',
        showTitle: false
      };

      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: partialConfig,
          widgetType: 'gauge'
        }
      });

      const merged = wrapper.vm.mergedConfig;
      expect(merged.title).toBe('Custom Title');
      expect(merged.showTitle).toBe(false);
      expect(merged.exportable).toBe(true); // 默认值
    });
  });

  describe('组件生命周期', () => {
    test('应该在mounted时初始化组件', async () => {
      const initializeSpy = vi.fn();
      
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: mockConfig,
          widgetType: 'gauge'
        },
        global: {
          mixins: [{
            mounted() {
              initializeSpy();
            }
          }]
        }
      });

      await nextTick();
      expect(initializeSpy).toHaveBeenCalled();
    });

    test('应该在unmounted时清理资源', async () => {
      const cleanupSpy = vi.fn();

      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: mockConfig,
          widgetType: 'gauge'
        },
        global: {
          mixins: [{
            beforeUnmount() {
              cleanupSpy();
            }
          }]
        }
      });

      wrapper.unmount();
      expect(cleanupSpy).toHaveBeenCalled();
    });

    test('应该响应数据变化', async () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: mockConfig,
          widgetType: 'gauge'
        }
      });

      const updateSpy = vi.spyOn(wrapper.vm, 'updateWidget');

      // 更新数据
      const newDataset = { ...mockDataset, value: 55 };
      await wrapper.setProps({ dataset: newDataset });

      expect(updateSpy).toHaveBeenCalledWith(newDataset);
    });
  });

  describe('事件处理', () => {
    test('应该触发导出事件', async () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: mockConfig,
          widgetType: 'gauge'
        }
      });

      await wrapper.vm.handleExport();

      expect(wrapper.emitted('export')).toBeTruthy();
      expect(wrapper.emitted('export')[0]).toEqual([
        expect.objectContaining({
          type: 'gauge',
          data: mockDataset,
          timestamp: expect.any(Number)
        })
      ]);
    });

    test('应该触发调整大小事件', async () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: mockConfig,
          widgetType: 'gauge'
        }
      });

      const newSize = { width: 400, height: 300 };
      await wrapper.vm.handleResize(newSize);

      expect(wrapper.emitted('resize')).toBeTruthy();
      expect(wrapper.emitted('resize')[0]).toEqual([newSize]);
    });

    test('应该处理错误事件', async () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: mockConfig,
          widgetType: 'gauge'
        }
      });

      const error = new Error('Test error');
      await wrapper.vm.handleError(error);

      expect(wrapper.emitted('error')).toBeTruthy();
      expect(wrapper.emitted('error')[0]).toEqual([error]);
    });
  });

  describe('响应式数据', () => {
    test('应该正确计算显示状态', async () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: { ...mockConfig, showTitle: true },
          widgetType: 'gauge'
        }
      });

      expect(wrapper.vm.shouldShowTitle).toBe(true);
      expect(wrapper.vm.isExportable).toBe(true);
      expect(wrapper.vm.isResizable).toBe(true);
    });

    test('应该监听数据变化并更新状态', async () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: mockConfig,
          widgetType: 'gauge'
        }
      });

      // 初始状态
      expect(wrapper.vm.currentValue).toBe(42);

      // 更新数据
      const newDataset = { ...mockDataset, value: 100 };
      await wrapper.setProps({ dataset: newDataset });
      await nextTick();

      expect(wrapper.vm.currentValue).toBe(100);
    });

    test('应该缓存计算属性', async () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: mockConfig,
          widgetType: 'gauge'
        }
      });

      const computeSpy = vi.spyOn(wrapper.vm, 'computeDisplayValue');
      
      // 多次访问同一计算属性
      const value1 = wrapper.vm.displayValue;
      const value2 = wrapper.vm.displayValue;
      const value3 = wrapper.vm.displayValue;

      expect(value1).toBe(value2);
      expect(value2).toBe(value3);
      expect(computeSpy).toHaveBeenCalledTimes(1); // 应该只计算一次
    });
  });

  describe('主题和样式', () => {
    test('应该应用默认主题', () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: mockConfig,
          widgetType: 'gauge'
        }
      });

      const element = wrapper.find('.base-widget');
      expect(element.classes()).toContain('theme-default');
    });

    test('应该支持主题切换', async () => {
      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: { ...mockConfig, theme: 'dark' },
          widgetType: 'gauge'
        }
      });

      const element = wrapper.find('.base-widget');
      expect(element.classes()).toContain('theme-dark');

      // 切换主题
      await wrapper.setProps({ 
        config: { ...mockConfig, theme: 'light' }
      });
      await nextTick();

      expect(element.classes()).toContain('theme-light');
    });

    test('应该应用自定义样式', () => {
      const customStyle = {
        backgroundColor: '#ff0000',
        borderRadius: '10px'
      };

      wrapper = mount(BaseWidget, {
        props: {
          dataset: mockDataset,
          config: { ...mockConfig, customStyle },
          widgetType: 'gauge'
        }
      });

      const element = wrapper.find('.base-widget');
      expect(element.attributes('style')).toContain('background-color: rgb(255, 0, 0)');
      expect(element.attributes('style')).toContain('border-radius: 10px');
    });
  });
});
```

### 3.2 实时图表组件测试

```typescript
// tests/visualization/plot-widget.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { mount, VueWrapper } from '@vue/test-utils';
import { nextTick } from 'vue';
import PlotWidget from '@/components/visualization/PlotWidget.vue';
import { Chart } from 'chart.js';

// Mock Chart.js
vi.mock('chart.js', () => ({
  Chart: vi.fn().mockImplementation(() => ({
    data: { datasets: [] },
    update: vi.fn(),
    destroy: vi.fn(),
    resize: vi.fn(),
    getDatasetMeta: vi.fn().mockReturnValue({ data: [] }),
    canvas: {
      getContext: vi.fn().mockReturnValue({
        clearRect: vi.fn(),
        fillRect: vi.fn(),
        drawImage: vi.fn()
      })
    }
  })),
  registerables: []
}));

describe('PlotWidget实时图表组件测试', () => {
  let wrapper: VueWrapper<any>;
  let mockChart: any;
  let mockDataset: any;

  beforeEach(() => {
    mockChart = {
      data: { datasets: [] },
      update: vi.fn(),
      destroy: vi.fn(),
      resize: vi.fn(),
      getDatasetMeta: vi.fn().mockReturnValue({ data: [] }),
      canvas: {
        getContext: vi.fn().mockReturnValue({
          clearRect: vi.fn(),
          fillRect: vi.fn(),
          drawImage: vi.fn()
        })
      }
    };

    vi.mocked(Chart).mockReturnValue(mockChart);

    mockDataset = {
      id: 'temperature',
      title: 'Temperature',
      value: 25.6,
      timestamp: Date.now(),
      units: '°C',
      graph: true,
      history: Array.from({ length: 100 }, (_, i) => ({
        value: 20 + Math.sin(i * 0.1) * 5,
        timestamp: Date.now() - (100 - i) * 1000
      }))
    };
  });

  afterEach(() => {
    wrapper?.unmount();
    vi.clearAllMocks();
  });

  describe('图表初始化', () => {
    test('应该正确初始化Chart.js实例', async () => {
      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: {
            chartType: 'line',
            maxDataPoints: 100,
            updateInterval: 50 // 20Hz
          }
        }
      });

      await nextTick();

      expect(Chart).toHaveBeenCalledWith(
        expect.any(HTMLCanvasElement),
        expect.objectContaining({
          type: 'line',
          data: expect.objectContaining({
            datasets: expect.arrayContaining([
              expect.objectContaining({
                label: 'Temperature',
                data: expect.any(Array)
              })
            ])
          })
        })
      );
    });

    test('应该配置图表选项', async () => {
      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: {
            chartType: 'line',
            showGrid: true,
            showLegend: false,
            animation: false
          }
        }
      });

      await nextTick();

      const chartConfig = vi.mocked(Chart).mock.calls[0][1];
      expect(chartConfig.options.scales.x.grid.display).toBe(true);
      expect(chartConfig.options.plugins.legend.display).toBe(false);
      expect(chartConfig.options.animation).toBe(false);
    });

    test('应该支持多种图表类型', async () => {
      const chartTypes = ['line', 'bar', 'scatter', 'area'];

      for (const chartType of chartTypes) {
        const testWrapper = mount(PlotWidget, {
          props: {
            dataset: mockDataset,
            config: { chartType }
          }
        });

        await nextTick();

        expect(Chart).toHaveBeenCalledWith(
          expect.any(HTMLCanvasElement),
          expect.objectContaining({
            type: chartType === 'area' ? 'line' : chartType
          })
        );

        testWrapper.unmount();
        vi.clearAllMocks();
      }
    });
  });

  describe('实时数据更新', () => {
    test('应该以20Hz频率更新数据', async () => {
      vi.useFakeTimers();

      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: {
            updateInterval: 50, // 20Hz
            maxDataPoints: 100
          }
        }
      });

      await nextTick();

      // 模拟数据更新
      for (let i = 0; i < 5; i++) {
        const newDataset = {
          ...mockDataset,
          value: 25 + i,
          timestamp: Date.now() + i * 50
        };

        await wrapper.setProps({ dataset: newDataset });
        vi.advanceTimersByTime(50);
      }

      expect(mockChart.update).toHaveBeenCalledTimes(5);
      vi.useRealTimers();
    });

    test('应该限制数据点数量', async () => {
      const maxDataPoints = 50;

      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: { maxDataPoints }
        }
      });

      await nextTick();

      // 添加大量数据点
      const manyDataPoints = Array.from({ length: 100 }, (_, i) => ({
        value: i,
        timestamp: Date.now() + i * 100
      }));

      for (const dataPoint of manyDataPoints) {
        await wrapper.vm.addDataPoint(dataPoint);
      }

      const chartData = wrapper.vm.chartData.datasets[0].data;
      expect(chartData.length).toBeLessThanOrEqual(maxDataPoints);
    });

    test('应该正确处理数据队列', async () => {
      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: {
            maxDataPoints: 10,
            bufferSize: 20
          }
        }
      });

      await nextTick();

      // 添加数据到队列
      for (let i = 0; i < 15; i++) {
        await wrapper.vm.addDataPoint({
          value: i,
          timestamp: Date.now() + i * 100
        });
      }

      // 检查队列管理
      expect(wrapper.vm.dataQueue.length).toBe(10);
      expect(wrapper.vm.dataQueue[0].value).toBe(5); // 最老的5个数据应该被移除
    });
  });

  describe('图表交互', () => {
    test('应该支持缩放功能', async () => {
      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: {
            enableZoom: true,
            enablePan: true
          }
        }
      });

      await nextTick();

      const chartConfig = vi.mocked(Chart).mock.calls[0][1];
      expect(chartConfig.options.plugins.zoom).toBeDefined();
      expect(chartConfig.options.plugins.zoom.zoom.wheel.enabled).toBe(true);
      expect(chartConfig.options.plugins.zoom.pan.enabled).toBe(true);
    });

    test('应该处理鼠标悬停事件', async () => {
      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: {
            showTooltip: true
          }
        }
      });

      await nextTick();

      // 模拟鼠标悬停
      const canvas = wrapper.find('canvas');
      await canvas.trigger('mousemove', {
        clientX: 100,
        clientY: 100
      });

      // 验证tooltip配置
      const chartConfig = vi.mocked(Chart).mock.calls[0][1];
      expect(chartConfig.options.plugins.tooltip.enabled).toBe(true);
    });

    test('应该支持数据点选择', async () => {
      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: {
            enableSelection: true
          }
        }
      });

      await nextTick();

      // 模拟点击数据点
      const canvas = wrapper.find('canvas');
      await canvas.trigger('click', {
        clientX: 150,
        clientY: 150
      });

      expect(wrapper.emitted('dataPointSelected')).toBeTruthy();
    });
  });

  describe('性能优化', () => {
    test('应该使用Canvas优化渲染', async () => {
      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: {
            useCanvasOptimization: true,
            renderingQuality: 'high'
          }
        }
      });

      await nextTick();

      const canvas = wrapper.find('canvas').element as HTMLCanvasElement;
      expect(canvas.getContext('2d')).toBeDefined();
    });

    test('应该优化大数据集渲染', async () => {
      const largeDataset = {
        ...mockDataset,
        history: Array.from({ length: 10000 }, (_, i) => ({
          value: Math.sin(i * 0.01),
          timestamp: Date.now() - i * 100
        }))
      };

      const startTime = performance.now();

      wrapper = mount(PlotWidget, {
        props: {
          dataset: largeDataset,
          config: {
            enableDataSampling: true,
            samplingThreshold: 1000
          }
        }
      });

      await nextTick();

      const renderTime = performance.now() - startTime;
      expect(renderTime).toBeLessThan(500); // 渲染时间应小于500ms

      // 验证数据采样
      const chartData = wrapper.vm.chartData.datasets[0].data;
      expect(chartData.length).toBeLessThanOrEqual(1000);
    });

    test('应该实现增量更新', async () => {
      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: {
            enableIncrementalUpdate: true
          }
        }
      });

      await nextTick();

      const updateSpy = vi.spyOn(wrapper.vm, 'incrementalUpdate');

      // 添加新数据点
      const newDataset = {
        ...mockDataset,
        value: 30,
        timestamp: Date.now()
      };

      await wrapper.setProps({ dataset: newDataset });

      expect(updateSpy).toHaveBeenCalled();
      expect(mockChart.update).toHaveBeenCalledWith('none'); // 增量更新模式
    });
  });

  describe('数据导出', () => {
    test('应该导出图表为图片', async () => {
      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset
        }
      });

      await nextTick();

      // Mock canvas.toDataURL
      const mockToDataURL = vi.fn().mockReturnValue('data:image/png;base64,mock-image-data');
      mockChart.canvas.toDataURL = mockToDataURL;

      const imageData = await wrapper.vm.exportAsImage('png');

      expect(mockToDataURL).toHaveBeenCalledWith('image/png', 1.0);
      expect(imageData).toBe('data:image/png;base64,mock-image-data');
    });

    test('应该导出数据为CSV', async () => {
      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset
        }
      });

      await nextTick();

      const csvData = await wrapper.vm.exportAsCSV();

      expect(csvData).toContain('timestamp,value');
      expect(csvData).toContain(mockDataset.value.toString());
    });

    test('应该导出图表配置', async () => {
      const chartConfig = {
        chartType: 'line',
        showGrid: true,
        maxDataPoints: 100
      };

      wrapper = mount(PlotWidget, {
        props: {
          dataset: mockDataset,
          config: chartConfig
        }
      });

      await nextTick();

      const exportedConfig = await wrapper.vm.exportConfiguration();

      expect(exportedConfig).toMatchObject(chartConfig);
      expect(exportedConfig.dataset).toEqual(mockDataset);
    });
  });
});
```

### 3.3 仪表盘组件测试

```typescript
// tests/visualization/gauge-widget.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { mount, VueWrapper } from '@vue/test-utils';
import { nextTick } from 'vitest';
import GaugeWidget from '@/components/visualization/GaugeWidget.vue';

describe('GaugeWidget仪表盘组件测试', () => {
  let wrapper: VueWrapper<any>;
  let mockDataset: any;

  beforeEach(() => {
    mockDataset = {
      id: 'speed',
      title: 'Speed',
      value: 75,
      timestamp: Date.now(),
      units: 'km/h',
      min: 0,
      max: 200,
      gauge: true
    };
  });

  afterEach(() => {
    wrapper?.unmount();
    vi.clearAllMocks();
  });

  describe('仪表盘渲染', () => {
    test('应该正确渲染SVG仪表盘', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            gaugeType: 'circular',
            showNeedle: true,
            showValue: true
          }
        }
      });

      await nextTick();

      const svg = wrapper.find('svg');
      expect(svg.exists()).toBe(true);

      const needle = wrapper.find('.gauge-needle');
      expect(needle.exists()).toBe(true);

      const valueText = wrapper.find('.gauge-value');
      expect(valueText.text()).toContain('75');
    });

    test('应该支持不同的仪表盘类型', async () => {
      const gaugeTypes = ['circular', 'semicircular', 'linear'];

      for (const gaugeType of gaugeTypes) {
        const testWrapper = mount(GaugeWidget, {
          props: {
            dataset: mockDataset,
            config: { gaugeType }
          }
        });

        await nextTick();

        expect(testWrapper.find(`.gauge-${gaugeType}`).exists()).toBe(true);

        testWrapper.unmount();
      }
    });

    test('应该正确计算指针角度', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            gaugeType: 'circular',
            startAngle: -90,
            endAngle: 90
          }
        }
      });

      await nextTick();

      const needleAngle = wrapper.vm.calculateNeedleAngle(75, 0, 200);
      expect(needleAngle).toBeCloseTo(-22.5, 1); // 75/200 * 180 - 90
    });

    test('应该显示刻度标记', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            showScale: true,
            majorTicks: 10,
            minorTicks: 5
          }
        }
      });

      await nextTick();

      const majorTicks = wrapper.findAll('.gauge-tick-major');
      const minorTicks = wrapper.findAll('.gauge-tick-minor');

      expect(majorTicks.length).toBe(10);
      expect(minorTicks.length).toBeGreaterThan(10);
    });
  });

  describe('数值显示和格式化', () => {
    test('应该正确格式化数值', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: { ...mockDataset, value: 123.456 },
          config: {
            precision: 2,
            showUnits: true
          }
        }
      });

      await nextTick();

      const valueText = wrapper.find('.gauge-value');
      expect(valueText.text()).toBe('123.46 km/h');
    });

    test('应该支持自定义数值格式', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            valueFormatter: (value: number) => `${value.toFixed(0)}%`
          }
        }
      });

      await nextTick();

      const valueText = wrapper.find('.gauge-value');
      expect(valueText.text()).toBe('75%');
    });

    test('应该处理边界值', async () => {
      // 测试最小值
      await wrapper.setProps({
        dataset: { ...mockDataset, value: -10 }
      });
      await nextTick();

      expect(wrapper.vm.clampedValue).toBe(0);

      // 测试最大值
      await wrapper.setProps({
        dataset: { ...mockDataset, value: 250 }
      });
      await nextTick();

      expect(wrapper.vm.clampedValue).toBe(200);
    });
  });

  describe('颜色和主题', () => {
    test('应该根据数值应用颜色区间', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            colorZones: [
              { min: 0, max: 50, color: '#00ff00' },    // 绿色 - 正常
              { min: 50, max: 100, color: '#ffff00' },  // 黄色 - 警告
              { min: 100, max: 200, color: '#ff0000' }  // 红色 - 危险
            ]
          }
        }
      });

      await nextTick();

      const currentColor = wrapper.vm.getCurrentColor(75);
      expect(currentColor).toBe('#ffff00'); // 75在50-100区间，应该是黄色
    });

    test('应该支持渐变色', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            useGradient: true,
            gradientColors: ['#00ff00', '#ffff00', '#ff0000']
          }
        }
      });

      await nextTick();

      const gradientDef = wrapper.find('defs linearGradient');
      expect(gradientDef.exists()).toBe(true);
    });

    test('应该响应主题变化', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            theme: 'dark'
          }
        }
      });

      await nextTick();

      expect(wrapper.classes()).toContain('gauge-dark-theme');

      // 切换到浅色主题
      await wrapper.setProps({
        config: { theme: 'light' }
      });

      expect(wrapper.classes()).toContain('gauge-light-theme');
    });
  });

  describe('动画效果', () => {
    test('应该平滑过渡数值变化', async () => {
      vi.useFakeTimers();

      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            enableAnimation: true,
            animationDuration: 500
          }
        }
      });

      await nextTick();

      const initialValue = wrapper.vm.displayValue;
      expect(initialValue).toBe(75);

      // 更新数值
      await wrapper.setProps({
        dataset: { ...mockDataset, value: 150 }
      });

      // 动画进行中
      vi.advanceTimersByTime(250);
      const midValue = wrapper.vm.displayValue;
      expect(midValue).toBeGreaterThan(75);
      expect(midValue).toBeLessThan(150);

      // 动画完成
      vi.advanceTimersByTime(300);
      const finalValue = wrapper.vm.displayValue;
      expect(finalValue).toBe(150);

      vi.useRealTimers();
    });

    test('应该支持弹性动画效果', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            enableAnimation: true,
            animationType: 'elastic',
            animationDuration: 1000
          }
        }
      });

      await nextTick();

      const animationSpy = vi.spyOn(wrapper.vm, 'animateValue');

      await wrapper.setProps({
        dataset: { ...mockDataset, value: 100 }
      });

      expect(animationSpy).toHaveBeenCalledWith(75, 100, 'elastic', 1000);
    });
  });

  describe('交互功能', () => {
    test('应该处理点击事件', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            clickable: true
          }
        }
      });

      await nextTick();

      await wrapper.find('.gauge-container').trigger('click');

      expect(wrapper.emitted('click')).toBeTruthy();
      expect(wrapper.emitted('click')[0]).toEqual([
        expect.objectContaining({
          value: 75,
          dataset: mockDataset
        })
      ]);
    });

    test('应该显示悬停信息', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            showTooltip: true,
            tooltipTemplate: 'Current: {value} {units}'
          }
        }
      });

      await nextTick();

      await wrapper.find('.gauge-container').trigger('mouseenter');

      const tooltip = wrapper.find('.gauge-tooltip');
      expect(tooltip.exists()).toBe(true);
      expect(tooltip.text()).toBe('Current: 75 km/h');
    });

    test('应该支持键盘导航', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            focusable: true
          }
        }
      });

      await nextTick();

      const container = wrapper.find('.gauge-container');
      await container.trigger('focus');

      expect(container.attributes('tabindex')).toBe('0');
      expect(wrapper.emitted('focus')).toBeTruthy();
    });
  });

  describe('性能优化', () => {
    test('应该优化SVG渲染', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            optimizeRendering: true
          }
        }
      });

      await nextTick();

      // 验证关键元素是否使用了优化属性
      const svg = wrapper.find('svg');
      expect(svg.attributes('shape-rendering')).toBe('geometricPrecision');
    });

    test('应该缓存计算结果', async () => {
      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset
        }
      });

      await nextTick();

      const calculateSpy = vi.spyOn(wrapper.vm, 'calculatePath');

      // 多次访问相同计算
      const path1 = wrapper.vm.arcPath;
      const path2 = wrapper.vm.arcPath;

      expect(path1).toBe(path2);
      expect(calculateSpy).toHaveBeenCalledTimes(1);
    });

    test('应该在高频更新时节流', async () => {
      vi.useFakeTimers();

      wrapper = mount(GaugeWidget, {
        props: {
          dataset: mockDataset,
          config: {
            throttleUpdates: true,
            updateInterval: 50 // 20Hz
          }
        }
      });

      await nextTick();

      const updateSpy = vi.spyOn(wrapper.vm, 'updateDisplay');

      // 快速连续更新
      for (let i = 0; i < 10; i++) {
        await wrapper.setProps({
          dataset: { ...mockDataset, value: 70 + i }
        });
        vi.advanceTimersByTime(10);
      }

      expect(updateSpy).toHaveBeenCalledTimes(2); // 应该被节流

      vi.useRealTimers();
    });
  });
});
```

### 3.4 3D可视化组件测试

```typescript
// tests/visualization/plot3d-widget.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { mount, VueWrapper } from '@vue/test-utils';
import { nextTick } from 'vue';
import Plot3DWidget from '@/components/visualization/Plot3DWidget.vue';
import * as THREE from 'three';

// Mock Three.js
vi.mock('three', () => ({
  Scene: vi.fn().mockImplementation(() => ({
    add: vi.fn(),
    remove: vi.fn(),
    children: []
  })),
  PerspectiveCamera: vi.fn().mockImplementation(() => ({
    position: { set: vi.fn() },
    lookAt: vi.fn()
  })),
  WebGLRenderer: vi.fn().mockImplementation(() => ({
    setSize: vi.fn(),
    render: vi.fn(),
    dispose: vi.fn(),
    domElement: document.createElement('canvas')
  })),
  BufferGeometry: vi.fn().mockImplementation(() => ({
    setAttribute: vi.fn(),
    dispose: vi.fn()
  })),
  Float32BufferAttribute: vi.fn(),
  Points: vi.fn().mockImplementation(() => ({
    position: { set: vi.fn() }
  })),
  PointsMaterial: vi.fn(),
  OrbitControls: vi.fn().mockImplementation(() => ({
    enableDamping: true,
    update: vi.fn()
  }))
}));

describe('Plot3DWidget 3D可视化组件测试', () => {
  let wrapper: VueWrapper<any>;
  let mockDataset: any;
  let mockScene: any;
  let mockRenderer: any;
  let mockCamera: any;

  beforeEach(() => {
    mockScene = {
      add: vi.fn(),
      remove: vi.fn(),
      children: []
    };

    mockRenderer = {
      setSize: vi.fn(),
      render: vi.fn(),
      dispose: vi.fn(),
      domElement: document.createElement('canvas')
    };

    mockCamera = {
      position: { set: vi.fn() },
      lookAt: vi.fn()
    };

    vi.mocked(THREE.Scene).mockReturnValue(mockScene);
    vi.mocked(THREE.WebGLRenderer).mockReturnValue(mockRenderer);
    vi.mocked(THREE.PerspectiveCamera).mockReturnValue(mockCamera);

    mockDataset = {
      id: 'accelerometer',
      title: '3D Accelerometer',
      value: { x: 1.2, y: -0.8, z: 9.8 },
      timestamp: Date.now(),
      units: 'm/s²',
      plot3D: true,
      history: Array.from({ length: 100 }, (_, i) => ({
        value: {
          x: Math.sin(i * 0.1),
          y: Math.cos(i * 0.1),
          z: Math.sin(i * 0.05) * 2
        },
        timestamp: Date.now() - (100 - i) * 100
      }))
    };
  });

  afterEach(() => {
    wrapper?.unmount();
    vi.clearAllMocks();
  });

  describe('3D场景初始化', () => {
    test('应该正确初始化Three.js场景', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            cameraPosition: { x: 10, y: 10, z: 10 },
            backgroundColor: 0x000000
          }
        }
      });

      await nextTick();

      expect(THREE.Scene).toHaveBeenCalled();
      expect(THREE.PerspectiveCamera).toHaveBeenCalled();
      expect(THREE.WebGLRenderer).toHaveBeenCalled();
      expect(mockCamera.position.set).toHaveBeenCalledWith(10, 10, 10);
    });

    test('应该创建坐标轴', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            showAxes: true,
            axisLength: 10
          }
        }
      });

      await nextTick();

      expect(mockScene.add).toHaveBeenCalledTimes(4); // 场景 + 3个坐标轴
    });

    test('应该设置照明系统', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            lighting: {
              ambient: { intensity: 0.4 },
              directional: { intensity: 0.8, position: { x: 1, y: 1, z: 1 } }
            }
          }
        }
      });

      await nextTick();

      expect(mockScene.add).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'AmbientLight'
        })
      );
    });
  });

  describe('3D数据渲染', () => {
    test('应该渲染3D数据点', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            pointSize: 2,
            pointColor: 0xff0000
          }
        }
      });

      await nextTick();

      expect(THREE.BufferGeometry).toHaveBeenCalled();
      expect(THREE.Points).toHaveBeenCalled();
      expect(THREE.PointsMaterial).toHaveBeenCalledWith(
        expect.objectContaining({
          size: 2,
          color: 0xff0000
        })
      );
    });

    test('应该创建3D轨迹线', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            showTrail: true,
            trailLength: 50,
            trailWidth: 1
          }
        }
      });

      await nextTick();

      const trailGeometry = wrapper.vm.createTrailGeometry();
      expect(trailGeometry).toBeDefined();
      expect(mockScene.add).toHaveBeenCalledWith(
        expect.objectContaining({
          type: 'Line'
        })
      );
    });

    test('应该支持多种渲染模式', async () => {
      const renderModes = ['points', 'lines', 'surface', 'volume'];

      for (const mode of renderModes) {
        const testWrapper = mount(Plot3DWidget, {
          props: {
            dataset: mockDataset,
            config: { renderMode: mode }
          }
        });

        await nextTick();

        expect(testWrapper.vm.currentRenderMode).toBe(mode);
        testWrapper.unmount();
      }
    });

    test('应该处理大量数据点', async () => {
      const largeDataset = {
        ...mockDataset,
        history: Array.from({ length: 10000 }, (_, i) => ({
          value: {
            x: Math.random() * 20 - 10,
            y: Math.random() * 20 - 10,
            z: Math.random() * 20 - 10
          },
          timestamp: Date.now() - i * 10
        }))
      };

      const startTime = performance.now();

      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: largeDataset,
          config: {
            enableLOD: true, // Level of Detail
            maxRenderPoints: 5000
          }
        }
      });

      await nextTick();

      const renderTime = performance.now() - startTime;
      expect(renderTime).toBeLessThan(1000); // 渲染时间应小于1秒

      // 验证LOD优化
      const renderedPoints = wrapper.vm.getRenderedPointsCount();
      expect(renderedPoints).toBeLessThanOrEqual(5000);
    });
  });

  describe('3D交互控制', () => {
    test('应该支持相机控制', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            enableOrbitControls: true,
            enableZoom: true,
            enableRotate: true
          }
        }
      });

      await nextTick();

      // 验证OrbitControls初始化
      expect(wrapper.vm.controls).toBeDefined();
      expect(wrapper.vm.controls.enableZoom).toBe(true);
      expect(wrapper.vm.controls.enableRotate).toBe(true);
    });

    test('应该处理鼠标交互', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            enablePicking: true
          }
        }
      });

      await nextTick();

      const canvas = wrapper.find('canvas');
      await canvas.trigger('click', {
        clientX: 100,
        clientY: 100
      });

      expect(wrapper.emitted('pointSelected')).toBeTruthy();
    });

    test('应该支持键盘快捷键', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            enableKeyboardControls: true
          }
        }
      });

      await nextTick();

      // 模拟按键事件
      await wrapper.trigger('keydown', { key: 'r' }); // 重置视角

      expect(wrapper.vm.controls.reset).toHaveBeenCalled();
    });
  });

  describe('性能优化', () => {
    test('应该使用WebGL优化', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            useWebGL2: true,
            enableInstancing: true
          }
        }
      });

      await nextTick();

      expect(THREE.WebGLRenderer).toHaveBeenCalledWith(
        expect.objectContaining({
          antialias: true,
          alpha: true
        })
      );
    });

    test('应该实现视锥剔除', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            enableFrustumCulling: true
          }
        }
      });

      await nextTick();

      const culledObjects = wrapper.vm.performFrustumCulling();
      expect(culledObjects.length).toBeLessThanOrEqual(mockDataset.history.length);
    });

    test('应该优化渲染循环', async () => {
      vi.useFakeTimers();

      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            targetFrameRate: 60,
            adaptiveQuality: true
          }
        }
      });

      await nextTick();

      const renderSpy = vi.spyOn(mockRenderer, 'render');

      // 模拟渲染循环
      for (let i = 0; i < 60; i++) {
        vi.advanceTimersByTime(16.67); // 60fps
      }

      expect(renderSpy).toHaveBeenCalledTimes(60);

      vi.useRealTimers();
    });
  });

  describe('数据更新和动画', () => {
    test('应该平滑更新3D数据', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            enableDataAnimation: true,
            animationSpeed: 0.1
          }
        }
      });

      await nextTick();

      const newDataset = {
        ...mockDataset,
        value: { x: 2.0, y: -1.5, z: 8.5 }
      };

      await wrapper.setProps({ dataset: newDataset });

      expect(wrapper.vm.animateDataTransition).toHaveBeenCalled();
    });

    test('应该支持实时数据流', async () => {
      vi.useFakeTimers();

      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset,
          config: {
            realTimeMode: true,
            updateFrequency: 20 // 20Hz
          }
        }
      });

      await nextTick();

      const updateSpy = vi.spyOn(wrapper.vm, 'updateRealTimeData');

      // 模拟实时数据更新
      for (let i = 0; i < 10; i++) {
        vi.advanceTimersByTime(50);
        const newValue = {
          x: Math.sin(i * 0.1),
          y: Math.cos(i * 0.1),
          z: i * 0.1
        };
        await wrapper.setProps({
          dataset: { ...mockDataset, value: newValue }
        });
      }

      expect(updateSpy).toHaveBeenCalledTimes(10);

      vi.useRealTimers();
    });
  });

  describe('资源管理', () => {
    test('应该正确清理WebGL资源', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset
        }
      });

      await nextTick();

      wrapper.unmount();

      expect(mockRenderer.dispose).toHaveBeenCalled();
      expect(wrapper.vm.scene.children.length).toBe(0);
    });

    test('应该处理WebGL上下文丢失', async () => {
      wrapper = mount(Plot3DWidget, {
        props: {
          dataset: mockDataset
        }
      });

      await nextTick();

      const handleContextLoss = vi.spyOn(wrapper.vm, 'handleWebGLContextLoss');

      // 模拟WebGL上下文丢失
      const canvas = wrapper.find('canvas');
      await canvas.trigger('webglcontextlost');

      expect(handleContextLoss).toHaveBeenCalled();
    });
  });
});
```

## 4. 性能基准测试

```typescript
// tests/visualization/performance.bench.ts
import { bench, describe } from 'vitest';
import { mount } from '@vue/test-utils';
import PlotWidget from '@/components/visualization/PlotWidget.vue';
import GaugeWidget from '@/components/visualization/GaugeWidget.vue';
import Plot3DWidget from '@/components/visualization/Plot3DWidget.vue';

describe('可视化组件性能基准测试', () => {
  const mockDataset = {
    id: 'test',
    title: 'Test',
    value: 50,
    timestamp: Date.now(),
    history: Array.from({ length: 1000 }, (_, i) => ({
      value: Math.sin(i * 0.01),
      timestamp: Date.now() - i * 100
    }))
  };

  bench('PlotWidget渲染性能', () => {
    const wrapper = mount(PlotWidget, {
      props: { dataset: mockDataset }
    });
    wrapper.unmount();
  });

  bench('GaugeWidget渲染性能', () => {
    const wrapper = mount(GaugeWidget, {
      props: { dataset: mockDataset }
    });
    wrapper.unmount();
  });

  bench('实时数据更新性能', async () => {
    const wrapper = mount(PlotWidget, {
      props: { dataset: mockDataset }
    });

    for (let i = 0; i < 100; i++) {
      await wrapper.setProps({
        dataset: {
          ...mockDataset,
          value: Math.random() * 100,
          timestamp: Date.now()
        }
      });
    }

    wrapper.unmount();
  });

  bench('大数据集渲染性能', () => {
    const largeDataset = {
      ...mockDataset,
      history: Array.from({ length: 10000 }, (_, i) => ({
        value: Math.random(),
        timestamp: Date.now() - i * 10
      }))
    };

    const wrapper = mount(PlotWidget, {
      props: { dataset: largeDataset }
    });
    wrapper.unmount();
  });
});
```

这个详细的可视化组件单元测试方案涵盖了基础组件框架、实时图表、仪表盘、3D可视化等各个核心组件，确保用户界面的功能完整性和高性能表现。