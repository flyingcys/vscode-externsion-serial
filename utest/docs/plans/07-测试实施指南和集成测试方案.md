# æµ‹è¯•å®æ–½æŒ‡å—å’Œé›†æˆæµ‹è¯•æ–¹æ¡ˆ

## 1. å®æ–½æ¦‚è¿°

æœ¬æ–‡æ¡£æ˜¯Serial-Studio VSCodeæ’ä»¶å•å…ƒæµ‹è¯•çš„å®Œæ•´å®æ–½æŒ‡å—ï¼Œæ•´åˆäº†7å¤§æ ¸å¿ƒæ¨¡å—çš„æµ‹è¯•æ–¹æ¡ˆï¼Œæä¾›è¯¦ç»†çš„é›†æˆæµ‹è¯•ç­–ç•¥ã€å®æ–½æ—¶é—´çº¿å’Œè´¨é‡ä¿è¯æµç¨‹ã€‚åŸºäºé¡¹ç›®çš„é«˜åº¦æ¨¡å—åŒ–æ¶æ„å’Œ20Hzå®æ—¶æ€§èƒ½è¦æ±‚ï¼Œé‡‡ç”¨åˆ†é˜¶æ®µã€æŒç»­é›†æˆçš„æµ‹è¯•å®æ–½ç­–ç•¥ã€‚

### 1.1 æµ‹è¯•å®æ–½ç›®æ ‡

- **å…¨é¢è¦†ç›–**ï¼šå®ç°â‰¥95%çš„æ€»ä½“ä»£ç è¦†ç›–ç‡
- **è´¨é‡ä¿è¯**ï¼šç¡®ä¿0å´©æºƒã€0å†…å­˜æ³„æ¼çš„ç¨³å®šè¿è¡Œ
- **æ€§èƒ½è¾¾æ ‡**ï¼šéªŒè¯20Hzå®æ—¶æ›´æ–°ã€50mså»¶è¿Ÿã€60fpsæ¸²æŸ“ç­‰å…³é”®æŒ‡æ ‡
- **æŒç»­é›†æˆ**ï¼šå»ºç«‹è‡ªåŠ¨åŒ–æµ‹è¯•æµæ°´çº¿å’Œè´¨é‡é—¨ç¦
- **å›¢é˜Ÿåä½œ**ï¼šæä¾›æ¸…æ™°çš„æµ‹è¯•å®æ–½æŒ‡å¯¼å’Œæœ€ä½³å®è·µ

### 1.2 æµ‹è¯•æ¶æ„æ€»è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æµ‹è¯•æ¶æ„æ€»è§ˆ                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   å•å…ƒæµ‹è¯•å±‚     â”‚  â”‚   é›†æˆæµ‹è¯•å±‚     â”‚  â”‚   E2Eæµ‹è¯•å±‚   â”‚ â”‚
â”‚  â”‚ - 7å¤§æ¨¡å—æµ‹è¯•    â”‚  â”‚ - æ¨¡å—é—´é›†æˆ     â”‚  â”‚ - ç”¨æˆ·æµç¨‹    â”‚ â”‚
â”‚  â”‚ - Mockå’ŒStub    â”‚  â”‚ - APIé›†æˆ       â”‚  â”‚ - ç«¯åˆ°ç«¯éªŒè¯  â”‚ â”‚
â”‚  â”‚ - è¦†ç›–ç‡â‰¥95%    â”‚  â”‚ - æ€§èƒ½é›†æˆ       â”‚  â”‚ - UIè‡ªåŠ¨åŒ–    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  æµ‹è¯•åŸºç¡€è®¾æ–½    â”‚  â”‚  è´¨é‡é—¨ç¦ç³»ç»Ÿ    â”‚  â”‚  ç›‘æ§æŠ¥å‘Š     â”‚ â”‚
â”‚  â”‚ - CI/CDæµæ°´çº¿   â”‚  â”‚ - è‡ªåŠ¨åŒ–æ£€æŸ¥     â”‚  â”‚ - è¦†ç›–ç‡æŠ¥å‘Š  â”‚ â”‚
â”‚  â”‚ - æµ‹è¯•ç¯å¢ƒ       â”‚  â”‚ - æ€§èƒ½åŸºå‡†       â”‚  â”‚ - æ€§èƒ½ç›‘æ§    â”‚ â”‚
â”‚  â”‚ - æ•°æ®å’ŒMock    â”‚  â”‚ - ä»£ç è´¨é‡       â”‚  â”‚ - é”™è¯¯è¿½è¸ª    â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 2. æ¨¡å—æµ‹è¯•æ€»ç»“

### 2.1 7å¤§æ ¸å¿ƒæ¨¡å—æµ‹è¯•æ¦‚è§ˆ

| æ¨¡å—åç§° | æµ‹è¯•æ–‡ä»¶æ•° | æµ‹è¯•ç”¨ä¾‹æ•° | è¦†ç›–ç‡ç›®æ ‡ | ä¼˜å…ˆçº§ | çŠ¶æ€ |
|---------|-----------|-----------|-----------|--------|------|
| é€šè®¯æ¨¡å— | 15ä¸ª | 186ä¸ª | â‰¥98% | P0 | ğŸ“‹ å·²è§„åˆ’ |
| æ•°æ®è§£ææ¨¡å— | 12ä¸ª | 148ä¸ª | â‰¥97% | P0 | ğŸ“‹ å·²è§„åˆ’ |
| å¯è§†åŒ–ç»„ä»¶ | 18ä¸ª | 224ä¸ª | â‰¥95% | P0 | ğŸ“‹ å·²è§„åˆ’ |
| é¡¹ç›®ç®¡ç† | 8ä¸ª | 95ä¸ª | â‰¥93% | P1 | ğŸ“‹ å·²è§„åˆ’ |
| æ‰©å±•æ¨¡å— | 14ä¸ª | 167ä¸ª | â‰¥90% | P1 | ğŸ“‹ å·²è§„åˆ’ |
| æ€§èƒ½ä¼˜åŒ– | 10ä¸ª | 123ä¸ª | â‰¥95% | P1 | ğŸ“‹ å·²è§„åˆ’ |
| æ•°æ®å¯¼å‡º | 9ä¸ª | 112ä¸ª | â‰¥92% | P2 | ğŸ“‹ å·²è§„åˆ’ |
| **æ€»è®¡** | **86ä¸ª** | **1055ä¸ª** | **â‰¥95%** | - | ğŸ“‹ å·²è§„åˆ’ |

### 2.2 æµ‹è¯•å¤æ‚åº¦åˆ†æ

```typescript
// æµ‹è¯•å¤æ‚åº¦è¯„ä¼°
interface TestComplexityAnalysis {
  highComplexity: {
    modules: ['é€šè®¯æ¨¡å—', 'æ•°æ®è§£ææ¨¡å—', 'å¯è§†åŒ–ç»„ä»¶'],
    reasons: [
      'ç¡¬ä»¶æŠ½è±¡å±‚æµ‹è¯•éœ€è¦å¤§é‡Mock',
      'JavaScriptæ‰§è¡Œç¯å¢ƒå®‰å…¨æ€§æµ‹è¯•',
      '20Hzå®æ—¶æ¸²æŸ“æ€§èƒ½æµ‹è¯•',
      'å¤šåè®®å¹¶å‘è¿æ¥æµ‹è¯•'
    ],
    estimatedEffort: '60%' // å æ€»å·¥ä½œé‡çš„60%
  },
  mediumComplexity: {
    modules: ['æ‰©å±•æ¨¡å—', 'æ€§èƒ½ä¼˜åŒ–', 'é¡¹ç›®ç®¡ç†'],
    reasons: [
      'æ’ä»¶ç³»ç»ŸåŠ¨æ€åŠ è½½æµ‹è¯•',
      'æ€§èƒ½ç›‘æ§å’Œè°ƒä¼˜æµ‹è¯•',
      'é…ç½®ç®¡ç†å’ŒæŒä¹…åŒ–æµ‹è¯•'
    ],
    estimatedEffort: '30%'
  },
  lowComplexity: {
    modules: ['æ•°æ®å¯¼å‡º'],
    reasons: [
      'ç›¸å¯¹ç‹¬ç«‹çš„åŠŸèƒ½æ¨¡å—',
      'æ ‡å‡†æ ¼å¼è½¬æ¢æµ‹è¯•',
      'æ–‡ä»¶I/Oæ“ä½œæµ‹è¯•'
    ],
    estimatedEffort: '10%'
  }
}
```

## 3. é›†æˆæµ‹è¯•ç­–ç•¥

### 3.1 æ¨¡å—é—´é›†æˆæµ‹è¯•

```typescript
// tests/integration/module-integration.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { CommunicationManager } from '@/communication/communication-manager';
import { DataParsingPipeline } from '@/parsing/data-parsing-pipeline';
import { VisualizationEngine } from '@/visualization/visualization-engine';
import { ExportManager } from '@/export/export-manager';

describe('æ¨¡å—é—´é›†æˆæµ‹è¯•', () => {
  let communicationManager: CommunicationManager;
  let parsingPipeline: DataParsingPipeline;
  let visualizationEngine: VisualizationEngine;
  let exportManager: ExportManager;

  beforeAll(async () => {
    // åˆå§‹åŒ–æ‰€æœ‰æ¨¡å—
    communicationManager = new CommunicationManager();
    parsingPipeline = new DataParsingPipeline();
    visualizationEngine = new VisualizationEngine();
    exportManager = new ExportManager();

    await Promise.all([
      communicationManager.initialize(),
      parsingPipeline.initialize(),
      visualizationEngine.initialize(),
      exportManager.initialize()
    ]);
  });

  afterAll(async () => {
    // æ¸…ç†æ‰€æœ‰æ¨¡å—
    await Promise.all([
      communicationManager.shutdown(),
      parsingPipeline.shutdown(),
      visualizationEngine.shutdown(),
      exportManager.shutdown()
    ]);
  });

  describe('æ•°æ®æµé›†æˆæµ‹è¯•', () => {
    test('å®Œæ•´æ•°æ®æµï¼šé€šè®¯â†’è§£æâ†’å¯è§†åŒ–', async () => {
      // 1. å»ºç«‹é€šè®¯è¿æ¥
      const connection = await communicationManager.createConnection('mock', {
        mockData: generateMockSerialData()
      });

      // 2. é…ç½®æ•°æ®è§£æ
      await parsingPipeline.configure({
        frameDetection: { mode: 'end-delimiter', endDelimiter: '\n' },
        parseScript: 'function parse(frame) { return frame.split(",").map(Number); }'
      });

      // 3. åˆ›å»ºå¯è§†åŒ–ç»„ä»¶
      const plotWidget = await visualizationEngine.createWidget('plot', {
        title: 'Integration Test Plot',
        maxDataPoints: 100
      });

      // 4. è¿æ¥æ•°æ®æµ
      const dataFlow = createDataFlow(connection, parsingPipeline, plotWidget);

      // 5. å¯åŠ¨æ•°æ®æµ
      await dataFlow.start();

      // 6. éªŒè¯æ•°æ®ä¼ è¾“
      await new Promise(resolve => setTimeout(resolve, 1000));

      expect(plotWidget.getDataPointCount()).toBeGreaterThan(0);
      expect(plotWidget.getLastUpdateTime()).toBeGreaterThan(Date.now() - 2000);

      await dataFlow.stop();
    });

    test('é«˜é¢‘æ•°æ®æµæ€§èƒ½é›†æˆæµ‹è¯•', async () => {
      const highFreqConnection = await communicationManager.createConnection('mock', {
        mockData: generateHighFrequencyData(20), // 20Hz
        realTime: true
      });

      const performanceMonitor = visualizationEngine.createPerformanceMonitor();
      
      const plotWidget = await visualizationEngine.createWidget('plot', {
        title: 'High Frequency Test',
        updateRate: 20, // 20Hz
        enablePerformanceOptimization: true
      });

      const dataFlow = createDataFlow(highFreqConnection, parsingPipeline, plotWidget);
      
      await dataFlow.start();
      await new Promise(resolve => setTimeout(resolve, 5000)); // 5ç§’æµ‹è¯•

      const metrics = performanceMonitor.getMetrics();
      
      expect(metrics.averageUpdateRate).toBeGreaterThanOrEqual(18); // â‰¥18Hz
      expect(metrics.averageLatency).toBeLessThan(50); // <50ms
      expect(metrics.droppedFrames).toBeLessThan(5); // <5ä¸ªä¸¢å¸§

      await dataFlow.stop();
    });

    test('å¤šè¿æ¥å¹¶å‘é›†æˆæµ‹è¯•', async () => {
      const connections = await Promise.all([
        communicationManager.createConnection('mock', { port: 'COM1' }),
        communicationManager.createConnection('mock', { port: 'COM2' }),
        communicationManager.createConnection('mock', { port: 'COM3' })
      ]);

      const widgets = await Promise.all([
        visualizationEngine.createWidget('plot', { title: 'Connection 1' }),
        visualizationEngine.createWidget('gauge', { title: 'Connection 2' }),
        visualizationEngine.createWidget('bar', { title: 'Connection 3' })
      ]);

      const dataFlows = connections.map((conn, i) => 
        createDataFlow(conn, parsingPipeline, widgets[i])
      );

      await Promise.all(dataFlows.map(flow => flow.start()));
      await new Promise(resolve => setTimeout(resolve, 2000));

      // éªŒè¯æ‰€æœ‰è¿æ¥éƒ½åœ¨æ­£å¸¸å·¥ä½œ
      widgets.forEach(widget => {
        expect(widget.getDataPointCount()).toBeGreaterThan(0);
      });

      await Promise.all(dataFlows.map(flow => flow.stop()));
    });
  });

  describe('é”™è¯¯å¤„ç†é›†æˆæµ‹è¯•', () => {
    test('é€šè®¯ä¸­æ–­è‡ªåŠ¨æ¢å¤', async () => {
      const connection = await communicationManager.createConnection('mock', {
        simulateInterruption: true,
        interruptionInterval: 2000 // 2ç§’åä¸­æ–­
      });

      const errorEvents: any[] = [];
      const recoveryEvents: any[] = [];

      connection.on('error', (error) => errorEvents.push(error));
      connection.on('reconnected', (event) => recoveryEvents.push(event));

      const plotWidget = await visualizationEngine.createWidget('plot');
      const dataFlow = createDataFlow(connection, parsingPipeline, plotWidget);

      await dataFlow.start();
      await new Promise(resolve => setTimeout(resolve, 5000)); // ç­‰å¾…ä¸­æ–­å’Œæ¢å¤

      expect(errorEvents.length).toBeGreaterThan(0);
      expect(recoveryEvents.length).toBeGreaterThan(0);
      expect(connection.isConnected()).toBe(true); // åº”è¯¥å·²æ¢å¤

      await dataFlow.stop();
    });

    test('è§£æé”™è¯¯å¤„ç†ä¸å½±å“å…¶ä»–æ¨¡å—', async () => {
      const connection = await communicationManager.createConnection('mock', {
        mockData: generateCorruptedData() // åŒ…å«æŸåæ•°æ®
      });

      await parsingPipeline.configure({
        parseScript: 'function parse(frame) { throw new Error("Parse error"); }',
        errorHandling: { skipInvalidFrames: true }
      });

      const plotWidget = await visualizationEngine.createWidget('plot');
      const dataFlow = createDataFlow(connection, parsingPipeline, plotWidget);

      const parseErrors: any[] = [];
      parsingPipeline.on('parseError', (error) => parseErrors.push(error));

      await dataFlow.start();
      await new Promise(resolve => setTimeout(resolve, 2000));

      expect(parseErrors.length).toBeGreaterThan(0); // åº”è¯¥æœ‰è§£æé”™è¯¯
      expect(connection.isConnected()).toBe(true); // é€šè®¯ä»ç„¶æ­£å¸¸
      expect(plotWidget.isActive()).toBe(true); // å¯è§†åŒ–ä»ç„¶æ­£å¸¸

      await dataFlow.stop();
    });

    test('å†…å­˜æ³„æ¼æ£€æµ‹', async () => {
      const initialMemory = process.memoryUsage().heapUsed;

      for (let i = 0; i < 10; i++) {
        const connection = await communicationManager.createConnection('mock');
        const plotWidget = await visualizationEngine.createWidget('plot');
        const dataFlow = createDataFlow(connection, parsingPipeline, plotWidget);

        await dataFlow.start();
        await new Promise(resolve => setTimeout(resolve, 100));
        await dataFlow.stop();

        // æ¸…ç†èµ„æº
        await plotWidget.destroy();
        await connection.disconnect();
      }

      // å¼ºåˆ¶åƒåœ¾å›æ”¶
      if (global.gc) {
        global.gc();
      }

      const finalMemory = process.memoryUsage().heapUsed;
      const memoryIncrease = finalMemory - initialMemory;

      // å†…å­˜å¢é•¿åº”è¯¥æ§åˆ¶åœ¨åˆç†èŒƒå›´å†…
      expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // <50MB
    });
  });

  describe('å¯¼å‡ºé›†æˆæµ‹è¯•', () => {
    test('å®æ—¶æ•°æ®å¯¼å‡ºé›†æˆ', async () => {
      const connection = await communicationManager.createConnection('mock');
      const plotWidget = await visualizationEngine.createWidget('plot');
      const dataFlow = createDataFlow(connection, parsingPipeline, plotWidget);

      await dataFlow.start();
      await new Promise(resolve => setTimeout(resolve, 1000)); // æ”¶é›†æ•°æ®

      // å¯¼å‡ºå½“å‰æ•°æ®
      const exportTask = await exportManager.createExportTask(
        plotWidget.getData(),
        {
          format: 'csv',
          filePath: '/tmp/integration-test-export.csv',
          includeMetadata: true
        }
      );

      const result = await exportManager.executeTask(exportTask);

      expect(result.success).toBe(true);
      expect(result.recordsExported).toBeGreaterThan(0);
      expect(result.fileSize).toBeGreaterThan(0);

      await dataFlow.stop();
    });

    test('å¤šç»„ä»¶æ•°æ®åˆå¹¶å¯¼å‡º', async () => {
      const connections = await Promise.all([
        communicationManager.createConnection('mock', { sensorType: 'temperature' }),
        communicationManager.createConnection('mock', { sensorType: 'humidity' })
      ]);

      const widgets = await Promise.all([
        visualizationEngine.createWidget('plot', { title: 'Temperature' }),
        visualizationEngine.createWidget('gauge', { title: 'Humidity' })
      ]);

      const dataFlows = connections.map((conn, i) => 
        createDataFlow(conn, parsingPipeline, widgets[i])
      );

      await Promise.all(dataFlows.map(flow => flow.start()));
      await new Promise(resolve => setTimeout(resolve, 2000));

      // åˆå¹¶æ‰€æœ‰ç»„ä»¶çš„æ•°æ®
      const combinedData = widgets.flatMap(widget => widget.getData());

      const exportTask = await exportManager.createExportTask(
        combinedData,
        {
          format: 'json',
          filePath: '/tmp/combined-export.json',
          nested: true,
          groupBy: 'sensorType'
        }
      );

      const result = await exportManager.executeTask(exportTask);

      expect(result.success).toBe(true);
      expect(result.recordsExported).toBeGreaterThan(widgets.length);

      await Promise.all(dataFlows.map(flow => flow.stop()));
    });
  });

  // è¾…åŠ©å‡½æ•°
  function createDataFlow(connection: any, pipeline: any, widget: any) {
    return {
      async start() {
        // è¿æ¥æ•°æ®æµç®¡é“
        connection.on('data', async (data: Buffer) => {
          try {
            const parsed = await pipeline.processData(data);
            await widget.updateData(parsed);
          } catch (error) {
            console.error('Data flow error:', error);
          }
        });

        await connection.connect();
      },
      
      async stop() {
        await connection.disconnect();
      }
    };
  }

  function generateMockSerialData() {
    return Array.from({ length: 100 }, (_, i) => 
      `${25 + Math.sin(i * 0.1) * 5},${60 + Math.cos(i * 0.1) * 10}\n`
    ).join('');
  }

  function generateHighFrequencyData(frequency: number) {
    const interval = 1000 / frequency; // ms
    return Array.from({ length: frequency * 5 }, (_, i) => ({
      data: `${Math.random() * 100}\n`,
      timestamp: Date.now() + i * interval
    }));
  }

  function generateCorruptedData() {
    return [
      'valid,data,123\n',
      'invalid data without delimiters',
      'another,valid,line\n',
      '\x00\x01\x02invalid binary\n',
      'final,valid,line\n'
    ].join('');
  }
});
```

### 3.2 APIé›†æˆæµ‹è¯•

```typescript
// tests/integration/api-integration.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { VSCodeAPIIntegration } from '@/integration/vscode-api';
import { ExtensionContext } from 'vscode';

describe('VSCode APIé›†æˆæµ‹è¯•', () => {
  let apiIntegration: VSCodeAPIIntegration;
  let mockContext: ExtensionContext;

  beforeAll(async () => {
    mockContext = createMockExtensionContext();
    apiIntegration = new VSCodeAPIIntegration(mockContext);
    await apiIntegration.initialize();
  });

  afterAll(async () => {
    await apiIntegration.dispose();
  });

  describe('å‘½ä»¤æ³¨å†Œå’Œæ‰§è¡Œ', () => {
    test('åº”è¯¥æ³¨å†Œæ‰€æœ‰æ‰©å±•å‘½ä»¤', () => {
      const registeredCommands = apiIntegration.getRegisteredCommands();
      
      const expectedCommands = [
        'serialstudio.openConnection',
        'serialstudio.closeConnection',
        'serialstudio.exportData',
        'serialstudio.changeTheme',
        'serialstudio.showSettings'
      ];

      expectedCommands.forEach(command => {
        expect(registeredCommands).toContain(command);
      });
    });

    test('åº”è¯¥æ­£ç¡®æ‰§è¡Œå‘½ä»¤', async () => {
      const result = await apiIntegration.executeCommand(
        'serialstudio.openConnection',
        { port: '/dev/ttyUSB0', baudRate: 115200 }
      );

      expect(result.success).toBe(true);
      expect(result.connectionId).toBeDefined();
    });

    test('åº”è¯¥å¤„ç†å‘½ä»¤æ‰§è¡Œé”™è¯¯', async () => {
      const result = await apiIntegration.executeCommand(
        'serialstudio.openConnection',
        { port: '/invalid/port' }
      );

      expect(result.success).toBe(false);
      expect(result.error).toBeDefined();
    });
  });

  describe('é…ç½®ç®¡ç†é›†æˆ', () => {
    test('åº”è¯¥è¯»å–VSCodeé…ç½®', () => {
      const config = apiIntegration.getConfiguration('serialstudio');
      
      expect(config).toHaveProperty('communication');
      expect(config).toHaveProperty('visualization');
      expect(config).toHaveProperty('ui');
    });

    test('åº”è¯¥ç›‘å¬é…ç½®å˜åŒ–', async () => {
      const configChanges: any[] = [];
      
      apiIntegration.onConfigurationChanged((change) => {
        configChanges.push(change);
      });

      // æ¨¡æ‹Ÿé…ç½®å˜åŒ–
      await apiIntegration.updateConfiguration('serialstudio.ui.theme', 'dark');

      expect(configChanges.length).toBeGreaterThan(0);
      expect(configChanges[0]).toHaveProperty('section', 'serialstudio.ui.theme');
    });

    test('åº”è¯¥éªŒè¯é…ç½®å€¼', async () => {
      const validation = await apiIntegration.validateConfiguration({
        'communication.uart.baudRate': 9600,
        'visualization.chart.updateRate': 20
      });

      expect(validation.isValid).toBe(true);
      expect(validation.errors).toHaveLength(0);
    });
  });

  describe('Webviewé›†æˆ', () => {
    test('åº”è¯¥åˆ›å»ºWebviewé¢æ¿', async () => {
      const panel = await apiIntegration.createWebviewPanel({
        viewType: 'serialstudio.dashboard',
        title: 'Serial Studio Dashboard',
        showOptions: { preserveFocus: true }
      });

      expect(panel).toBeDefined();
      expect(panel.webview).toBeDefined();
      expect(panel.title).toBe('Serial Studio Dashboard');
    });

    test('åº”è¯¥å¤„ç†Webviewæ¶ˆæ¯é€šä¿¡', async () => {
      const panel = await apiIntegration.createWebviewPanel({
        viewType: 'serialstudio.test',
        title: 'Test Panel'
      });

      const messages: any[] = [];
      
      panel.webview.onDidReceiveMessage((message) => {
        messages.push(message);
      });

      // ä»Extensionå‘Webviewå‘é€æ¶ˆæ¯
      await panel.webview.postMessage({
        type: 'data-update',
        payload: { value: 42 }
      });

      // æ¨¡æ‹Ÿä»Webviewæ¥æ”¶æ¶ˆæ¯
      panel.webview.mockReceiveMessage({
        type: 'user-action',
        action: 'export-data'
      });

      expect(messages).toHaveLength(1);
      expect(messages[0].action).toBe('export-data');
    });

    test('åº”è¯¥ç®¡ç†Webviewç”Ÿå‘½å‘¨æœŸ', async () => {
      const panel = await apiIntegration.createWebviewPanel({
        viewType: 'serialstudio.lifecycle',
        title: 'Lifecycle Test'
      });

      let disposeCalled = false;
      panel.onDidDispose(() => {
        disposeCalled = true;
      });

      panel.dispose();

      expect(disposeCalled).toBe(true);
    });
  });

  describe('æ–‡ä»¶ç³»ç»Ÿé›†æˆ', () => {
    test('åº”è¯¥è¯»å†™å·¥ä½œåŒºæ–‡ä»¶', async () => {
      const testData = { test: 'data', timestamp: Date.now() };
      
      await apiIntegration.writeWorkspaceFile(
        'test-config.json',
        JSON.stringify(testData, null, 2)
      );

      const readData = await apiIntegration.readWorkspaceFile('test-config.json');
      const parsed = JSON.parse(readData);

      expect(parsed).toEqual(testData);
    });

    test('åº”è¯¥ç›‘å¬æ–‡ä»¶å˜åŒ–', async () => {
      const fileChanges: any[] = [];
      
      const watcher = apiIntegration.watchWorkspaceFiles('**/*.json', (change) => {
        fileChanges.push(change);
      });

      await apiIntegration.writeWorkspaceFile('watched-file.json', '{}');

      expect(fileChanges.length).toBeGreaterThan(0);
      expect(fileChanges[0].type).toBe('created');

      watcher.dispose();
    });

    test('åº”è¯¥å¤„ç†æ–‡ä»¶æ“ä½œé”™è¯¯', async () => {
      await expect(
        apiIntegration.readWorkspaceFile('non-existent-file.json')
      ).rejects.toThrow();
    });
  });

  function createMockExtensionContext(): ExtensionContext {
    return {
      subscriptions: [],
      workspaceState: {
        get: vi.fn(),
        update: vi.fn()
      },
      globalState: {
        get: vi.fn(),
        update: vi.fn()
      },
      extensionPath: '/mock/extension/path',
      storagePath: '/mock/storage/path',
      globalStoragePath: '/mock/global/storage/path',
      logPath: '/mock/log/path',
      extensionUri: { scheme: 'file', path: '/mock/extension/path' },
      storageUri: { scheme: 'file', path: '/mock/storage/path' },
      globalStorageUri: { scheme: 'file', path: '/mock/global/storage/path' },
      logUri: { scheme: 'file', path: '/mock/log/path' },
      secrets: {
        get: vi.fn(),
        store: vi.fn(),
        delete: vi.fn(),
        onDidChange: vi.fn()
      }
    } as any;
  }
});
```

### 3.3 æ€§èƒ½é›†æˆæµ‹è¯•

```typescript
// tests/integration/performance-integration.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { PerformanceTestSuite } from '@/test-utils/performance-test-suite';
import { SystemResourceMonitor } from '@/test-utils/system-resource-monitor';

describe('æ€§èƒ½é›†æˆæµ‹è¯•', () => {
  let performanceTestSuite: PerformanceTestSuite;
  let resourceMonitor: SystemResourceMonitor;

  beforeAll(async () => {
    performanceTestSuite = new PerformanceTestSuite();
    resourceMonitor = new SystemResourceMonitor();
    
    await performanceTestSuite.initialize();
    resourceMonitor.start();
  });

  afterAll(async () => {
    resourceMonitor.stop();
    await performanceTestSuite.cleanup();
  });

  describe('å®æ—¶æ€§èƒ½åŸºå‡†æµ‹è¯•', () => {
    test('20Hzæ•°æ®æ›´æ–°æ€§èƒ½åŸºå‡†', async () => {
      const testConfig = {
        dataFrequency: 20, // 20Hz
        testDuration: 10000, // 10ç§’
        expectedLatency: 50, // <50ms
        expectedFrameRate: 60 // â‰¥60fps
      };

      const result = await performanceTestSuite.runRealtimePerformanceTest(testConfig);

      expect(result.averageUpdateRate).toBeGreaterThanOrEqual(18); // â‰¥18Hzï¼ˆå…è®¸2Hzè¯¯å·®ï¼‰
      expect(result.averageLatency).toBeLessThan(testConfig.expectedLatency);
      expect(result.averageFrameRate).toBeGreaterThanOrEqual(testConfig.expectedFrameRate);
      expect(result.droppedFrames).toBeLessThan(10); // <1%ä¸¢å¸§ç‡
    });

    test('é«˜å¹¶å‘è¿æ¥æ€§èƒ½æµ‹è¯•', async () => {
      const connectionCount = 10;
      const dataRate = 10; // 10Hz per connection
      
      const result = await performanceTestSuite.runConcurrentConnectionTest({
        connectionCount,
        dataRatePerConnection: dataRate,
        testDuration: 5000
      });

      expect(result.successfulConnections).toBe(connectionCount);
      expect(result.totalThroughput).toBeGreaterThanOrEqual(connectionCount * dataRate * 0.9); // 90%æ•ˆç‡
      expect(result.averageConnectionLatency).toBeLessThan(100); // <100msè¿æ¥å»¶è¿Ÿ
    });

    test('å†…å­˜ä½¿ç”¨æ€§èƒ½æµ‹è¯•', async () => {
      const initialMemory = resourceMonitor.getMemoryUsage();

      // è¿è¡Œå†…å­˜å¯†é›†å‹æµ‹è¯•
      await performanceTestSuite.runMemoryStressTest({
        dataSetSize: 100000, // 10ä¸‡æ¡è®°å½•
        operationCount: 1000,
        testDuration: 30000 // 30ç§’
      });

      const finalMemory = resourceMonitor.getMemoryUsage();
      const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;

      expect(memoryIncrease).toBeLessThan(200 * 1024 * 1024); // <200MBå†…å­˜å¢é•¿
      expect(finalMemory.heapUsed / finalMemory.heapTotal).toBeLessThan(0.8); // <80%å †ä½¿ç”¨ç‡
    });

    test('æ¸²æŸ“æ€§èƒ½å‹åŠ›æµ‹è¯•', async () => {
      const renderingConfig = {
        componentCount: 50, // 50ä¸ªå¯è§†åŒ–ç»„ä»¶
        dataPointsPerComponent: 1000,
        updateFrequency: 20, // 20Hz
        testDuration: 15000 // 15ç§’
      };

      const result = await performanceTestSuite.runRenderingStressTest(renderingConfig);

      expect(result.averageRenderTime).toBeLessThan(16); // <16msï¼ˆ60fpsè¦æ±‚ï¼‰
      expect(result.frameDropRate).toBeLessThan(0.05); // <5%ä¸¢å¸§ç‡
      expect(result.cpuUsage).toBeLessThan(0.8); // <80% CPUä½¿ç”¨ç‡
    });
  });

  describe('å¤§æ•°æ®é‡å¤„ç†æ€§èƒ½æµ‹è¯•', () => {
    test('å¤§æ•°æ®é›†å¯è§†åŒ–æ€§èƒ½', async () => {
      const largeDataSet = generateLargeDataSet(1000000); // 100ä¸‡æ•°æ®ç‚¹

      const startTime = performance.now();
      
      const result = await performanceTestSuite.runLargeDataVisualizationTest({
        dataSet: largeDataSet,
        componentType: 'plot',
        enableOptimizations: true
      });

      const processingTime = performance.now() - startTime;

      expect(processingTime).toBeLessThan(5000); // <5ç§’å¤„ç†æ—¶é—´
      expect(result.renderingPerformance.averageFrameTime).toBeLessThan(16);
      expect(result.memoryEfficiency).toBeGreaterThan(0.7); // >70%å†…å­˜æ•ˆç‡
    });

    test('æ•°æ®å¯¼å‡ºæ€§èƒ½æµ‹è¯•', async () => {
      const exportDataSet = generateLargeDataSet(500000); // 50ä¸‡æ•°æ®ç‚¹

      const exportTests = [
        { format: 'csv', expectedSpeed: 10000 }, // 10k records/sec
        { format: 'json', expectedSpeed: 5000 },  // 5k records/sec
        { format: 'excel', expectedSpeed: 1000 }  // 1k records/sec
      ];

      for (const testConfig of exportTests) {
        const startTime = performance.now();
        
        const result = await performanceTestSuite.runExportPerformanceTest({
          dataSet: exportDataSet,
          format: testConfig.format,
          filePath: `/tmp/perf-test.${testConfig.format}`
        });

        const duration = performance.now() - startTime;
        const recordsPerSecond = exportDataSet.length / (duration / 1000);

        expect(recordsPerSecond).toBeGreaterThanOrEqual(testConfig.expectedSpeed);
        expect(result.success).toBe(true);
        expect(result.fileSize).toBeGreaterThan(0);
      }
    });

    test('æ•°æ®è§£ææ€§èƒ½æµ‹è¯•', async () => {
      const testFrames = generateTestFrames(100000); // 10ä¸‡å¸§æ•°æ®

      const parseResult = await performanceTestSuite.runParsingPerformanceTest({
        frames: testFrames,
        parseScript: 'function parse(frame) { return frame.split(",").map(Number); }',
        enableOptimizations: true
      });

      expect(parseResult.framesPerSecond).toBeGreaterThanOrEqual(10000); // â‰¥10k frames/sec
      expect(parseResult.errorRate).toBeLessThan(0.001); // <0.1%é”™è¯¯ç‡
      expect(parseResult.averageParseTime).toBeLessThan(0.1); // <0.1ms per frame
    });
  });

  describe('é•¿æœŸç¨³å®šæ€§æµ‹è¯•', () => {
    test('24å°æ—¶è¿ç»­è¿è¡Œç¨³å®šæ€§æµ‹è¯•', async () => {
      const stabilityTest = await performanceTestSuite.runStabilityTest({
        duration: 24 * 60 * 60 * 1000, // 24å°æ—¶ï¼ˆå®é™…æµ‹è¯•ä¸­å¯ç¼©çŸ­ï¼‰
        dataRate: 1, // 1Hzï¼ˆé™ä½é¢‘ç‡ä»¥è¿›è¡Œé•¿æœŸæµ‹è¯•ï¼‰
        memoryLeakThreshold: 10 * 1024 * 1024, // 10MBå†…å­˜æ³„æ¼é˜ˆå€¼
        crashTolerance: 0 // 0å´©æºƒå®¹å¿åº¦
      });

      expect(stabilityTest.totalUptime).toBeGreaterThan(stabilityTest.duration * 0.99); // 99%è¿è¡Œæ—¶é—´
      expect(stabilityTest.memoryLeakDetected).toBe(false);
      expect(stabilityTest.crashCount).toBe(0);
      expect(stabilityTest.errorCount).toBeLessThan(10); // <10ä¸ªé”™è¯¯
    });

    test('å†…å­˜æ³„æ¼æ£€æµ‹æµ‹è¯•', async () => {
      const memoryLeakTest = await performanceTestSuite.runMemoryLeakTest({
        operationCount: 10000,
        cycleCount: 100,
        checkInterval: 1000
      });

      expect(memoryLeakTest.leakDetected).toBe(false);
      expect(memoryLeakTest.maxMemoryIncrease).toBeLessThan(50 * 1024 * 1024); // <50MB
      expect(memoryLeakTest.memoryStability).toBeGreaterThan(0.95); // 95%å†…å­˜ç¨³å®šæ€§
    });
  });

  function generateLargeDataSet(size: number) {
    return Array.from({ length: size }, (_, i) => ({
      id: `record_${i}`,
      value: Math.sin(i * 0.001) * 100 + Math.random() * 10,
      timestamp: Date.now() - (size - i) * 1000,
      metadata: {
        index: i,
        category: Math.floor(i / 1000),
        quality: Math.random() > 0.1 ? 'good' : 'poor'
      }
    }));
  }

  function generateTestFrames(count: number) {
    return Array.from({ length: count }, (_, i) => 
      `${Math.random() * 100},${Math.random() * 50},${Date.now() + i}`
    );
  }
});
```

## 4. æµ‹è¯•å®æ–½æ—¶é—´çº¿

### 4.1 åˆ†é˜¶æ®µå®æ–½è®¡åˆ’

```mermaid
gantt
    title å•å…ƒæµ‹è¯•å®æ–½æ—¶é—´çº¿
    dateFormat  YYYY-MM-DD
    section Phase 1 - åŸºç¡€è®¾æ–½æ­å»º
    æµ‹è¯•æ¡†æ¶é…ç½®           :2024-01-01, 3d
    CI/CDæµæ°´çº¿è®¾ç½®       :2024-01-04, 4d
    Mockç³»ç»Ÿå»ºç«‹          :2024-01-08, 3d
    æµ‹è¯•æ•°æ®å‡†å¤‡           :2024-01-11, 2d
    section Phase 2 - æ ¸å¿ƒæ¨¡å—æµ‹è¯• (P0)
    é€šè®¯æ¨¡å—æµ‹è¯•å¼€å‘        :2024-01-13, 8d
    æ•°æ®è§£ææ¨¡å—æµ‹è¯•        :2024-01-21, 7d
    å¯è§†åŒ–ç»„ä»¶æµ‹è¯•         :2024-01-28, 10d
    æ ¸å¿ƒæ¨¡å—é›†æˆæµ‹è¯•        :2024-02-07, 5d
    section Phase 3 - é‡è¦æ¨¡å—æµ‹è¯• (P1)
    æ‰©å±•æ¨¡å—æµ‹è¯•           :2024-02-12, 6d
    æ€§èƒ½ä¼˜åŒ–æ¨¡å—æµ‹è¯•        :2024-02-18, 5d
    é¡¹ç›®ç®¡ç†æ¨¡å—æµ‹è¯•        :2024-02-23, 4d
    section Phase 4 - è¾…åŠ©æ¨¡å—æµ‹è¯• (P2)
    æ•°æ®å¯¼å‡ºæ¨¡å—æµ‹è¯•        :2024-02-27, 4d
    è¾…åŠ©åŠŸèƒ½é›†æˆæµ‹è¯•        :2024-03-03, 3d
    section Phase 5 - ç³»ç»Ÿçº§æµ‹è¯•
    ç«¯åˆ°ç«¯æµ‹è¯•å¼€å‘         :2024-03-06, 5d
    æ€§èƒ½åŸºå‡†æµ‹è¯•           :2024-03-11, 4d
    ç¨³å®šæ€§æµ‹è¯•             :2024-03-15, 3d
    section Phase 6 - è´¨é‡ä¿è¯
    æµ‹è¯•è¦†ç›–ç‡åˆ†æ         :2024-03-18, 2d
    è´¨é‡é—¨ç¦è®¾ç½®           :2024-03-20, 2d
    æ–‡æ¡£æ•´ç†å’Œäº¤ä»˜         :2024-03-22, 2d
```

### 4.2 å…³é”®é‡Œç¨‹ç¢‘å’Œäº¤ä»˜ç‰©

| é‡Œç¨‹ç¢‘ | æ—¶é—´ | äº¤ä»˜ç‰© | éªŒæ”¶æ ‡å‡† |
|-------|------|-------|----------|
| M1 - æµ‹è¯•åŸºç¡€è®¾æ–½ | 2024-01-12 | æµ‹è¯•æ¡†æ¶ã€CI/CDã€Mockç³»ç»Ÿ | èƒ½è¿è¡ŒåŸºç¡€æµ‹è¯•ç”¨ä¾‹ |
| M2 - æ ¸å¿ƒæ¨¡å—æµ‹è¯• | 2024-02-11 | 3ä¸ªP0æ¨¡å—æµ‹è¯•å®Œæˆ | è¦†ç›–ç‡â‰¥95%ï¼Œæ‰€æœ‰æµ‹è¯•é€šè¿‡ |
| M3 - å…¨æ¨¡å—æµ‹è¯• | 2024-03-05 | 7ä¸ªæ¨¡å—æµ‹è¯•å®Œæˆ | æ€»ä½“è¦†ç›–ç‡â‰¥95% |
| M4 - é›†æˆæµ‹è¯• | 2024-03-17 | é›†æˆæµ‹è¯•ã€æ€§èƒ½æµ‹è¯• | æ€§èƒ½æŒ‡æ ‡è¾¾æ ‡ |
| M5 - è´¨é‡äº¤ä»˜ | 2024-03-24 | å®Œæ•´æµ‹è¯•å¥—ä»¶ | è´¨é‡é—¨ç¦é€šè¿‡ |

### 4.3 èµ„æºåˆ†é…è®¡åˆ’

```typescript
interface ResourceAllocation {
  teamStructure: {
    testLead: 1,           // æµ‹è¯•è´Ÿè´£äºº
    seniorTesters: 2,      // é«˜çº§æµ‹è¯•å·¥ç¨‹å¸ˆ
    juniorTesters: 3,      // åˆçº§æµ‹è¯•å·¥ç¨‹å¸ˆ
    automationEngineer: 1, // è‡ªåŠ¨åŒ–å·¥ç¨‹å¸ˆ
    performanceEngineer: 1 // æ€§èƒ½æµ‹è¯•å·¥ç¨‹å¸ˆ
  },
  
  effortDistribution: {
    testDevelopment: '60%',    // æµ‹è¯•ä»£ç å¼€å‘
    testExecution: '20%',      // æµ‹è¯•æ‰§è¡Œå’Œè°ƒè¯•
    toolingAndInfra: '15%',    // å·¥å…·å’ŒåŸºç¡€è®¾æ–½
    documentation: '5%'        // æ–‡æ¡£ç¼–å†™
  },
  
  skillsRequired: [
    'TypeScript/JavaScriptä¸“ä¸šçŸ¥è¯†',
    'Vue.jsæµ‹è¯•ç»éªŒ',
    'Node.jsåç«¯æµ‹è¯•',
    'VSCodeæ‰©å±•å¼€å‘',
    'æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–',
    'CI/CDæµæ°´çº¿é…ç½®',
    'Mockå’Œå­˜æ ¹æŠ€æœ¯'
  ]
}
```

## 5. è´¨é‡ä¿è¯æµç¨‹

### 5.1 ä»£ç è´¨é‡é—¨ç¦

```typescript
// quality-gates.config.ts
export const qualityGates = {
  // è¦†ç›–ç‡é—¨ç¦
  coverage: {
    global: {
      lines: 95,
      branches: 90,
      functions: 98,
      statements: 95
    },
    perModule: {
      communication: { lines: 98 },
      parsing: { lines: 97 },
      visualization: { lines: 95 },
      extensions: { lines: 90 },
      performance: { lines: 95 },
      export: { lines: 92 }
    }
  },
  
  // æ€§èƒ½é—¨ç¦
  performance: {
    unitTestDuration: 30000,        // 30ç§’å†…å®Œæˆå•å…ƒæµ‹è¯•
    integrationTestDuration: 300000, // 5åˆ†é’Ÿå†…å®Œæˆé›†æˆæµ‹è¯•
    memoryLeakTolerance: 10 * 1024 * 1024, // 10MBå†…å­˜æ³„æ¼å®¹å¿åº¦
    realtimePerformance: {
      updateRate: 18,               // â‰¥18Hzæ›´æ–°ç‡
      latency: 50,                  // â‰¤50mså»¶è¿Ÿ
      frameRate: 55                 // â‰¥55fpsæ¸²æŸ“
    }
  },
  
  // ä»£ç è´¨é‡é—¨ç¦
  codeQuality: {
    eslintErrors: 0,                // 0ä¸ªESLinté”™è¯¯
    tscErrors: 0,                   // 0ä¸ªTypeScripté”™è¯¯
    complexityScore: 10,            // å¤æ‚åº¦â‰¤10
    duplicateCodePercentage: 3,     // é‡å¤ä»£ç â‰¤3%
    maintainabilityIndex: 70        // å¯ç»´æŠ¤æ€§æŒ‡æ•°â‰¥70
  },
  
  // æµ‹è¯•è´¨é‡é—¨ç¦
  testQuality: {
    testToCodeRatio: 1.2,           // æµ‹è¯•ä»£ç ä¸äº§å“ä»£ç æ¯”ä¾‹â‰¥1.2:1
    assertionsPerTest: 3,           // å¹³å‡æ¯ä¸ªæµ‹è¯•â‰¥3ä¸ªæ–­è¨€
    mockUsagePercentage: 80,        // 80%çš„å¤–éƒ¨ä¾èµ–ä½¿ç”¨Mock
    testExecutionTime: {
      unit: 0.1,                    // å•å…ƒæµ‹è¯•å¹³å‡â‰¤0.1ç§’
      integration: 2.0              // é›†æˆæµ‹è¯•å¹³å‡â‰¤2ç§’
    }
  }
};
```

### 5.2 æŒç»­é›†æˆæµæ°´çº¿

```yaml
# .github/workflows/test-pipeline.yml
name: Serial Studio æµ‹è¯•æµæ°´çº¿

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  # é˜¶æ®µ1ï¼šä»£ç è´¨é‡æ£€æŸ¥
  code-quality:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: TypeScript ç±»å‹æ£€æŸ¥
      run: npm run type-check
    
    - name: ESLint ä»£ç æ£€æŸ¥
      run: npm run lint
    
    - name: Prettier æ ¼å¼æ£€æŸ¥
      run: npm run format:check
    
    - name: ä¾èµ–å®‰å…¨æ‰«æ
      run: npm audit --audit-level high

  # é˜¶æ®µ2ï¼šå•å…ƒæµ‹è¯•
  unit-tests:
    runs-on: ubuntu-latest
    needs: code-quality
    strategy:
      matrix:
        node-version: [16.x, 18.x, 20.x]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: è¿è¡Œå•å…ƒæµ‹è¯•
      run: npm run test:unit --coverage
      env:
        NODE_OPTIONS: --max-old-space-size=4096
    
    - name: æ£€æŸ¥æµ‹è¯•è¦†ç›–ç‡
      run: npm run coverage:check
    
    - name: ä¸Šä¼ è¦†ç›–ç‡æŠ¥å‘Š
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-${{ matrix.node-version }}

  # é˜¶æ®µ3ï¼šé›†æˆæµ‹è¯•
  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: å¯åŠ¨æµ‹è¯•æœåŠ¡
      run: |
        npm run test:services:start &
        sleep 10
    
    - name: è¿è¡Œé›†æˆæµ‹è¯•
      run: npm run test:integration
      timeout-minutes: 10
    
    - name: è¿è¡ŒAPIæµ‹è¯•
      run: npm run test:api
    
    - name: åœæ­¢æµ‹è¯•æœåŠ¡
      run: npm run test:services:stop

  # é˜¶æ®µ4ï¼šæ€§èƒ½æµ‹è¯•
  performance-tests:
    runs-on: ubuntu-latest
    needs: integration-tests
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: è¿è¡Œæ€§èƒ½åŸºå‡†æµ‹è¯•
      run: npm run test:performance
      timeout-minutes: 15
    
    - name: æ£€æŸ¥æ€§èƒ½å›å½’
      run: npm run performance:check
    
    - name: ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
      run: npm run performance:report
    
    - name: ä¸Šä¼ æ€§èƒ½ç»“æœ
      uses: actions/upload-artifact@v3
      with:
        name: performance-results
        path: performance-results/

  # é˜¶æ®µ5ï¼šç«¯åˆ°ç«¯æµ‹è¯•
  e2e-tests:
    runs-on: ubuntu-latest
    needs: performance-tests
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: å®‰è£…VSCodeæµ‹è¯•ç¯å¢ƒ
      run: npm run vscode:prepublish
    
    - name: è¿è¡ŒE2Eæµ‹è¯•
      uses: GabrielBB/xvfb-action@v1
      with:
        run: npm run test:e2e
        options: -screen 0 1920x1080x24
    
    - name: ä¸Šä¼ æµ‹è¯•æˆªå›¾
      if: failure()
      uses: actions/upload-artifact@v3
      with:
        name: e2e-screenshots
        path: test-results/screenshots/

  # é˜¶æ®µ6ï¼šæ„å»ºéªŒè¯
  build-verification:
    runs-on: ubuntu-latest
    needs: e2e-tests
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'
    
    - name: Install dependencies
      run: npm ci
    
    - name: æ„å»ºæ‰©å±•
      run: npm run build
    
    - name: æ‰“åŒ…æ‰©å±•
      run: npm run package
    
    - name: éªŒè¯æ‰©å±•åŒ…
      run: npm run verify:package
    
    - name: ä¸Šä¼ æ‰©å±•åŒ…
      uses: actions/upload-artifact@v3
      with:
        name: vscode-extension
        path: '*.vsix'

  # é˜¶æ®µ7ï¼šè´¨é‡é—¨ç¦æ£€æŸ¥
  quality-gate:
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests, performance-tests, e2e-tests, build-verification]
    
    steps:
    - uses: actions/checkout@v3
    
    - name: ä¸‹è½½æµ‹è¯•ç»“æœ
      uses: actions/download-artifact@v3
    
    - name: è´¨é‡é—¨ç¦æ£€æŸ¥
      run: npm run quality:gate:check
    
    - name: ç”Ÿæˆè´¨é‡æŠ¥å‘Š
      run: npm run quality:report
    
    - name: å‘å¸ƒæµ‹è¯•ç»“æœ
      if: always()
      uses: dorny/test-reporter@v1
      with:
        name: Test Results
        path: 'test-results/*.json'
        reporter: jest-junit
```

### 5.3 æµ‹è¯•æŠ¥å‘Šå’Œç›‘æ§

```typescript
// test-reporting.config.ts
export const testReportingConfig = {
  // è¦†ç›–ç‡æŠ¥å‘Šé…ç½®
  coverage: {
    reporters: ['html', 'lcov', 'text', 'cobertura'],
    outputDirectory: 'coverage',
    thresholds: {
      global: {
        lines: 95,
        branches: 90,
        functions: 98,
        statements: 95
      }
    },
    watermarks: {
      lines: [80, 95],
      branches: [75, 90],
      functions: [85, 98],
      statements: [80, 95]
    }
  },
  
  // æµ‹è¯•ç»“æœæŠ¥å‘Š
  testResults: {
    outputFormats: ['junit', 'json', 'html'],
    outputDirectory: 'test-results',
    includeStackTrace: true,
    includePaths: true,
    generateSummary: true
  },
  
  // æ€§èƒ½æŠ¥å‘Šé…ç½®
  performance: {
    outputDirectory: 'performance-results',
    formats: ['json', 'html', 'csv'],
    benchmarkComparison: true,
    trendAnalysis: true,
    alertThresholds: {
      regressionTolerance: 10, // 10%æ€§èƒ½å›å½’å®¹å¿åº¦
      latencyIncrease: 20,     // 20mså»¶è¿Ÿå¢é•¿å®¹å¿åº¦
      memoryIncrease: 50       // 50MBå†…å­˜å¢é•¿å®¹å¿åº¦
    }
  },
  
  // é”™è¯¯å’Œå¼‚å¸¸æŠ¥å‘Š
  errorReporting: {
    errorTracking: true,
    stackTraceAnalysis: true,
    errorCategorization: true,
    automatedBugReporting: {
      enabled: true,
      jiraIntegration: true,
      slackNotifications: true
    }
  },
  
  // å®æ—¶ç›‘æ§é¢æ¿
  dashboard: {
    enabled: true,
    refreshInterval: 30000, // 30ç§’åˆ·æ–°
    metrics: [
      'test-execution-time',
      'test-success-rate',
      'coverage-percentage',
      'performance-trends',
      'error-rates'
    ],
    alerts: {
      testFailureThreshold: 5,     // 5%æµ‹è¯•å¤±è´¥ç‡
      coverageDropThreshold: 2,    // 2%è¦†ç›–ç‡ä¸‹é™
      performanceRegressionThreshold: 15 // 15%æ€§èƒ½å›å½’
    }
  }
};
```

## 6. æœ€ä½³å®è·µå’ŒæŒ‡å¯¼åŸåˆ™

### 6.1 æµ‹è¯•ç¼–å†™æœ€ä½³å®è·µ

```typescript
// æµ‹è¯•ç¼–å†™è§„èŒƒå’Œæœ€ä½³å®è·µæŒ‡å—

// âœ… å¥½çš„æµ‹è¯•ç”¨ä¾‹ç¤ºä¾‹
describe('ConnectionManager - è¿æ¥ç®¡ç†', () => {
  test('åº”è¯¥æˆåŠŸå»ºç«‹UARTè¿æ¥', async () => {
    // Arrange - å‡†å¤‡æµ‹è¯•ç¯å¢ƒ
    const mockSerialPort = createMockSerialPort();
    const connectionManager = new ConnectionManager();
    const config = {
      type: 'uart',
      port: '/dev/ttyUSB0',
      baudRate: 115200
    };

    // Act - æ‰§è¡Œè¢«æµ‹è¯•çš„æ“ä½œ
    const connection = await connectionManager.createConnection(config);
    
    // Assert - éªŒè¯ç»“æœ
    expect(connection).toBeDefined();
    expect(connection.isConnected()).toBe(true);
    expect(connection.getConfig()).toEqual(config);
  });

  test('åº”è¯¥å¤„ç†è¿æ¥å¤±è´¥å¹¶æŠ›å‡ºé€‚å½“é”™è¯¯', async () => {
    // Arrange
    const connectionManager = new ConnectionManager();
    const invalidConfig = { type: 'uart', port: '/invalid/port' };

    // Act & Assert
    await expect(connectionManager.createConnection(invalidConfig))
      .rejects
      .toThrow(/Failed to connect to port/);
  });
});

// âŒ ä¸å¥½çš„æµ‹è¯•ç”¨ä¾‹ç¤ºä¾‹ï¼ˆé¿å…ï¼‰
describe('Bad test examples', () => {
  test('test connection', async () => {
    const cm = new ConnectionManager();
    const conn = await cm.createConnection({ port: 'COM1' });
    expect(conn).toBeTruthy(); // æ–­è¨€è¿‡äºæ¨¡ç³Š
  });
});
```

### 6.2 Mockå’ŒStubç­–ç•¥

```typescript
// mock-strategies.ts - Mockç­–ç•¥æŒ‡å—

// ç­–ç•¥1ï¼šæ¥å£çº§Mockï¼ˆæ¨èç”¨äºå•å…ƒæµ‹è¯•ï¼‰
interface ISerialPort {
  open(): Promise<void>;
  write(data: Buffer): Promise<void>;
  close(): Promise<void>;
}

class MockSerialPort implements ISerialPort {
  private isOpen = false;
  
  async open(): Promise<void> {
    this.isOpen = true;
  }
  
  async write(data: Buffer): Promise<void> {
    if (!this.isOpen) throw new Error('Port not open');
    // Mock å†™å…¥é€»è¾‘
  }
  
  async close(): Promise<void> {
    this.isOpen = false;
  }
}

// ç­–ç•¥2ï¼šéƒ¨åˆ†Mockï¼ˆæ¨èç”¨äºé›†æˆæµ‹è¯•ï¼‰
const partialMockSerialPort = {
  ...realSerialPort,
  write: vi.fn().mockResolvedValue(undefined),
  on: vi.fn()
};

// ç­–ç•¥3ï¼šæµ‹è¯•æ•°æ®å·¥å‚
class TestDataFactory {
  static createSensorData(overrides?: Partial<SensorData>): SensorData {
    return {
      id: 'test-sensor',
      value: 25.6,
      timestamp: Date.now(),
      units: 'Â°C',
      ...overrides
    };
  }
  
  static createDataStream(count: number, interval: number = 1000): SensorData[] {
    return Array.from({ length: count }, (_, i) => 
      this.createSensorData({
        value: 20 + Math.sin(i * 0.1) * 5,
        timestamp: Date.now() + i * interval
      })
    );
  }
}
```

### 6.3 æ€§èƒ½æµ‹è¯•æŒ‡å¯¼

```typescript
// performance-testing-guide.ts

class PerformanceTestingGuide {
  // åŸåˆ™1ï¼šéš”ç¦»æ€§èƒ½æµ‹è¯•
  static runIsolatedPerformanceTest(testFn: () => Promise<void>) {
    return async () => {
      // é¢„çƒ­JITç¼–è¯‘å™¨
      for (let i = 0; i < 10; i++) {
        await testFn();
      }
      
      // å¼ºåˆ¶åƒåœ¾å›æ”¶
      if (global.gc) global.gc();
      
      // å®é™…æ€§èƒ½æµ‹è¯•
      const startTime = performance.now();
      await testFn();
      const endTime = performance.now();
      
      return endTime - startTime;
    };
  }
  
  // åŸåˆ™2ï¼šç»Ÿè®¡æ„ä¹‰ä¸Šçš„æ€§èƒ½æµ‹è¯•
  static async runStatisticalPerformanceTest(
    testFn: () => Promise<number>,
    iterations: number = 100
  ) {
    const measurements: number[] = [];
    
    for (let i = 0; i < iterations; i++) {
      const measurement = await testFn();
      measurements.push(measurement);
    }
    
    return {
      mean: measurements.reduce((a, b) => a + b) / measurements.length,
      median: measurements.sort()[Math.floor(measurements.length / 2)],
      p95: measurements.sort()[Math.floor(measurements.length * 0.95)],
      p99: measurements.sort()[Math.floor(measurements.length * 0.99)],
      stdDev: this.calculateStandardDeviation(measurements)
    };
  }
  
  // åŸåˆ™3ï¼šå†…å­˜æ³„æ¼æ£€æµ‹
  static async detectMemoryLeaks(
    testFn: () => Promise<void>,
    iterations: number = 1000
  ) {
    const initialMemory = process.memoryUsage().heapUsed;
    
    for (let i = 0; i < iterations; i++) {
      await testFn();
      
      // æ¯100æ¬¡è¿­ä»£æ£€æŸ¥ä¸€æ¬¡å†…å­˜
      if (i % 100 === 0) {
        if (global.gc) global.gc();
        
        const currentMemory = process.memoryUsage().heapUsed;
        const memoryGrowth = currentMemory - initialMemory;
        
        // å¦‚æœå†…å­˜å¢é•¿è¶…è¿‡100MBï¼Œå¯èƒ½å­˜åœ¨å†…å­˜æ³„æ¼
        if (memoryGrowth > 100 * 1024 * 1024) {
          throw new Error(`Potential memory leak detected: ${memoryGrowth} bytes`);
        }
      }
    }
  }
}
```

### 6.4 é”™è¯¯å¤„ç†æµ‹è¯•æ¨¡å¼

```typescript
// error-handling-patterns.ts

class ErrorHandlingTestPatterns {
  // æ¨¡å¼1ï¼šå¼‚å¸¸è¾¹ç•Œæµ‹è¯•
  static testErrorBoundaries() {
    test('åº”è¯¥å¤„ç†è¾¹ç•Œæ¡ä»¶é”™è¯¯', () => {
      const processor = new DataProcessor();
      
      // æµ‹è¯•ç©ºè¾“å…¥
      expect(() => processor.process(null)).toThrow();
      expect(() => processor.process(undefined)).toThrow();
      expect(() => processor.process('')).toThrow();
      
      // æµ‹è¯•è¶…å¤§è¾“å…¥
      const hugaData = 'x'.repeat(10000000);
      expect(() => processor.process(hugaData)).not.toThrow();
    });
  }
  
  // æ¨¡å¼2ï¼šé”™è¯¯æ¢å¤æµ‹è¯•
  static testErrorRecovery() {
    test('åº”è¯¥ä»é”™è¯¯ä¸­è‡ªåŠ¨æ¢å¤', async () => {
      const connection = new MockConnection();
      let errorCount = 0;
      let recoveryCount = 0;
      
      connection.on('error', () => errorCount++);
      connection.on('recovered', () => recoveryCount++);
      
      // æ¨¡æ‹Ÿè¿æ¥ä¸­æ–­
      connection.simulateError();
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      expect(errorCount).toBeGreaterThan(0);
      expect(recoveryCount).toBeGreaterThan(0);
      expect(connection.isConnected()).toBe(true);
    });
  }
  
  // æ¨¡å¼3ï¼šçº§è”é”™è¯¯é˜²æŠ¤æµ‹è¯•
  static testErrorPropagation() {
    test('åº”è¯¥é˜²æ­¢é”™è¯¯çº§è”ä¼ æ’­', async () => {
      const system = new IntegratedSystem();
      const errorHandler = vi.fn();
      
      system.on('componentError', errorHandler);
      
      // åœ¨ä¸€ä¸ªç»„ä»¶ä¸­è§¦å‘é”™è¯¯
      system.getComponent('parsing').simulateError();
      
      // å…¶ä»–ç»„ä»¶åº”è¯¥ç»§ç»­æ­£å¸¸å·¥ä½œ
      expect(system.getComponent('visualization').isActive()).toBe(true);
      expect(system.getComponent('communication').isActive()).toBe(true);
      expect(errorHandler).toHaveBeenCalledOnce();
    });
  }
}
```

## 7. æ€»ç»“å’Œåç»­è®¡åˆ’

### 7.1 æµ‹è¯•æ–¹æ¡ˆæ€»ç»“

é€šè¿‡æœ¬å®Œæ•´çš„å•å…ƒæµ‹è¯•æ–¹æ¡ˆï¼Œæˆ‘ä»¬ä¸ºSerial-Studio VSCodeæ’ä»¶å»ºç«‹äº†ï¼š

1. **å…¨é¢çš„æµ‹è¯•è¦†ç›–ä½“ç³»**ï¼š7å¤§æ ¸å¿ƒæ¨¡å—ï¼Œ86ä¸ªæµ‹è¯•æ–‡ä»¶ï¼Œ1055ä¸ªæµ‹è¯•ç”¨ä¾‹
2. **åˆ†å±‚çš„æµ‹è¯•æ¶æ„**ï¼šå•å…ƒæµ‹è¯•(80%) + é›†æˆæµ‹è¯•(15%) + E2Eæµ‹è¯•(5%)
3. **ä¸¥æ ¼çš„è´¨é‡é—¨ç¦**ï¼šâ‰¥95%ä»£ç è¦†ç›–ç‡ï¼Œ20Hzæ€§èƒ½åŸºå‡†ï¼Œ0å†…å­˜æ³„æ¼
4. **å®Œæ•´çš„CI/CDæµæ°´çº¿**ï¼šè‡ªåŠ¨åŒ–æµ‹è¯•ã€è´¨é‡æ£€æŸ¥ã€æ€§èƒ½ç›‘æ§
5. **è¯¦ç»†çš„å®æ–½æŒ‡å¯¼**ï¼šæœ€ä½³å®è·µã€Mockç­–ç•¥ã€é”™è¯¯å¤„ç†æ¨¡å¼

### 7.2 é¢„æœŸæˆæœ

å®æ–½æœ¬æµ‹è¯•æ–¹æ¡ˆåï¼Œé¡¹ç›®å°†è·å¾—ï¼š

- **é«˜è´¨é‡ä»£ç **ï¼šé€šè¿‡å…¨é¢çš„å•å…ƒæµ‹è¯•ç¡®ä¿ä»£ç è´¨é‡
- **ç¨³å®šçš„äº§å“**ï¼šé€šè¿‡é›†æˆæµ‹è¯•ç¡®ä¿æ¨¡å—é—´åä½œç¨³å®š
- **ä¼˜ç§€çš„æ€§èƒ½**ï¼šé€šè¿‡æ€§èƒ½æµ‹è¯•ç¡®ä¿20Hzå®æ—¶æ›´æ–°ç­‰å…³é”®æŒ‡æ ‡
- **å¯ç»´æŠ¤çš„ä»£ç åº“**ï¼šé€šè¿‡æµ‹è¯•é©±åŠ¨å¼€å‘æé«˜ä»£ç å¯ç»´æŠ¤æ€§
- **å¿«é€Ÿçš„é—®é¢˜å®šä½**ï¼šé€šè¿‡è‡ªåŠ¨åŒ–æµ‹è¯•å¿«é€Ÿå‘ç°å’Œå®šä½é—®é¢˜

### 7.3 åç»­ç»´æŠ¤è®¡åˆ’

1. **æŒç»­ä¼˜åŒ–**ï¼šæ ¹æ®å®é™…ä½¿ç”¨æƒ…å†µæŒç»­ä¼˜åŒ–æµ‹è¯•ç”¨ä¾‹
2. **æ‰©å±•æµ‹è¯•**ï¼šéšç€åŠŸèƒ½å¢åŠ ï¼ŒåŠæ—¶è¡¥å……æ–°çš„æµ‹è¯•ç”¨ä¾‹
3. **æ€§èƒ½ç›‘æ§**ï¼šå»ºç«‹é•¿æœŸçš„æ€§èƒ½è¶‹åŠ¿ç›‘æ§å’Œå‘Šè­¦æœºåˆ¶
4. **å›¢é˜ŸåŸ¹è®­**ï¼šå®šæœŸåŸ¹è®­å›¢é˜Ÿæˆå‘˜æœ€æ–°çš„æµ‹è¯•æŠ€æœ¯å’Œæœ€ä½³å®è·µ
5. **å·¥å…·å‡çº§**ï¼šè·Ÿè¿›æµ‹è¯•å·¥å…·å’Œæ¡†æ¶çš„æ›´æ–°ï¼Œä¿æŒæŠ€æœ¯æ ˆå…ˆè¿›æ€§

<function_calls>
<invoke name="TodoWrite">
<parameter name="todos">[{"content": "\u9605\u8bfb docs/plan_actions \u4e0b\u7684\u6240\u6709\u6280\u672f\u67b6\u6784\u6587\u6863", "status": "completed", "priority": "high", "id": "read-architecture"}, {"content": "\u5206\u6790\u9879\u76ee\u6574\u4f53\u7ed3\u6784\u548c\u529f\u80fd\u6a21\u5757", "status": "completed", "priority": "high", "id": "analyze-project-structure"}, {"content": "\u8bbe\u8ba1\u6574\u4f53\u6d4b\u8bd5\u7b56\u7565\u548c\u8986\u76d6\u7387\u8981\u6c42", "status": "completed", "priority": "high", "id": "design-test-strategy"}, {"content": "\u89c4\u5212\u5404\u4e2a\u529f\u80fd\u6a21\u5757\u7684\u5355\u5143\u6d4b\u8bd5\u5212\u5206", "status": "completed", "priority": "high", "id": "plan-test-modules"}, {"content": "\u7f16\u5199\u8be6\u7ec6\u7684\u5355\u5143\u6d4b\u8bd5\u65b9\u6848\u6587\u6863", "status": "completed", "priority": "high", "id": "create-test-documentation"}, {"content": "\u521b\u5efa docs/utest \u76ee\u5f55\u5e76\u7ec4\u7ec7\u6d4b\u8bd5\u6587\u6863", "status": "completed", "priority": "medium", "id": "create-utest-directory"}]