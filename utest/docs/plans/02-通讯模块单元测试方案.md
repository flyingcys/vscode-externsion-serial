# 通讯模块单元测试方案

## 1. 模块概述

通讯模块是Serial-Studio VSCode插件的核心基础模块，负责实现多协议硬件通讯功能。基于HAL（硬件抽象层）设计模式，支持UART、TCP/UDP、Bluetooth LE等多种通讯协议，具有高度的可扩展性和稳定性要求。

### 1.1 模块架构

```
┌─────────────────────────────────────────────────────────────┐
│                    通讯模块架构                              │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   HAL基础类     │  │   连接管理器     │  │  错误处理器   │ │
│  │ - HALDriver     │  │ - Connection     │  │ - ErrorMgr   │ │
│  │ - BusType枚举   │  │ - Multiplexer    │  │ - Retry逻辑  │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   UART驱动      │  │   网络驱动       │  │  蓝牙LE驱动   │ │
│  │ - SerialHAL     │  │ - NetworkHAL     │  │ - BluetoothHAL│ │
│  │ - 波特率管理     │  │ - Socket管理     │  │ - 设备扫描    │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 测试目标

- **功能完整性**：验证所有通讯协议的连接、数据传输、断开功能
- **性能指标**：确保数据吞吐量≥1MB/s，延迟≤50ms
- **稳定性保证**：长期运行无内存泄漏，连接异常自动恢复
- **兼容性验证**：多设备、多协议并发连接测试
- **错误处理**：各种异常情况的正确处理和恢复

## 2. 测试覆盖率目标

| 测试类型 | 覆盖率目标 | 优先级 | 说明 |
|---------|-----------|--------|------|
| 行覆盖率 | ≥98% | P0 | 核心模块，要求最高覆盖率 |
| 分支覆盖率 | ≥95% | P0 | 包含所有错误处理分支 |
| 函数覆盖率 | ≥100% | P0 | 所有公共接口必须测试 |
| 语句覆盖率 | ≥98% | P0 | 确保核心逻辑完全验证 |

## 3. 详细测试用例设计

### 3.1 HAL基础抽象层测试

```typescript
// tests/communication/hal-driver.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { HALDriver, BusType, HALDriverStatus } from '@/communication/hal-driver';

describe('HAL驱动基础抽象层测试', () => {
  let driver: TestHALDriver;
  let mockEventEmitter: any;

  beforeEach(() => {
    mockEventEmitter = {
      emit: vi.fn(),
      on: vi.fn(),
      off: vi.fn(),
      removeAllListeners: vi.fn()
    };
    driver = new TestHALDriver();
  });

  afterEach(() => {
    driver?.disconnect();
    vi.clearAllMocks();
  });

  describe('基础接口实现', () => {
    test('应该正确初始化HAL驱动', () => {
      expect(driver.getBusType()).toBe(BusType.Serial);
      expect(driver.isOpen()).toBe(false);
      expect(driver.isReadable()).toBe(false);
      expect(driver.isWritable()).toBe(false);
      expect(driver.configurationOk()).toBe(true);
    });

    test('应该正确设置和获取配置', () => {
      const config = {
        baudRate: 115200,
        dataBits: 8,
        stopBits: 1,
        parity: 'none'
      };
      
      driver.setConfiguration(config);
      expect(driver.getConfiguration()).toEqual(config);
      expect(driver.configurationOk()).toBe(true);
    });

    test('应该验证无效配置', () => {
      const invalidConfig = {
        baudRate: -1,
        dataBits: 0
      };
      
      expect(() => driver.setConfiguration(invalidConfig)).toThrow();
      expect(driver.configurationOk()).toBe(false);
    });
  });

  describe('连接生命周期管理', () => {
    test('应该成功建立连接', async () => {
      const connectSpy = vi.spyOn(driver, 'connect');
      
      await expect(driver.connect()).resolves.toBeUndefined();
      expect(connectSpy).toHaveBeenCalledOnce();
      expect(driver.isOpen()).toBe(true);
      expect(driver.getStatus()).toBe(HALDriverStatus.Connected);
    });

    test('应该正确处理连接失败', async () => {
      driver.shouldFailConnection = true;
      
      await expect(driver.connect()).rejects.toThrow('Connection failed');
      expect(driver.isOpen()).toBe(false);
      expect(driver.getStatus()).toBe(HALDriverStatus.Error);
    });

    test('应该成功断开连接', async () => {
      await driver.connect();
      expect(driver.isOpen()).toBe(true);
      
      await driver.disconnect();
      expect(driver.isOpen()).toBe(false);
      expect(driver.getStatus()).toBe(HALDriverStatus.Disconnected);
    });

    test('应该支持重复连接操作', async () => {
      await driver.connect();
      await driver.connect(); // 第二次连接应该是无害的
      expect(driver.isOpen()).toBe(true);
    });
  });

  describe('事件系统测试', () => {
    test('应该正确注册和触发事件监听器', () => {
      const dataHandler = vi.fn();
      const errorHandler = vi.fn();
      
      driver.on('data', dataHandler);
      driver.on('error', errorHandler);
      
      driver.emit('data', Buffer.from('test'));
      driver.emit('error', new Error('test error'));
      
      expect(dataHandler).toHaveBeenCalledWith(Buffer.from('test'));
      expect(errorHandler).toHaveBeenCalledWith(expect.any(Error));
    });

    test('应该支持一次性事件监听器', () => {
      const handler = vi.fn();
      
      driver.once('connected', handler);
      driver.emit('connected');
      driver.emit('connected'); // 第二次应该不触发
      
      expect(handler).toHaveBeenCalledOnce();
    });
  });
});

// 测试用HAL驱动实现
class TestHALDriver extends HALDriver {
  public shouldFailConnection = false;
  private connected = false;
  private config: any = {};

  getBusType(): BusType {
    return BusType.Serial;
  }

  async connect(): Promise<void> {
    if (this.shouldFailConnection) {
      throw new Error('Connection failed');
    }
    this.connected = true;
    this.emit('connected');
  }

  async disconnect(): Promise<void> {
    this.connected = false;
    this.emit('disconnected');
  }

  async write(data: Buffer): Promise<number> {
    if (!this.connected) {
      throw new Error('Not connected');
    }
    return data.length;
  }

  isOpen(): boolean {
    return this.connected;
  }

  isReadable(): boolean {
    return this.connected;
  }

  isWritable(): boolean {
    return this.connected;
  }

  configurationOk(): boolean {
    return this.config.baudRate > 0;
  }

  setConfiguration(config: any): void {
    if (config.baudRate <= 0) {
      throw new Error('Invalid baud rate');
    }
    this.config = config;
  }

  getConfiguration(): any {
    return this.config;
  }
}
```

### 3.2 UART串口驱动测试

```typescript
// tests/communication/serial-hal.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { SerialHAL } from '@/communication/serial-hal';
import { SerialPort } from 'serialport';

// Mock serialport module
vi.mock('serialport', () => ({
  SerialPort: vi.fn().mockImplementation(() => ({
    open: vi.fn(),
    close: vi.fn(),
    write: vi.fn(),
    on: vi.fn(),
    isOpen: vi.fn().mockReturnValue(false),
    readable: vi.fn().mockReturnValue(false),
    writable: vi.fn().mockReturnValue(false)
  })),
  availablePorts: vi.fn().mockResolvedValue([
    { path: '/dev/ttyUSB0', manufacturer: 'FTDI' },
    { path: '/dev/ttyUSB1', manufacturer: 'Arduino' }
  ])
}));

describe('UART串口驱动测试', () => {
  let serialHAL: SerialHAL;
  let mockSerialPort: any;

  beforeEach(() => {
    mockSerialPort = {
      open: vi.fn().mockImplementation((callback) => callback?.()),
      close: vi.fn().mockImplementation((callback) => callback?.()),
      write: vi.fn().mockImplementation((data, callback) => {
        callback?.(null, data.length);
        return true;
      }),
      on: vi.fn(),
      isOpen: vi.fn().mockReturnValue(false),
      readable: true,
      writable: true
    };
    
    vi.mocked(SerialPort).mockReturnValue(mockSerialPort);
    
    serialHAL = new SerialHAL({
      path: '/dev/ttyUSB0',
      baudRate: 115200,
      dataBits: 8,
      stopBits: 1,
      parity: 'none'
    });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('设备列举和配置', () => {
    test('应该正确列举可用串口设备', async () => {
      const ports = await SerialHAL.listPorts();
      
      expect(ports).toHaveLength(2);
      expect(ports[0]).toEqual({
        path: '/dev/ttyUSB0',
        manufacturer: 'FTDI'
      });
    });

    test('应该验证串口配置参数', () => {
      expect(() => new SerialHAL({
        path: '',
        baudRate: -1
      })).toThrow('Invalid configuration');
      
      expect(() => new SerialHAL({
        path: '/dev/ttyUSB0',
        baudRate: 115200,
        dataBits: 12 // 无效值
      })).toThrow('Invalid configuration');
    });

    test('应该正确设置串口参数', () => {
      const config = {
        path: '/dev/ttyUSB0',
        baudRate: 9600,
        dataBits: 7,
        stopBits: 2,
        parity: 'even' as const
      };
      
      serialHAL.setConfiguration(config);
      expect(serialHAL.getConfiguration()).toEqual(config);
    });
  });

  describe('连接管理', () => {
    test('应该成功打开串口连接', async () => {
      mockSerialPort.isOpen.mockReturnValue(true);
      
      await serialHAL.connect();
      
      expect(mockSerialPort.open).toHaveBeenCalled();
      expect(serialHAL.isOpen()).toBe(true);
    });

    test('应该处理连接失败情况', async () => {
      mockSerialPort.open.mockImplementation((callback) => {
        callback(new Error('Port busy'));
      });
      
      await expect(serialHAL.connect()).rejects.toThrow('Port busy');
      expect(serialHAL.isOpen()).toBe(false);
    });

    test('应该正确关闭串口连接', async () => {
      mockSerialPort.isOpen.mockReturnValue(true);
      await serialHAL.connect();
      
      mockSerialPort.isOpen.mockReturnValue(false);
      await serialHAL.disconnect();
      
      expect(mockSerialPort.close).toHaveBeenCalled();
      expect(serialHAL.isOpen()).toBe(false);
    });
  });

  describe('数据传输', () => {
    beforeEach(async () => {
      mockSerialPort.isOpen.mockReturnValue(true);
      await serialHAL.connect();
    });

    test('应该成功发送数据', async () => {
      const testData = Buffer.from('Hello World');
      
      const bytesWritten = await serialHAL.write(testData);
      
      expect(mockSerialPort.write).toHaveBeenCalledWith(testData, expect.any(Function));
      expect(bytesWritten).toBe(testData.length);
    });

    test('应该处理发送数据失败', async () => {
      mockSerialPort.write.mockImplementation((data, callback) => {
        callback(new Error('Write failed'));
      });
      
      const testData = Buffer.from('test');
      await expect(serialHAL.write(testData)).rejects.toThrow('Write failed');
    });

    test('应该正确接收数据', (done) => {
      const testData = Buffer.from('Received data');
      
      serialHAL.on('data', (data) => {
        expect(data).toEqual(testData);
        done();
      });
      
      // 模拟数据接收
      const dataHandler = mockSerialPort.on.mock.calls.find(
        call => call[0] === 'data'
      )?.[1];
      
      dataHandler?.(testData);
    });

    test('应该处理大数据量传输', async () => {
      const largeData = Buffer.alloc(64 * 1024, 'A'); // 64KB数据
      
      const bytesWritten = await serialHAL.write(largeData);
      
      expect(bytesWritten).toBe(largeData.length);
      expect(mockSerialPort.write).toHaveBeenCalledWith(largeData, expect.any(Function));
    });
  });

  describe('错误处理和恢复', () => {
    test('应该正确处理串口错误', (done) => {
      const testError = new Error('Serial port error');
      
      serialHAL.on('error', (error) => {
        expect(error.message).toBe('Serial port error');
        done();
      });
      
      // 模拟错误
      const errorHandler = mockSerialPort.on.mock.calls.find(
        call => call[0] === 'error'
      )?.[1];
      
      errorHandler?.(testError);
    });

    test('应该支持自动重连机制', async () => {
      serialHAL.setAutoReconnect(true, 1000);
      
      // 模拟连接断开
      mockSerialPort.isOpen.mockReturnValue(false);
      serialHAL.emit('close');
      
      // 等待重连尝试
      await new Promise(resolve => setTimeout(resolve, 1100));
      
      expect(mockSerialPort.open).toHaveBeenCalledTimes(2); // 初始连接 + 重连
    });
  });

  describe('性能测试', () => {
    test('应该满足数据吞吐量要求', async () => {
      mockSerialPort.isOpen.mockReturnValue(true);
      await serialHAL.connect();
      
      const dataSize = 1024 * 1024; // 1MB
      const testData = Buffer.alloc(dataSize, 'X');
      
      const startTime = performance.now();
      await serialHAL.write(testData);
      const duration = performance.now() - startTime;
      
      const throughput = dataSize / (duration / 1000); // bytes/second
      expect(throughput).toBeGreaterThan(1024 * 1024); // ≥1MB/s
    });

    test('应该测试数据传输延迟', async () => {
      mockSerialPort.isOpen.mockReturnValue(true);
      await serialHAL.connect();
      
      const testData = Buffer.from('ping');
      
      const startTime = performance.now();
      await serialHAL.write(testData);
      const latency = performance.now() - startTime;
      
      expect(latency).toBeLessThan(50); // <50ms
    });
  });
});
```

### 3.3 网络通讯驱动测试

```typescript
// tests/communication/network-hal.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { NetworkHAL, NetworkProtocol } from '@/communication/network-hal';
import { Socket } from 'net';
import { createSocket } from 'dgram';

// Mock net and dgram modules
vi.mock('net', () => ({
  Socket: vi.fn(),
  createConnection: vi.fn()
}));

vi.mock('dgram', () => ({
  createSocket: vi.fn()
}));

describe('网络通讯驱动测试', () => {
  let networkHAL: NetworkHAL;
  let mockSocket: any;
  let mockUDPSocket: any;

  beforeEach(() => {
    mockSocket = {
      connect: vi.fn(),
      end: vi.fn(),
      destroy: vi.fn(),
      write: vi.fn(),
      on: vi.fn(),
      removeAllListeners: vi.fn(),
      readable: true,
      writable: true,
      destroyed: false
    };

    mockUDPSocket = {
      bind: vi.fn(),
      send: vi.fn(),
      close: vi.fn(),
      on: vi.fn(),
      removeAllListeners: vi.fn()
    };

    vi.mocked(Socket).mockReturnValue(mockSocket);
    vi.mocked(createSocket).mockReturnValue(mockUDPSocket);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('TCP连接测试', () => {
    beforeEach(() => {
      networkHAL = new NetworkHAL({
        protocol: NetworkProtocol.TCP,
        host: '192.168.1.100',
        port: 8080,
        timeout: 5000
      });
    });

    test('应该成功建立TCP连接', async () => {
      mockSocket.connect.mockImplementation((port, host, callback) => {
        setTimeout(callback, 10);
      });

      await networkHAL.connect();

      expect(mockSocket.connect).toHaveBeenCalledWith(8080, '192.168.1.100', expect.any(Function));
      expect(networkHAL.isOpen()).toBe(true);
    });

    test('应该处理TCP连接超时', async () => {
      mockSocket.connect.mockImplementation(() => {
        // 不调用回调，模拟超时
      });

      await expect(networkHAL.connect()).rejects.toThrow('Connection timeout');
    });

    test('应该正确发送TCP数据', async () => {
      mockSocket.connect.mockImplementation((port, host, callback) => callback());
      await networkHAL.connect();

      const testData = Buffer.from('TCP test data');
      mockSocket.write.mockReturnValue(true);

      const bytesWritten = await networkHAL.write(testData);

      expect(mockSocket.write).toHaveBeenCalledWith(testData);
      expect(bytesWritten).toBe(testData.length);
    });

    test('应该处理TCP连接中断', (done) => {
      networkHAL.on('disconnect', () => {
        expect(networkHAL.isOpen()).toBe(false);
        done();
      });

      // 模拟连接中断
      const closeHandler = mockSocket.on.mock.calls.find(
        call => call[0] === 'close'
      )?.[1];

      closeHandler?.();
    });
  });

  describe('UDP连接测试', () => {
    beforeEach(() => {
      networkHAL = new NetworkHAL({
        protocol: NetworkProtocol.UDP,
        host: '192.168.1.100',
        port: 8080,
        localPort: 9090
      });
    });

    test('应该成功创建UDP套接字', async () => {
      mockUDPSocket.bind.mockImplementation((port, callback) => {
        setTimeout(callback, 10);
      });

      await networkHAL.connect();

      expect(mockUDPSocket.bind).toHaveBeenCalledWith(9090, expect.any(Function));
      expect(networkHAL.isOpen()).toBe(true);
    });

    test('应该正确发送UDP数据', async () => {
      mockUDPSocket.bind.mockImplementation((port, callback) => callback());
      await networkHAL.connect();

      const testData = Buffer.from('UDP test data');
      mockUDPSocket.send.mockImplementation((data, port, host, callback) => {
        callback(null);
      });

      const bytesWritten = await networkHAL.write(testData);

      expect(mockUDPSocket.send).toHaveBeenCalledWith(
        testData, 8080, '192.168.1.100', expect.any(Function)
      );
      expect(bytesWritten).toBe(testData.length);
    });

    test('应该处理UDP发送错误', async () => {
      mockUDPSocket.bind.mockImplementation((port, callback) => callback());
      await networkHAL.connect();

      mockUDPSocket.send.mockImplementation((data, port, host, callback) => {
        callback(new Error('Network unreachable'));
      });

      const testData = Buffer.from('test');
      await expect(networkHAL.write(testData)).rejects.toThrow('Network unreachable');
    });
  });

  describe('连接池管理测试', () => {
    test('应该支持多个并发连接', async () => {
      const connections = [];
      
      for (let i = 0; i < 5; i++) {
        const hal = new NetworkHAL({
          protocol: NetworkProtocol.TCP,
          host: '192.168.1.100',
          port: 8080 + i
        });
        connections.push(hal);
      }

      const mockConnects = connections.map(() => {
        const mock = { ...mockSocket };
        mock.connect.mockImplementation((port, host, callback) => callback());
        vi.mocked(Socket).mockReturnValueOnce(mock);
        return mock;
      });

      await Promise.all(connections.map(hal => hal.connect()));

      connections.forEach((hal, index) => {
        expect(hal.isOpen()).toBe(true);
        expect(mockConnects[index].connect).toHaveBeenCalled();
      });
    });

    test('应该正确管理连接生命周期', async () => {
      const connectionManager = new NetworkConnectionManager();
      
      const hal1 = await connectionManager.createConnection({
        protocol: NetworkProtocol.TCP,
        host: '192.168.1.100',
        port: 8080
      });

      const hal2 = await connectionManager.createConnection({
        protocol: NetworkProtocol.UDP,
        host: '192.168.1.101',
        port: 8081
      });

      expect(connectionManager.getActiveConnections()).toHaveLength(2);

      await connectionManager.closeConnection(hal1);
      expect(connectionManager.getActiveConnections()).toHaveLength(1);

      await connectionManager.closeAllConnections();
      expect(connectionManager.getActiveConnections()).toHaveLength(0);
    });
  });

  describe('网络性能测试', () => {
    test('应该测量网络延迟', async () => {
      mockSocket.connect.mockImplementation((port, host, callback) => callback());
      await networkHAL.connect();

      const pingData = Buffer.from('PING');
      let responseTime: number;

      networkHAL.on('data', (data) => {
        if (data.toString() === 'PONG') {
          responseTime = performance.now() - startTime;
        }
      });

      const startTime = performance.now();
      await networkHAL.write(pingData);

      // 模拟响应
      setTimeout(() => {
        const dataHandler = mockSocket.on.mock.calls.find(
          call => call[0] === 'data'
        )?.[1];
        dataHandler?.(Buffer.from('PONG'));
      }, 20);

      await new Promise(resolve => setTimeout(resolve, 50));
      expect(responseTime!).toBeLessThan(50); // 网络延迟应小于50ms
    });

    test('应该测试网络吞吐量', async () => {
      mockSocket.connect.mockImplementation((port, host, callback) => callback());
      mockSocket.write.mockReturnValue(true);
      await networkHAL.connect();

      const dataSize = 1024 * 1024; // 1MB
      const testData = Buffer.alloc(dataSize, 'N');

      const startTime = performance.now();
      await networkHAL.write(testData);
      const duration = performance.now() - startTime;

      const throughput = dataSize / (duration / 1000);
      expect(throughput).toBeGreaterThan(1024 * 1024); // ≥1MB/s
    });
  });
});

// 辅助类用于连接管理测试
class NetworkConnectionManager {
  private connections: NetworkHAL[] = [];

  async createConnection(config: any): Promise<NetworkHAL> {
    const hal = new NetworkHAL(config);
    await hal.connect();
    this.connections.push(hal);
    return hal;
  }

  async closeConnection(hal: NetworkHAL): Promise<void> {
    await hal.disconnect();
    this.connections = this.connections.filter(c => c !== hal);
  }

  async closeAllConnections(): Promise<void> {
    await Promise.all(this.connections.map(hal => hal.disconnect()));
    this.connections = [];
  }

  getActiveConnections(): NetworkHAL[] {
    return this.connections.filter(hal => hal.isOpen());
  }
}
```

### 3.4 蓝牙LE驱动测试

```typescript
// tests/communication/bluetooth-hal.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { BluetoothHAL } from '@/communication/bluetooth-hal';

// Mock noble library
vi.mock('noble', () => ({
  state: 'poweredOn',
  startScanning: vi.fn(),
  stopScanning: vi.fn(),
  on: vi.fn(),
  removeAllListeners: vi.fn()
}));

describe('蓝牙LE驱动测试', () => {
  let bluetoothHAL: BluetoothHAL;
  let mockNoble: any;
  let mockPeripheral: any;
  let mockCharacteristic: any;

  beforeEach(() => {
    mockCharacteristic = {
      uuid: 'test-char-uuid',
      write: vi.fn(),
      on: vi.fn(),
      subscribe: vi.fn(),
      unsubscribe: vi.fn()
    };

    mockPeripheral = {
      uuid: 'test-device-uuid',
      advertisement: {
        localName: 'Test Device'
      },
      connect: vi.fn(),
      disconnect: vi.fn(),
      discoverServices: vi.fn(),
      on: vi.fn(),
      state: 'disconnected'
    };

    mockNoble = {
      state: 'poweredOn',
      startScanning: vi.fn(),
      stopScanning: vi.fn(),
      on: vi.fn(),
      removeAllListeners: vi.fn()
    };

    bluetoothHAL = new BluetoothHAL({
      deviceUUID: 'test-device-uuid',
      serviceUUID: 'test-service-uuid',
      characteristicUUID: 'test-char-uuid',
      scanTimeout: 10000
    });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('设备扫描和发现', () => {
    test('应该成功扫描蓝牙设备', async () => {
      const discoveredDevices: any[] = [];

      bluetoothHAL.on('deviceDiscovered', (device) => {
        discoveredDevices.push(device);
      });

      bluetoothHAL.startScan();

      // 模拟设备发现
      const discoverHandler = mockNoble.on.mock.calls.find(
        call => call[0] === 'discover'
      )?.[1];

      discoverHandler?.(mockPeripheral);

      expect(discoveredDevices).toHaveLength(1);
      expect(discoveredDevices[0]).toEqual({
        uuid: 'test-device-uuid',
        name: 'Test Device',
        rssi: undefined
      });
    });

    test('应该处理扫描超时', async () => {
      bluetoothHAL.setScanTimeout(100);

      const scanPromise = bluetoothHAL.scan();

      await expect(scanPromise).rejects.toThrow('Scan timeout');
    });

    test('应该正确过滤设备', async () => {
      bluetoothHAL.setDeviceFilter((device) => {
        return device.advertisement.localName?.includes('Test');
      });

      const validDevice = { ...mockPeripheral };
      const invalidDevice = {
        ...mockPeripheral,
        advertisement: { localName: 'Invalid Device' }
      };

      bluetoothHAL.startScan();

      const discoverHandler = mockNoble.on.mock.calls.find(
        call => call[0] === 'discover'
      )?.[1];

      const discoveredDevices: any[] = [];
      bluetoothHAL.on('deviceDiscovered', (device) => {
        discoveredDevices.push(device);
      });

      discoverHandler?.(validDevice);
      discoverHandler?.(invalidDevice);

      expect(discoveredDevices).toHaveLength(1);
      expect(discoveredDevices[0].name).toBe('Test Device');
    });
  });

  describe('设备连接管理', () => {
    test('应该成功连接蓝牙设备', async () => {
      mockPeripheral.connect.mockImplementation((callback) => {
        mockPeripheral.state = 'connected';
        callback?.();
      });

      mockPeripheral.discoverServices.mockImplementation((uuids, callback) => {
        const mockService = {
          uuid: 'test-service-uuid',
          discoverCharacteristics: vi.fn().mockImplementation((uuids, callback) => {
            callback(null, [mockCharacteristic]);
          })
        };
        callback(null, [mockService]);
      });

      await bluetoothHAL.connectToDevice(mockPeripheral);

      expect(mockPeripheral.connect).toHaveBeenCalled();
      expect(bluetoothHAL.isOpen()).toBe(true);
    });

    test('应该处理连接失败', async () => {
      mockPeripheral.connect.mockImplementation((callback) => {
        callback(new Error('Connection failed'));
      });

      await expect(bluetoothHAL.connectToDevice(mockPeripheral))
        .rejects.toThrow('Connection failed');
      expect(bluetoothHAL.isOpen()).toBe(false);
    });

    test('应该正确断开连接', async () => {
      // 先建立连接
      mockPeripheral.connect.mockImplementation((callback) => {
        mockPeripheral.state = 'connected';
        callback?.();
      });
      mockPeripheral.discoverServices.mockImplementation((uuids, callback) => {
        const mockService = {
          uuid: 'test-service-uuid',
          discoverCharacteristics: vi.fn().mockImplementation((uuids, callback) => {
            callback(null, [mockCharacteristic]);
          })
        };
        callback(null, [mockService]);
      });

      await bluetoothHAL.connectToDevice(mockPeripheral);

      // 断开连接
      mockPeripheral.disconnect.mockImplementation((callback) => {
        mockPeripheral.state = 'disconnected';
        callback?.();
      });

      await bluetoothHAL.disconnect();

      expect(mockPeripheral.disconnect).toHaveBeenCalled();
      expect(bluetoothHAL.isOpen()).toBe(false);
    });
  });

  describe('数据传输', () => {
    beforeEach(async () => {
      // 设置连接状态
      mockPeripheral.connect.mockImplementation((callback) => {
        mockPeripheral.state = 'connected';
        callback?.();
      });
      mockPeripheral.discoverServices.mockImplementation((uuids, callback) => {
        const mockService = {
          uuid: 'test-service-uuid',
          discoverCharacteristics: vi.fn().mockImplementation((uuids, callback) => {
            callback(null, [mockCharacteristic]);
          })
        };
        callback(null, [mockService]);
      });

      await bluetoothHAL.connectToDevice(mockPeripheral);
    });

    test('应该成功发送数据', async () => {
      const testData = Buffer.from('BLE test data');
      
      mockCharacteristic.write.mockImplementation((data, withoutResponse, callback) => {
        callback?.();
      });

      const bytesWritten = await bluetoothHAL.write(testData);

      expect(mockCharacteristic.write).toHaveBeenCalledWith(
        testData, false, expect.any(Function)
      );
      expect(bytesWritten).toBe(testData.length);
    });

    test('应该处理数据发送失败', async () => {
      mockCharacteristic.write.mockImplementation((data, withoutResponse, callback) => {
        callback(new Error('Write failed'));
      });

      const testData = Buffer.from('test');
      await expect(bluetoothHAL.write(testData)).rejects.toThrow('Write failed');
    });

    test('应该正确接收数据', (done) => {
      const testData = Buffer.from('Received BLE data');

      bluetoothHAL.on('data', (data) => {
        expect(data).toEqual(testData);
        done();
      });

      // 模拟数据接收
      const dataHandler = mockCharacteristic.on.mock.calls.find(
        call => call[0] === 'data'
      )?.[1];

      dataHandler?.(testData, true);
    });

    test('应该支持数据通知订阅', async () => {
      mockCharacteristic.subscribe.mockImplementation((callback) => {
        callback?.();
      });

      await bluetoothHAL.subscribeToNotifications();

      expect(mockCharacteristic.subscribe).toHaveBeenCalled();
    });
  });

  describe('蓝牙特定功能测试', () => {
    test('应该监控信号强度(RSSI)', async () => {
      const rssiValues: number[] = [];

      bluetoothHAL.on('rssiUpdate', (rssi) => {
        rssiValues.push(rssi);
      });

      bluetoothHAL.startRSSIMonitoring(1000); // 每秒更新

      // 模拟RSSI更新
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          bluetoothHAL.emit('rssiUpdate', -50 - i * 10);
        }, i * 100);
      }

      await new Promise(resolve => setTimeout(resolve, 350));

      expect(rssiValues).toEqual([-50, -60, -70]);
    });

    test('应该处理连接中断和自动重连', async () => {
      bluetoothHAL.setAutoReconnect(true, 1000);

      // 模拟连接中断
      mockPeripheral.state = 'disconnected';
      bluetoothHAL.emit('disconnect');

      // 等待重连尝试
      await new Promise(resolve => setTimeout(resolve, 1100));

      expect(mockPeripheral.connect).toHaveBeenCalledTimes(2); // 初始连接 + 重连
    });

    test('应该检测蓝牙适配器状态', () => {
      expect(bluetoothHAL.getAdapterState()).toBe('poweredOn');

      // 模拟适配器状态变化
      mockNoble.state = 'poweredOff';
      const stateChangeHandler = mockNoble.on.mock.calls.find(
        call => call[0] === 'stateChange'
      )?.[1];

      stateChangeHandler?.('poweredOff');

      expect(bluetoothHAL.getAdapterState()).toBe('poweredOff');
    });
  });

  describe('性能和可靠性测试', () => {
    test('应该测试蓝牙数据传输性能', async () => {
      // 建立连接
      mockPeripheral.connect.mockImplementation((callback) => callback?.());
      mockPeripheral.discoverServices.mockImplementation((uuids, callback) => {
        const mockService = {
          discoverCharacteristics: vi.fn().mockImplementation((uuids, callback) => {
            callback(null, [mockCharacteristic]);
          })
        };
        callback(null, [mockService]);
      });

      await bluetoothHAL.connectToDevice(mockPeripheral);

      // 测试大量小包数据传输
      const packetSize = 20; // BLE典型MTU
      const packetCount = 1000;
      const startTime = performance.now();

      mockCharacteristic.write.mockImplementation((data, withoutResponse, callback) => {
        setTimeout(callback, 1); // 模拟1ms传输延迟
      });

      const promises = [];
      for (let i = 0; i < packetCount; i++) {
        const data = Buffer.alloc(packetSize, i % 256);
        promises.push(bluetoothHAL.write(data));
      }

      await Promise.all(promises);
      const duration = performance.now() - startTime;

      const totalBytes = packetSize * packetCount;
      const throughput = totalBytes / (duration / 1000);

      // BLE吞吐量通常较低，但应该稳定
      expect(throughput).toBeGreaterThan(1000); // >1KB/s
      expect(duration / packetCount).toBeLessThan(10); // 平均<10ms/包
    });
  });
});
```

## 4. 性能基准测试

```typescript
// tests/communication/performance.bench.ts
import { bench, describe } from 'vitest';
import { SerialHAL } from '@/communication/serial-hal';
import { NetworkHAL } from '@/communication/network-hal';

describe('通讯模块性能基准测试', () => {
  bench('串口数据写入性能', async () => {
    const serialHAL = new SerialHAL({
      path: '/dev/ttyUSB0',
      baudRate: 115200
    });

    const testData = Buffer.alloc(1024, 'X');
    await serialHAL.write(testData);
  });

  bench('网络数据写入性能', async () => {
    const networkHAL = new NetworkHAL({
      protocol: 'TCP',
      host: 'localhost',
      port: 8080
    });

    const testData = Buffer.alloc(1024, 'N');
    await networkHAL.write(testData);
  });

  bench('并发连接性能', async () => {
    const connections = Array(10).fill(null).map((_, i) => 
      new NetworkHAL({
        protocol: 'TCP',
        host: 'localhost',
        port: 8080 + i
      })
    );

    await Promise.all(connections.map(conn => conn.connect()));
  });
});
```

## 5. 集成测试

```typescript
// tests/communication/integration.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { CommunicationManager } from '@/communication/communication-manager';

describe('通讯模块集成测试', () => {
  let communicationManager: CommunicationManager;

  beforeAll(async () => {
    communicationManager = new CommunicationManager();
    await communicationManager.initialize();
  });

  afterAll(async () => {
    await communicationManager.shutdown();
  });

  test('应该支持多协议并发连接', async () => {
    const connections = await Promise.all([
      communicationManager.createConnection('serial', { path: '/dev/ttyUSB0' }),
      communicationManager.createConnection('tcp', { host: 'localhost', port: 8080 }),
      communicationManager.createConnection('udp', { host: 'localhost', port: 8081 })
    ]);

    expect(connections).toHaveLength(3);
    connections.forEach(conn => {
      expect(conn.isOpen()).toBe(true);
    });
  });

  test('应该正确处理连接错误和恢复', async () => {
    const connection = await communicationManager.createConnection('serial', {
      path: '/dev/nonexistent'
    });

    expect(connection.getStatus()).toBe('error');
    
    // 测试错误恢复
    await connection.setConfiguration({ path: '/dev/ttyUSB0' });
    await connection.reconnect();
    
    expect(connection.isOpen()).toBe(true);
  });
});
```

这个详细的通讯模块单元测试方案涵盖了HAL抽象层、多协议驱动实现、性能测试、集成测试等各个方面，确保通讯模块的高质量和可靠性。