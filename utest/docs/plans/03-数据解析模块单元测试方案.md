# 数据解析模块单元测试方案

## 1. 模块概述

数据解析模块是Serial-Studio VSCode插件的数据处理核心，负责将原始通讯数据转换为可视化数据结构。模块采用JavaScript虚拟机(VM2)提供安全的用户脚本执行环境，支持多种数据格式和帧检测机制，具有高性能和安全性要求。

### 1.1 模块架构

```
┌─────────────────────────────────────────────────────────────┐
│                    数据解析模块架构                          │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   帧提取器      │  │   数据解码器     │  │  JS解析引擎   │ │
│  │ - FrameReader   │  │ - DataDecoder    │  │ - VM2Engine  │ │
│  │ - 分隔符检测     │  │ - 格式转换       │  │ - 安全执行    │ │
│  │ - 缓冲区管理     │  │ - 编码处理       │  │ - 语法验证    │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  数据验证器     │  │  性能监控器      │  │  错误处理器   │ │
│  │ - Schema校验    │  │ - 解析性能       │  │ - 异常捕获    │ │
│  │ - 类型检查       │  │ - 内存使用       │  │ - 恢复机制    │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 测试目标

- **功能完整性**：验证所有数据格式和帧检测机制的正确性
- **安全性保证**：确保JavaScript执行环境的安全隔离
- **性能指标**：解析延迟≤10ms，吞吐量≥10000帧/秒
- **可靠性验证**：异常数据的正确处理和恢复
- **内存安全**：长期运行无内存泄漏

## 2. 测试覆盖率目标

| 测试类型 | 覆盖率目标 | 优先级 | 说明 |
|---------|-----------|--------|------|
| 行覆盖率 | ≥97% | P0 | 涉及安全执行，需高覆盖率 |
| 分支覆盖率 | ≥93% | P0 | 包含所有格式和错误分支 |
| 函数覆盖率 | ≥100% | P0 | 所有解析接口必须测试 |
| 语句覆盖率 | ≥97% | P0 | 确保解析逻辑完全验证 |

## 3. 详细测试用例设计

### 3.1 帧提取器测试

```typescript
// tests/parsing/frame-reader.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { FrameReader, FrameDetectionMode } from '@/parsing/frame-reader';
import { CircularBuffer } from '@/utils/circular-buffer';

describe('帧提取器测试', () => {
  let frameReader: FrameReader;
  let mockBuffer: CircularBuffer;

  beforeEach(() => {
    mockBuffer = new CircularBuffer(1024);
    frameReader = new FrameReader(mockBuffer);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('帧检测模式测试', () => {
    test('无分隔符模式应该按固定长度提取帧', () => {
      frameReader.setDetectionMode(FrameDetectionMode.NoDelimiters);
      frameReader.setFrameSize(10);

      const testData = Buffer.from('0123456789abcdefghij');
      mockBuffer.write(testData);

      const frames = frameReader.extractFrames();

      expect(frames).toHaveLength(2);
      expect(frames[0].toString()).toBe('0123456789');
      expect(frames[1].toString()).toBe('abcdefghij');
    });

    test('结束分隔符模式应该正确检测帧边界', () => {
      frameReader.setDetectionMode(FrameDetectionMode.EndDelimiter);
      frameReader.setEndDelimiter('\n');

      const testData = Buffer.from('frame1\nframe2\nframe3\n');
      mockBuffer.write(testData);

      const frames = frameReader.extractFrames();

      expect(frames).toHaveLength(3);
      expect(frames[0].toString()).toBe('frame1');
      expect(frames[1].toString()).toBe('frame2');
      expect(frames[2].toString()).toBe('frame3');
    });

    test('起始结束分隔符模式应该正确解析完整帧', () => {
      frameReader.setDetectionMode(FrameDetectionMode.StartEndDelimiter);
      frameReader.setStartDelimiter('<');
      frameReader.setEndDelimiter('>');

      const testData = Buffer.from('<frame1><frame2><incomplete');
      mockBuffer.write(testData);

      const frames = frameReader.extractFrames();

      expect(frames).toHaveLength(2);
      expect(frames[0].toString()).toBe('frame1');
      expect(frames[1].toString()).toBe('frame2');
      
      // 不完整的帧应该保留在缓冲区中
      expect(mockBuffer.toString()).toContain('<incomplete');
    });

    test('应该正确处理多字符分隔符', () => {
      frameReader.setDetectionMode(FrameDetectionMode.EndDelimiter);
      frameReader.setEndDelimiter('\r\n');

      const testData = Buffer.from('data1\r\ndata2\r\ndata3\r\n');
      mockBuffer.write(testData);

      const frames = frameReader.extractFrames();

      expect(frames).toHaveLength(3);
      expect(frames[0].toString()).toBe('data1');
      expect(frames[1].toString()).toBe('data2');
      expect(frames[2].toString()).toBe('data3');
    });
  });

  describe('数据缓冲和处理', () => {
    test('应该正确处理分片数据', () => {
      frameReader.setDetectionMode(FrameDetectionMode.EndDelimiter);
      frameReader.setEndDelimiter('\n');

      // 分片写入数据
      mockBuffer.write(Buffer.from('part1'));
      expect(frameReader.extractFrames()).toHaveLength(0);

      mockBuffer.write(Buffer.from('part2\n'));
      const frames = frameReader.extractFrames();

      expect(frames).toHaveLength(1);
      expect(frames[0].toString()).toBe('part1part2');
    });

    test('应该处理缓冲区溢出情况', () => {
      const smallBuffer = new CircularBuffer(10);
      frameReader = new FrameReader(smallBuffer);
      frameReader.setDetectionMode(FrameDetectionMode.EndDelimiter);
      frameReader.setEndDelimiter('\n');

      // 写入超过缓冲区大小的数据
      const largeData = Buffer.from('a'.repeat(20) + '\n');
      smallBuffer.write(largeData);

      const frames = frameReader.extractFrames();
      
      // 应该正确处理溢出，保留最新数据
      expect(frames).toHaveLength(1);
      expect(frames[0].length).toBeLessThanOrEqual(9); // 减去分隔符长度
    });

    test('应该统计帧处理性能指标', () => {
      frameReader.setDetectionMode(FrameDetectionMode.EndDelimiter);
      frameReader.setEndDelimiter('\n');

      const testData = Buffer.from('frame1\nframe2\nframe3\n');
      const startTime = performance.now();
      
      mockBuffer.write(testData);
      frameReader.extractFrames();
      
      const duration = performance.now() - startTime;
      const metrics = frameReader.getPerformanceMetrics();

      expect(metrics.totalFramesProcessed).toBe(3);
      expect(metrics.averageProcessingTime).toBeLessThan(10); // <10ms
      expect(duration).toBeLessThan(50); // 总时间<50ms
    });
  });

  describe('错误处理和恢复', () => {
    test('应该处理无效的帧配置', () => {
      expect(() => {
        frameReader.setFrameSize(-1);
      }).toThrow('Invalid frame size');

      expect(() => {
        frameReader.setEndDelimiter('');
      }).toThrow('Empty delimiter not allowed');
    });

    test('应该从帧解析错误中恢复', () => {
      frameReader.setDetectionMode(FrameDetectionMode.StartEndDelimiter);
      frameReader.setStartDelimiter('<');
      frameReader.setEndDelimiter('>');

      // 包含损坏数据的帧
      const testData = Buffer.from('<good><badframe<><another>');
      mockBuffer.write(testData);

      const frames = frameReader.extractFrames();

      // 应该跳过损坏的帧，继续处理后续正常帧
      expect(frames).toHaveLength(2);
      expect(frames[0].toString()).toBe('good');
      expect(frames[1].toString()).toBe('another');
    });

    test('应该限制单帧最大大小', () => {
      frameReader.setMaxFrameSize(100);
      frameReader.setDetectionMode(FrameDetectionMode.EndDelimiter);
      frameReader.setEndDelimiter('\n');

      const largeFrame = 'x'.repeat(200) + '\n';
      mockBuffer.write(Buffer.from(largeFrame));

      const frames = frameReader.extractFrames();

      // 超大帧应该被截断或丢弃
      expect(frames).toHaveLength(1);
      expect(frames[0].length).toBeLessThanOrEqual(100);
    });
  });
});
```

### 3.2 数据解码器测试

```typescript
// tests/parsing/data-decoder.test.ts
import { describe, test, expect, vi, beforeEach } from 'vitest';
import { DataDecoder, DataFormat } from '@/parsing/data-decoder';

describe('数据解码器测试', () => {
  let decoder: DataDecoder;

  beforeEach(() => {
    decoder = new DataDecoder();
  });

  describe('数据格式解码', () => {
    test('应该正确解码纯文本数据', () => {
      const input = Buffer.from('Hello World');
      const result = decoder.decode(input, DataFormat.PlainText);

      expect(result.format).toBe(DataFormat.PlainText);
      expect(result.text).toBe('Hello World');
      expect(result.bytes).toEqual(input);
    });

    test('应该正确解码十六进制数据', () => {
      const hexString = '48656C6C6F20576F726C64'; // "Hello World"
      const input = Buffer.from(hexString);
      const result = decoder.decode(input, DataFormat.Hexadecimal);

      expect(result.format).toBe(DataFormat.Hexadecimal);
      expect(result.text).toBe('Hello World');
      expect(result.hexString).toBe(hexString.toUpperCase());
    });

    test('应该正确解码Base64数据', () => {
      const base64String = 'SGVsbG8gV29ybGQ='; // "Hello World"
      const input = Buffer.from(base64String);
      const result = decoder.decode(input, DataFormat.Base64);

      expect(result.format).toBe(DataFormat.Base64);
      expect(result.text).toBe('Hello World');
      expect(result.base64String).toBe(base64String);
    });

    test('应该正确解码二进制数据', () => {
      const input = Buffer.from([0x01, 0x02, 0x03, 0xFF]);
      const result = decoder.decode(input, DataFormat.Binary);

      expect(result.format).toBe(DataFormat.Binary);
      expect(result.bytes).toEqual(input);
      expect(result.binaryString).toBe('00000001 00000010 00000011 11111111');
    });

    test('应该处理无效格式数据', () => {
      const invalidHex = Buffer.from('GGHHII'); // 无效十六进制
      
      expect(() => {
        decoder.decode(invalidHex, DataFormat.Hexadecimal);
      }).toThrow('Invalid hexadecimal data');

      const invalidBase64 = Buffer.from('Invalid@Base64!');
      
      expect(() => {
        decoder.decode(invalidBase64, DataFormat.Base64);
      }).toThrow('Invalid base64 data');
    });
  });

  describe('字符编码处理', () => {
    test('应该正确处理UTF-8编码', () => {
      const utf8Data = Buffer.from('测试中文', 'utf8');
      const result = decoder.decode(utf8Data, DataFormat.PlainText, 'utf8');

      expect(result.text).toBe('测试中文');
      expect(result.encoding).toBe('utf8');
    });

    test('应该正确处理ASCII编码', () => {
      const asciiData = Buffer.from('Test ASCII', 'ascii');
      const result = decoder.decode(asciiData, DataFormat.PlainText, 'ascii');

      expect(result.text).toBe('Test ASCII');
      expect(result.encoding).toBe('ascii');
    });

    test('应该正确处理Latin1编码', () => {
      const latin1Data = Buffer.from('Café', 'latin1');
      const result = decoder.decode(latin1Data, DataFormat.PlainText, 'latin1');

      expect(result.text).toBe('Café');
      expect(result.encoding).toBe('latin1');
    });

    test('应该自动检测和处理BOM标记', () => {
      const bomUtf8 = Buffer.concat([
        Buffer.from([0xEF, 0xBB, 0xBF]), // UTF-8 BOM
        Buffer.from('Test with BOM', 'utf8')
      ]);

      const result = decoder.decode(bomUtf8, DataFormat.PlainText);

      expect(result.text).toBe('Test with BOM');
      expect(result.hasBOM).toBe(true);
      expect(result.encoding).toBe('utf8');
    });
  });

  describe('数据转换和验证', () => {
    test('应该正确转换数值数据', () => {
      const numberData = Buffer.from('123.456');
      const result = decoder.decode(numberData, DataFormat.PlainText);

      expect(result.asNumber()).toBe(123.456);
      expect(result.asInteger()).toBe(123);
      expect(result.isNumeric()).toBe(true);
    });

    test('应该正确解析JSON数据', () => {
      const jsonData = { temperature: 25.6, humidity: 60.2 };
      const jsonBuffer = Buffer.from(JSON.stringify(jsonData));
      const result = decoder.decode(jsonBuffer, DataFormat.PlainText);

      expect(result.asJSON()).toEqual(jsonData);
      expect(result.isJSON()).toBe(true);
    });

    test('应该正确解析CSV数据', () => {
      const csvData = Buffer.from('temp,humidity,pressure\n25.6,60.2,1013.25');
      const result = decoder.decode(csvData, DataFormat.PlainText);

      const csvParsed = result.asCSV();
      expect(csvParsed.headers).toEqual(['temp', 'humidity', 'pressure']);
      expect(csvParsed.rows).toHaveLength(1);
      expect(csvParsed.rows[0]).toEqual(['25.6', '60.2', '1013.25']);
    });

    test('应该验证数据完整性', () => {
      const testData = Buffer.from('Test data for checksum');
      const result = decoder.decode(testData, DataFormat.PlainText);

      expect(result.checksum.crc32).toBeDefined();
      expect(result.checksum.md5).toBeDefined();
      expect(result.size).toBe(testData.length);
    });
  });

  describe('性能和优化', () => {
    test('应该高效处理大量数据', () => {
      const largeData = Buffer.alloc(1024 * 1024, 'x'); // 1MB数据
      const startTime = performance.now();

      const result = decoder.decode(largeData, DataFormat.PlainText);

      const duration = performance.now() - startTime;
      expect(duration).toBeLessThan(100); // <100ms
      expect(result.text).toHaveLength(1024 * 1024);
    });

    test('应该缓存重复解码结果', () => {
      const testData = Buffer.from('Repeated data');
      
      // 第一次解码
      const start1 = performance.now();
      const result1 = decoder.decode(testData, DataFormat.PlainText);
      const time1 = performance.now() - start1;

      // 第二次解码（应该使用缓存）
      const start2 = performance.now();
      const result2 = decoder.decode(testData, DataFormat.PlainText);
      const time2 = performance.now() - start2;

      expect(result1.text).toBe(result2.text);
      expect(time2).toBeLessThan(time1 * 0.5); // 缓存应该明显更快
    });

    test('应该批量处理多个数据帧', () => {
      const frames = Array(100).fill(null).map((_, i) => 
        Buffer.from(`Frame ${i}`)
      );

      const startTime = performance.now();
      const results = decoder.decodeBatch(frames, DataFormat.PlainText);
      const duration = performance.now() - startTime;

      expect(results).toHaveLength(100);
      expect(duration).toBeLessThan(50); // 批量处理应该高效
      results.forEach((result, i) => {
        expect(result.text).toBe(`Frame ${i}`);
      });
    });
  });
});
```

### 3.3 JavaScript解析引擎测试

```typescript
// tests/parsing/js-parser-engine.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { JSParserEngine } from '@/parsing/js-parser-engine';
import { VM } from 'vm2';

// Mock vm2
vi.mock('vm2', () => ({
  VM: vi.fn().mockImplementation(() => ({
    run: vi.fn(),
    freeze: vi.fn(),
    timeout: 5000,
    sandbox: {}
  }))
}));

describe('JavaScript解析引擎测试', () => {
  let jsEngine: JSParserEngine;
  let mockVM: any;

  beforeEach(() => {
    mockVM = {
      run: vi.fn(),
      freeze: vi.fn(),
      timeout: 5000,
      sandbox: {}
    };
    vi.mocked(VM).mockReturnValue(mockVM);
    
    jsEngine = new JSParserEngine({
      timeout: 5000,
      memoryLimit: 128 * 1024 * 1024, // 128MB
      allowAsync: false
    });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('脚本加载和验证', () => {
    test('应该正确加载有效的解析脚本', () => {
      const validScript = `
        function parse(frame) {
          return frame.split(',').map(Number);
        }
      `;

      expect(() => {
        jsEngine.loadScript(validScript);
      }).not.toThrow();

      const scriptInfo = jsEngine.getScriptInfo();
      expect(scriptInfo.isValid).toBe(true);
      expect(scriptInfo.hasParseFunction).toBe(true);
    });

    test('应该拒绝无效的JavaScript语法', () => {
      const invalidScript = `
        function parse(frame {  // 语法错误：缺少右括号
          return frame.split(',');
        }
      `;

      expect(() => {
        jsEngine.loadScript(invalidScript);
      }).toThrow('Invalid JavaScript syntax');
    });

    test('应该验证必需的parse函数', () => {
      const scriptWithoutParse = `
        function helper() {
          return 'helper';
        }
      `;

      expect(() => {
        jsEngine.loadScript(scriptWithoutParse);
      }).toThrow('Parse function not found');
    });

    test('应该检测危险的代码模式', () => {
      const dangerousScript = `
        function parse(frame) {
          require('fs').readFileSync('/etc/passwd'); // 危险操作
          return [];
        }
      `;

      expect(() => {
        jsEngine.loadScript(dangerousScript);
      }).toThrow('Dangerous code detected');
    });

    test('应该限制脚本复杂度', () => {
      const complexScript = `
        function parse(frame) {
          ${'let x = 0; '.repeat(10000)} // 过度复杂
          return [x];
        }
      `;

      expect(() => {
        jsEngine.loadScript(complexScript);
      }).toThrow('Script too complex');
    });
  });

  describe('数据解析执行', () => {
    beforeEach(() => {
      const testScript = `
        function parse(frame) {
          const parts = frame.split(',');
          return parts.map((part, index) => ({
            index: index,
            value: parseFloat(part),
            timestamp: Date.now()
          }));
        }
      `;
      jsEngine.loadScript(testScript);
    });

    test('应该正确执行数据解析', () => {
      const frameData = '1.23,4.56,7.89';
      const expectedResult = [
        { index: 0, value: 1.23, timestamp: expect.any(Number) },
        { index: 1, value: 4.56, timestamp: expect.any(Number) },
        { index: 2, value: 7.89, timestamp: expect.any(Number) }
      ];

      mockVM.run.mockReturnValue(expectedResult);

      const result = jsEngine.parseFrame(frameData);

      expect(mockVM.run).toHaveBeenCalledWith(
        expect.stringContaining('parse("1.23,4.56,7.89")')
      );
      expect(result).toEqual(expectedResult);
    });

    test('应该处理解析异常', () => {
      mockVM.run.mockImplementation(() => {
        throw new Error('Division by zero');
      });

      expect(() => {
        jsEngine.parseFrame('invalid,data');
      }).toThrow('Parse execution failed: Division by zero');
    });

    test('应该强制执行超时限制', () => {
      mockVM.run.mockImplementation(() => {
        // 模拟无限循环
        while (true) {
          // 死循环
        }
      });

      expect(() => {
        jsEngine.parseFrame('test');
      }).toThrow('Script execution timeout');
    });

    test('应该支持批量数据解析', () => {
      const frames = ['1,2,3', '4,5,6', '7,8,9'];
      
      mockVM.run.mockImplementation((code) => {
        const frameMatch = code.match(/parse\("([^"]+)"\)/);
        if (frameMatch) {
          const frame = frameMatch[1];
          return frame.split(',').map(Number);
        }
        return [];
      });

      const results = jsEngine.parseFrames(frames);

      expect(results).toHaveLength(3);
      expect(results[0]).toEqual([1, 2, 3]);
      expect(results[1]).toEqual([4, 5, 6]);
      expect(results[2]).toEqual([7, 8, 9]);
    });
  });

  describe('安全性和隔离', () => {
    test('应该阻止文件系统访问', () => {
      const maliciousScript = `
        function parse(frame) {
          const fs = require('fs');
          return fs.readdirSync('/');
        }
      `;

      mockVM.run.mockImplementation(() => {
        throw new Error('Access denied');
      });

      jsEngine.loadScript(maliciousScript);
      
      expect(() => {
        jsEngine.parseFrame('test');
      }).toThrow('Access denied');
    });

    test('应该阻止网络访问', () => {
      const networkScript = `
        function parse(frame) {
          const http = require('http');
          http.get('http://evil.com');
          return [];
        }
      `;

      mockVM.run.mockImplementation(() => {
        throw new Error('Network access denied');
      });

      jsEngine.loadScript(networkScript);
      
      expect(() => {
        jsEngine.parseFrame('test');
      }).toThrow('Network access denied');
    });

    test('应该限制内存使用', () => {
      const memoryHogScript = `
        function parse(frame) {
          const bigArray = new Array(10000000).fill('x');
          return bigArray;
        }
      `;

      mockVM.run.mockImplementation(() => {
        throw new Error('Memory limit exceeded');
      });

      jsEngine.loadScript(memoryHogScript);
      
      expect(() => {
        jsEngine.parseFrame('test');
      }).toThrow('Memory limit exceeded');
    });

    test('应该隔离全局变量', () => {
      const script1 = `
        let globalVar = 'script1';
        function parse(frame) {
          return [globalVar];
        }
      `;

      const script2 = `
        let globalVar = 'script2';
        function parse(frame) {
          return [globalVar];
        }
      `;

      const engine1 = new JSParserEngine();
      const engine2 = new JSParserEngine();

      mockVM.run.mockReturnValueOnce(['script1']);
      engine1.loadScript(script1);
      const result1 = engine1.parseFrame('test');

      mockVM.run.mockReturnValueOnce(['script2']);
      engine2.loadScript(script2);
      const result2 = engine2.parseFrame('test');

      expect(result1).toEqual(['script1']);
      expect(result2).toEqual(['script2']);
    });
  });

  describe('性能监控和优化', () => {
    test('应该监控解析性能', () => {
      const performantScript = `
        function parse(frame) {
          return frame.split(',').map(Number);
        }
      `;

      jsEngine.loadScript(performantScript);
      mockVM.run.mockReturnValue([1, 2, 3]);

      const startTime = performance.now();
      jsEngine.parseFrame('1,2,3');
      const duration = performance.now() - startTime;

      const metrics = jsEngine.getPerformanceMetrics();
      expect(metrics.averageExecutionTime).toBeLessThan(10); // <10ms
      expect(metrics.totalExecutions).toBe(1);
      expect(duration).toBeLessThan(50);
    });

    test('应该缓存编译后的脚本', () => {
      const script = `
        function parse(frame) {
          return frame.split(',');
        }
      `;

      // 首次加载
      const start1 = performance.now();
      jsEngine.loadScript(script);
      const loadTime1 = performance.now() - start1;

      // 重新加载相同脚本（应该使用缓存）
      const start2 = performance.now();
      jsEngine.loadScript(script);
      const loadTime2 = performance.now() - start2;

      expect(loadTime2).toBeLessThan(loadTime1 * 0.5);
    });

    test('应该优化高频解析调用', () => {
      const script = `
        function parse(frame) {
          return [parseFloat(frame)];
        }
      `;

      jsEngine.loadScript(script);
      mockVM.run.mockImplementation(() => [Math.random()]);

      // 执行大量解析调用
      const iterations = 1000;
      const startTime = performance.now();

      for (let i = 0; i < iterations; i++) {
        jsEngine.parseFrame(i.toString());
      }

      const duration = performance.now() - startTime;
      const averageTime = duration / iterations;

      expect(averageTime).toBeLessThan(1); // 平均<1ms per parse
    });
  });

  describe('错误处理和恢复', () => {
    test('应该从解析错误中恢复', () => {
      const faultyScript = `
        let errorCount = 0;
        function parse(frame) {
          errorCount++;
          if (errorCount % 3 === 0) {
            throw new Error('Intermittent error');
          }
          return [errorCount];
        }
      `;

      jsEngine.loadScript(faultyScript);
      
      // 模拟间歇性错误
      mockVM.run.mockImplementation(() => {
        if (Math.random() < 0.3) {
          throw new Error('Intermittent error');
        }
        return [1];
      });

      let successCount = 0;
      let errorCount = 0;

      for (let i = 0; i < 10; i++) {
        try {
          jsEngine.parseFrame(`frame${i}`);
          successCount++;
        } catch (error) {
          errorCount++;
        }
      }

      expect(successCount).toBeGreaterThan(0);
      expect(errorCount).toBeGreaterThan(0);
      expect(successCount + errorCount).toBe(10);
    });

    test('应该限制连续错误次数', () => {
      const alwaysFailScript = `
        function parse(frame) {
          throw new Error('Always fails');
        }
      `;

      jsEngine.loadScript(alwaysFailScript);
      jsEngine.setMaxConsecutiveErrors(3);

      mockVM.run.mockImplementation(() => {
        throw new Error('Always fails');
      });

      let errorCount = 0;
      try {
        for (let i = 0; i < 5; i++) {
          jsEngine.parseFrame(`frame${i}`);
        }
      } catch (error) {
        errorCount++;
      }

      // 应该在达到最大错误次数后停止执行
      expect(jsEngine.isDisabled()).toBe(true);
    });
  });
});
```

### 3.4 综合集成测试

```typescript
// tests/parsing/integration.test.ts
import { describe, test, expect, beforeAll, afterAll } from 'vitest';
import { DataParsingPipeline } from '@/parsing/data-parsing-pipeline';
import { MockDataSource } from '../mocks/mock-data-source';

describe('数据解析模块集成测试', () => {
  let pipeline: DataParsingPipeline;
  let mockDataSource: MockDataSource;

  beforeAll(async () => {
    pipeline = new DataParsingPipeline();
    mockDataSource = new MockDataSource();
    
    await pipeline.initialize();
  });

  afterAll(async () => {
    await pipeline.shutdown();
  });

  test('应该端到端处理实际数据流', async () => {
    // 配置解析管道
    await pipeline.configure({
      frameDetection: {
        mode: 'end-delimiter',
        endDelimiter: '\n'
      },
      dataFormat: 'plaintext',
      encoding: 'utf8',
      parseScript: `
        function parse(frame) {
          const values = frame.split(',').map(Number);
          return {
            timestamp: Date.now(),
            temperature: values[0],
            humidity: values[1],
            pressure: values[2]
          };
        }
      `
    });

    // 模拟数据流
    const testData = [
      '25.6,60.2,1013.25\n',
      '26.1,59.8,1012.80\n',
      '25.9,60.5,1013.10\n'
    ];

    const results: any[] = [];
    pipeline.on('dataProcessed', (data) => {
      results.push(data);
    });

    // 发送数据
    for (const data of testData) {
      mockDataSource.emitData(Buffer.from(data));
    }

    // 等待处理完成
    await new Promise(resolve => setTimeout(resolve, 100));

    expect(results).toHaveLength(3);
    expect(results[0]).toMatchObject({
      temperature: 25.6,
      humidity: 60.2,
      pressure: 1013.25
    });
  });

  test('应该处理高频数据流', async () => {
    await pipeline.configure({
      frameDetection: { mode: 'fixed-length', frameSize: 4 },
      dataFormat: 'binary'
    });

    const dataCount = 10000;
    const processedData: any[] = [];

    pipeline.on('dataProcessed', (data) => {
      processedData.push(data);
    });

    const startTime = performance.now();

    // 发送高频数据
    for (let i = 0; i < dataCount; i++) {
      const data = Buffer.from([i & 0xFF, (i >> 8) & 0xFF, 0x00, 0x00]);
      mockDataSource.emitData(data);
    }

    // 等待处理完成
    await new Promise(resolve => setTimeout(resolve, 500));

    const duration = performance.now() - startTime;
    const throughput = processedData.length / (duration / 1000);

    expect(processedData).toHaveLength(dataCount);
    expect(throughput).toBeGreaterThan(10000); // >10000 frames/second
  });

  test('应该正确处理数据格式转换', async () => {
    const formats = ['plaintext', 'hex', 'base64', 'binary'];
    const testMessage = 'Hello World';

    for (const format of formats) {
      await pipeline.configure({
        frameDetection: { mode: 'end-delimiter', endDelimiter: '\n' },
        dataFormat: format
      });

      let processedData: any;
      pipeline.once('dataProcessed', (data) => {
        processedData = data;
      });

      // 根据格式编码测试数据
      let encodedData: Buffer;
      switch (format) {
        case 'plaintext':
          encodedData = Buffer.from(testMessage + '\n');
          break;
        case 'hex':
          encodedData = Buffer.from(Buffer.from(testMessage).toString('hex') + '\n');
          break;
        case 'base64':
          encodedData = Buffer.from(Buffer.from(testMessage).toString('base64') + '\n');
          break;
        case 'binary':
          encodedData = Buffer.concat([Buffer.from(testMessage), Buffer.from('\n')]);
          break;
      }

      mockDataSource.emitData(encodedData);
      await new Promise(resolve => setTimeout(resolve, 50));

      expect(processedData.originalText).toBe(testMessage);
      expect(processedData.format).toBe(format);
    }
  });
});
```

## 4. 性能基准测试

```typescript
// tests/parsing/performance.bench.ts
import { bench, describe } from 'vitest';
import { FrameReader } from '@/parsing/frame-reader';
import { DataDecoder } from '@/parsing/data-decoder';
import { JSParserEngine } from '@/parsing/js-parser-engine';

describe('数据解析模块性能基准测试', () => {
  bench('帧提取性能', () => {
    const frameReader = new FrameReader();
    const testData = Buffer.from('frame1\nframe2\nframe3\n'.repeat(100));
    
    frameReader.processData(testData);
    frameReader.extractFrames();
  });

  bench('数据解码性能', () => {
    const decoder = new DataDecoder();
    const testData = Buffer.from('Test data for decoding');
    
    decoder.decode(testData, 'plaintext');
  });

  bench('JavaScript解析性能', () => {
    const jsEngine = new JSParserEngine();
    jsEngine.loadScript('function parse(frame) { return frame.split(","); }');
    
    jsEngine.parseFrame('1,2,3,4,5');
  });

  bench('批量数据处理性能', () => {
    const decoder = new DataDecoder();
    const frames = Array(1000).fill(Buffer.from('test,data,frame'));
    
    decoder.decodeBatch(frames, 'plaintext');
  });
});
```

这个详细的数据解析模块单元测试方案涵盖了帧提取、数据解码、JavaScript解析引擎等各个核心组件，确保数据解析的准确性、安全性和性能表现。