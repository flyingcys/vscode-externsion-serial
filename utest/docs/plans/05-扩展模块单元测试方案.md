# 扩展模块单元测试方案

## 1. 模块概述

扩展模块是Serial-Studio VSCode插件的架构核心，实现插件系统、主题管理、国际化(i18n)、许可证管理和配置系统等高级功能。模块采用插件化架构设计，支持动态加载、生命周期管理和扩展点系统，具有高度可扩展性和模块化要求。

### 1.1 模块架构

```
┌─────────────────────────────────────────────────────────────┐
│                    扩展模块架构                              │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   插件管理器     │  │   主题系统       │  │  国际化引擎   │ │
│  │ - PluginManager │  │ - ThemeManager   │  │ - I18nEngine │ │
│  │ - 生命周期管理   │  │ - CSS变量管理    │  │ - 多语言支持  │ │
│  │ - 依赖解析       │  │ - 动态切换       │  │ - RTL布局     │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  许可证管理      │  │  配置系统        │  │  扩展点框架   │ │
│  │ - LicenseManager│  │ - ConfigManager  │  │ - Extension  │ │
│  │ - 特性门控       │  │ - VSCode集成     │  │ - 贡献点     │ │
│  │ - 版本验证       │  │ - 设置同步       │  │ - 15个扩展点  │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 测试目标

- **插件系统**：验证插件加载、卸载、依赖管理和生命周期
- **主题系统**：确保主题切换、CSS变量管理和用户体验
- **国际化**：多语言支持、RTL布局和本地化功能
- **许可证管理**：特性门控、版本验证和授权检查
- **配置系统**：设置管理、VSCode集成和数据同步

## 2. 测试覆盖率目标

| 测试类型 | 覆盖率目标 | 优先级 | 说明 |
|---------|-----------|--------|------|
| 行覆盖率 | ≥90% | P1 | 扩展功能，重要但非核心 |
| 分支覆盖率 | ≥80% | P1 | 包含所有特性门控分支 |
| 函数覆盖率 | ≥95% | P1 | 所有扩展接口必须测试 |
| 语句覆盖率 | ≥90% | P1 | 确保扩展逻辑完全验证 |

## 3. 详细测试用例设计

### 3.1 插件管理器测试

```typescript
// tests/extensions/plugin-manager.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { PluginManager } from '@/extensions/plugin-manager';
import { ExtensionPoint, PluginManifest, PluginStatus } from '@/types/extensions';

describe('插件管理器测试', () => {
  let pluginManager: PluginManager;
  let mockPlugin: any;
  let mockManifest: PluginManifest;

  beforeEach(() => {
    pluginManager = new PluginManager();
    
    mockManifest = {
      id: 'test-plugin',
      name: 'Test Plugin',
      version: '1.0.0',
      description: 'A test plugin',
      author: 'Test Author',
      main: 'index.js',
      extensionPoints: [ExtensionPoint.VISUALIZATION_WIDGETS],
      dependencies: [],
      permissions: ['data.read'],
      engines: {
        vscode: '^1.60.0',
        serialStudio: '^1.0.0'
      }
    };

    mockPlugin = {
      manifest: mockManifest,
      activate: vi.fn().mockResolvedValue(undefined),
      deactivate: vi.fn().mockResolvedValue(undefined),
      contributes: {
        widgets: [
          {
            id: 'custom-chart',
            name: 'Custom Chart',
            component: 'CustomChartWidget'
          }
        ]
      }
    };
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('插件注册和发现', () => {
    test('应该正确注册插件', async () => {
      const registered = await pluginManager.registerPlugin(mockPlugin);

      expect(registered).toBe(true);
      expect(pluginManager.getPlugin('test-plugin')).toBeDefined();
      expect(pluginManager.getPluginStatus('test-plugin')).toBe(PluginStatus.Registered);
    });

    test('应该验证插件清单', async () => {
      const invalidManifest = { ...mockManifest };
      delete invalidManifest.id;

      const invalidPlugin = { ...mockPlugin, manifest: invalidManifest };

      await expect(pluginManager.registerPlugin(invalidPlugin))
        .rejects.toThrow('Invalid plugin manifest');
    });

    test('应该检查版本兼容性', async () => {
      const incompatibleManifest = {
        ...mockManifest,
        engines: {
          vscode: '^2.0.0',
          serialStudio: '^2.0.0'
        }
      };

      const incompatiblePlugin = { ...mockPlugin, manifest: incompatibleManifest };

      await expect(pluginManager.registerPlugin(incompatiblePlugin))
        .rejects.toThrow('Incompatible version');
    });

    test('应该防止重复注册', async () => {
      await pluginManager.registerPlugin(mockPlugin);

      await expect(pluginManager.registerPlugin(mockPlugin))
        .rejects.toThrow('Plugin already registered');
    });

    test('应该扫描插件目录', async () => {
      const mockFS = {
        readdirSync: vi.fn().mockReturnValue(['plugin1', 'plugin2']),
        existsSync: vi.fn().mockReturnValue(true),
        readFileSync: vi.fn().mockReturnValue(JSON.stringify(mockManifest))
      };

      vi.doMock('fs', () => mockFS);

      const discoveredPlugins = await pluginManager.discoverPlugins('/plugins');

      expect(discoveredPlugins).toHaveLength(2);
      expect(mockFS.readdirSync).toHaveBeenCalledWith('/plugins');
    });
  });

  describe('插件生命周期管理', () => {
    beforeEach(async () => {
      await pluginManager.registerPlugin(mockPlugin);
    });

    test('应该正确激活插件', async () => {
      const activated = await pluginManager.activatePlugin('test-plugin');

      expect(activated).toBe(true);
      expect(mockPlugin.activate).toHaveBeenCalled();
      expect(pluginManager.getPluginStatus('test-plugin')).toBe(PluginStatus.Active);
    });

    test('应该正确停用插件', async () => {
      await pluginManager.activatePlugin('test-plugin');
      const deactivated = await pluginManager.deactivatePlugin('test-plugin');

      expect(deactivated).toBe(true);
      expect(mockPlugin.deactivate).toHaveBeenCalled();
      expect(pluginManager.getPluginStatus('test-plugin')).toBe(PluginStatus.Inactive);
    });

    test('应该处理激活失败', async () => {
      mockPlugin.activate.mockRejectedValue(new Error('Activation failed'));

      await expect(pluginManager.activatePlugin('test-plugin'))
        .rejects.toThrow('Activation failed');

      expect(pluginManager.getPluginStatus('test-plugin')).toBe(PluginStatus.Error);
    });

    test('应该支持插件热重载', async () => {
      await pluginManager.activatePlugin('test-plugin');

      const reloaded = await pluginManager.reloadPlugin('test-plugin');

      expect(reloaded).toBe(true);
      expect(mockPlugin.deactivate).toHaveBeenCalled();
      expect(mockPlugin.activate).toHaveBeenCalledTimes(2);
    });

    test('应该按依赖顺序激活插件', async () => {
      const dependentManifest = {
        ...mockManifest,
        id: 'dependent-plugin',
        dependencies: ['test-plugin']
      };

      const dependentPlugin = {
        ...mockPlugin,
        manifest: dependentManifest,
        activate: vi.fn().mockResolvedValue(undefined)
      };

      await pluginManager.registerPlugin(dependentPlugin);

      const activationOrder: string[] = [];
      
      mockPlugin.activate.mockImplementation(() => {
        activationOrder.push('test-plugin');
        return Promise.resolve();
      });

      dependentPlugin.activate.mockImplementation(() => {
        activationOrder.push('dependent-plugin');
        return Promise.resolve();
      });

      await pluginManager.activateAllPlugins();

      expect(activationOrder).toEqual(['test-plugin', 'dependent-plugin']);
    });
  });

  describe('扩展点管理', () => {
    test('应该注册扩展点贡献', async () => {
      await pluginManager.registerPlugin(mockPlugin);
      await pluginManager.activatePlugin('test-plugin');

      const contributions = pluginManager.getContributions(ExtensionPoint.VISUALIZATION_WIDGETS);

      expect(contributions).toHaveLength(1);
      expect(contributions[0]).toMatchObject({
        pluginId: 'test-plugin',
        contribution: mockPlugin.contributes.widgets[0]
      });
    });

    test('应该支持动态扩展点注册', () => {
      const customExtensionPoint = 'custom.dataProcessors';

      pluginManager.registerExtensionPoint(customExtensionPoint, {
        validator: (contribution: any) => typeof contribution.process === 'function'
      });

      expect(pluginManager.hasExtensionPoint(customExtensionPoint)).toBe(true);
    });

    test('应该验证扩展点贡献', async () => {
      const invalidContribution = {
        ...mockPlugin,
        contributes: {
          widgets: [
            {
              // 缺少必需的字段
              name: 'Invalid Widget'
            }
          ]
        }
      };

      await pluginManager.registerPlugin(invalidContribution);

      await expect(pluginManager.activatePlugin('test-plugin'))
        .rejects.toThrow('Invalid contribution');
    });

    test('应该支持扩展点监听器', () => {
      const listener = vi.fn();

      pluginManager.onExtensionPointChanged(ExtensionPoint.VISUALIZATION_WIDGETS, listener);

      pluginManager.registerPlugin(mockPlugin);

      expect(listener).toHaveBeenCalledWith({
        extensionPoint: ExtensionPoint.VISUALIZATION_WIDGETS,
        action: 'added',
        contribution: expect.any(Object)
      });
    });
  });

  describe('插件权限管理', () => {
    test('应该检查插件权限', () => {
      const hasPermission = pluginManager.checkPermission('test-plugin', 'data.read');
      expect(hasPermission).toBe(true);

      const noPermission = pluginManager.checkPermission('test-plugin', 'system.write');
      expect(noPermission).toBe(false);
    });

    test('应该支持运行时权限请求', async () => {
      await pluginManager.registerPlugin(mockPlugin);

      const granted = await pluginManager.requestPermission('test-plugin', 'network.access');

      expect(granted).toBe(true);
      expect(pluginManager.checkPermission('test-plugin', 'network.access')).toBe(true);
    });

    test('应该隔离插件上下文', async () => {
      const plugin1 = { ...mockPlugin, manifest: { ...mockManifest, id: 'plugin1' } };
      const plugin2 = { ...mockPlugin, manifest: { ...mockManifest, id: 'plugin2' } };

      await pluginManager.registerPlugin(plugin1);
      await pluginManager.registerPlugin(plugin2);

      const context1 = pluginManager.getPluginContext('plugin1');
      const context2 = pluginManager.getPluginContext('plugin2');

      expect(context1).not.toBe(context2);
      expect(context1.pluginId).toBe('plugin1');
      expect(context2.pluginId).toBe('plugin2');
    });
  });

  describe('插件通信', () => {
    test('应该支持插件间消息传递', async () => {
      const senderPlugin = { ...mockPlugin, manifest: { ...mockManifest, id: 'sender' } };
      const receiverPlugin = { ...mockPlugin, manifest: { ...mockManifest, id: 'receiver' } };

      const messageHandler = vi.fn();
      receiverPlugin.onMessage = messageHandler;

      await pluginManager.registerPlugin(senderPlugin);
      await pluginManager.registerPlugin(receiverPlugin);

      await pluginManager.sendMessage('sender', 'receiver', {
        type: 'data-update',
        payload: { value: 42 }
      });

      expect(messageHandler).toHaveBeenCalledWith({
        from: 'sender',
        type: 'data-update',
        payload: { value: 42 }
      });
    });

    test('应该支持广播消息', async () => {
      const plugin1 = { ...mockPlugin, manifest: { ...mockManifest, id: 'plugin1' } };
      const plugin2 = { ...mockPlugin, manifest: { ...mockManifest, id: 'plugin2' } };

      plugin1.onMessage = vi.fn();
      plugin2.onMessage = vi.fn();

      await pluginManager.registerPlugin(plugin1);
      await pluginManager.registerPlugin(plugin2);

      await pluginManager.broadcastMessage({
        type: 'global-event',
        payload: { event: 'theme-changed' }
      });

      expect(plugin1.onMessage).toHaveBeenCalled();
      expect(plugin2.onMessage).toHaveBeenCalled();
    });

    test('应该支持事件系统', () => {
      const eventHandler = vi.fn();

      pluginManager.on('plugin.activated', eventHandler);
      pluginManager.activatePlugin('test-plugin');

      expect(eventHandler).toHaveBeenCalledWith({
        type: 'plugin.activated',
        pluginId: 'test-plugin',
        timestamp: expect.any(Number)
      });
    });
  });

  describe('错误处理和恢复', () => {
    test('应该隔离插件错误', async () => {
      const faultyPlugin = {
        ...mockPlugin,
        manifest: { ...mockManifest, id: 'faulty' },
        activate: vi.fn().mockRejectedValue(new Error('Plugin crashed'))
      };

      await pluginManager.registerPlugin(mockPlugin);
      await pluginManager.registerPlugin(faultyPlugin);

      // 错误的插件不应影响其他插件
      await expect(pluginManager.activatePlugin('faulty')).rejects.toThrow();
      
      const success = await pluginManager.activatePlugin('test-plugin');
      expect(success).toBe(true);
    });

    test('应该支持插件崩溃恢复', async () => {
      await pluginManager.registerPlugin(mockPlugin);
      await pluginManager.activatePlugin('test-plugin');

      // 模拟插件崩溃
      pluginManager.handlePluginCrash('test-plugin', new Error('Unexpected crash'));

      expect(pluginManager.getPluginStatus('test-plugin')).toBe(PluginStatus.Crashed);

      // 尝试自动恢复
      const recovered = await pluginManager.recoverPlugin('test-plugin');
      expect(recovered).toBe(true);
      expect(pluginManager.getPluginStatus('test-plugin')).toBe(PluginStatus.Active);
    });

    test('应该记录插件错误日志', async () => {
      const logSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      await pluginManager.registerPlugin(mockPlugin);
      mockPlugin.activate.mockRejectedValue(new Error('Test error'));

      await expect(pluginManager.activatePlugin('test-plugin')).rejects.toThrow();

      expect(logSpy).toHaveBeenCalledWith(
        expect.stringContaining('Plugin activation failed'),
        expect.objectContaining({ pluginId: 'test-plugin' })
      );

      logSpy.mockRestore();
    });
  });
});
```

### 3.2 主题系统测试

```typescript
// tests/extensions/theme-manager.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { ThemeManager } from '@/extensions/theme-manager';
import { Theme, ThemeType } from '@/types/theme';

describe('主题系统测试', () => {
  let themeManager: ThemeManager;
  let mockTheme: Theme;

  beforeEach(() => {
    themeManager = new ThemeManager();
    
    mockTheme = {
      id: 'dark-theme',
      name: 'Dark Theme',
      type: ThemeType.Dark,
      version: '1.0.0',
      author: 'Theme Author',
      variables: {
        '--primary-color': '#007acc',
        '--background-color': '#1e1e1e',
        '--text-color': '#ffffff',
        '--border-color': '#3c3c3c'
      },
      components: {
        'base-widget': {
          backgroundColor: 'var(--background-color)',
          color: 'var(--text-color)',
          border: '1px solid var(--border-color)'
        },
        'plot-widget': {
          chartBackground: 'var(--background-color)',
          gridColor: 'var(--border-color)'
        }
      }
    };

    // Mock DOM 操作
    Object.defineProperty(window, 'getComputedStyle', {
      value: vi.fn().mockReturnValue({
        getPropertyValue: vi.fn().mockReturnValue('')
      })
    });

    global.document = {
      ...global.document,
      documentElement: {
        style: {
          setProperty: vi.fn(),
          removeProperty: vi.fn()
        }
      },
      querySelector: vi.fn().mockReturnValue({
        setAttribute: vi.fn(),
        removeAttribute: vi.fn()
      })
    } as any;
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('主题注册和管理', () => {
    test('应该正确注册主题', () => {
      const registered = themeManager.registerTheme(mockTheme);

      expect(registered).toBe(true);
      expect(themeManager.getTheme('dark-theme')).toEqual(mockTheme);
      expect(themeManager.getAvailableThemes()).toContain('dark-theme');
    });

    test('应该验证主题数据', () => {
      const invalidTheme = { ...mockTheme };
      delete invalidTheme.id;

      expect(() => {
        themeManager.registerTheme(invalidTheme as Theme);
      }).toThrow('Invalid theme data');
    });

    test('应该防止重复注册', () => {
      themeManager.registerTheme(mockTheme);

      expect(() => {
        themeManager.registerTheme(mockTheme);
      }).toThrow('Theme already registered');
    });

    test('应该支持主题继承', () => {
      const baseTheme = { ...mockTheme, id: 'base-theme' };
      const extendedTheme: Theme = {
        ...mockTheme,
        id: 'extended-theme',
        extends: 'base-theme',
        variables: {
          '--primary-color': '#ff6600', // 覆盖基础主题
          '--secondary-color': '#00ff66' // 新增变量
        }
      };

      themeManager.registerTheme(baseTheme);
      themeManager.registerTheme(extendedTheme);

      const resolvedTheme = themeManager.resolveTheme('extended-theme');

      expect(resolvedTheme.variables['--primary-color']).toBe('#ff6600');
      expect(resolvedTheme.variables['--background-color']).toBe('#1e1e1e'); // 继承
      expect(resolvedTheme.variables['--secondary-color']).toBe('#00ff66'); // 新增
    });

    test('应该加载外部主题文件', async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(mockTheme)
      });

      global.fetch = mockFetch;

      const loaded = await themeManager.loadThemeFromURL('/themes/dark-theme.json');

      expect(loaded).toBe(true);
      expect(mockFetch).toHaveBeenCalledWith('/themes/dark-theme.json');
      expect(themeManager.getTheme('dark-theme')).toEqual(mockTheme);
    });
  });

  describe('主题应用和切换', () => {
    beforeEach(() => {
      themeManager.registerTheme(mockTheme);
    });

    test('应该正确应用主题', () => {
      const applied = themeManager.applyTheme('dark-theme');

      expect(applied).toBe(true);
      expect(themeManager.getCurrentTheme()).toBe('dark-theme');

      // 验证CSS变量设置
      const setPropertySpy = document.documentElement.style.setProperty as any;
      expect(setPropertySpy).toHaveBeenCalledWith('--primary-color', '#007acc');
      expect(setPropertySpy).toHaveBeenCalledWith('--background-color', '#1e1e1e');
      expect(setPropertySpy).toHaveBeenCalledWith('--text-color', '#ffffff');
    });

    test('应该正确移除旧主题', () => {
      const lightTheme: Theme = {
        ...mockTheme,
        id: 'light-theme',
        type: ThemeType.Light,
        variables: {
          '--primary-color': '#0078d4',
          '--background-color': '#ffffff',
          '--text-color': '#000000'
        }
      };

      themeManager.registerTheme(lightTheme);

      // 先应用深色主题
      themeManager.applyTheme('dark-theme');
      
      // 再切换到浅色主题
      themeManager.applyTheme('light-theme');

      const setPropertySpy = document.documentElement.style.setProperty as any;
      expect(setPropertySpy).toHaveBeenCalledWith('--background-color', '#ffffff');
      expect(setPropertySpy).toHaveBeenCalledWith('--text-color', '#000000');
    });

    test('应该支持平滑主题过渡', async () => {
      vi.useFakeTimers();

      const transitionPromise = themeManager.applyThemeWithTransition('dark-theme', {
        duration: 300,
        easing: 'ease-in-out'
      });

      // 验证过渡开始
      expect(document.documentElement.style.setProperty).toHaveBeenCalledWith(
        'transition',
        'all 300ms ease-in-out'
      );

      vi.advanceTimersByTime(300);

      await transitionPromise;

      // 验证过渡完成后清理
      expect(document.documentElement.style.removeProperty).toHaveBeenCalledWith('transition');

      vi.useRealTimers();
    });

    test('应该自动检测系统主题', () => {
      const mockMatchMedia = vi.fn().mockReturnValue({
        matches: true,
        addEventListener: vi.fn(),
        removeEventListener: vi.fn()
      });

      global.window.matchMedia = mockMatchMedia;

      themeManager.enableAutoTheme();

      expect(mockMatchMedia).toHaveBeenCalledWith('(prefers-color-scheme: dark)');
    });

    test('应该响应系统主题变化', () => {
      const mockMatchMedia = vi.fn().mockReturnValue({
        matches: false,
        addEventListener: vi.fn(),
        removeEventListener: vi.fn()
      });

      global.window.matchMedia = mockMatchMedia;

      const lightTheme: Theme = {
        ...mockTheme,
        id: 'light-theme',
        type: ThemeType.Light
      };

      themeManager.registerTheme(lightTheme);
      themeManager.enableAutoTheme();

      // 模拟系统主题变化
      const changeHandler = mockMatchMedia.mock.results[0].value.addEventListener.mock.calls[0][1];
      changeHandler({ matches: true }); // 切换到深色模式

      expect(themeManager.getCurrentTheme()).toBe('dark-theme');
    });
  });

  describe('主题定制和变量管理', () => {
    beforeEach(() => {
      themeManager.registerTheme(mockTheme);
      themeManager.applyTheme('dark-theme');
    });

    test('应该支持运行时变量修改', () => {
      themeManager.setThemeVariable('--primary-color', '#ff0000');

      expect(document.documentElement.style.setProperty)
        .toHaveBeenCalledWith('--primary-color', '#ff0000');
    });

    test('应该支持批量变量修改', () => {
      const variables = {
        '--primary-color': '#ff0000',
        '--secondary-color': '#00ff00',
        '--accent-color': '#0000ff'
      };

      themeManager.setThemeVariables(variables);

      Object.entries(variables).forEach(([key, value]) => {
        expect(document.documentElement.style.setProperty)
          .toHaveBeenCalledWith(key, value);
      });
    });

    test('应该获取当前变量值', () => {
      const value = themeManager.getThemeVariable('--primary-color');
      expect(value).toBe('#007acc');
    });

    test('应该支持主题变量计算', () => {
      const computedColor = themeManager.computeThemeVariable('--primary-color', {
        darken: 0.2,
        alpha: 0.8
      });

      expect(computedColor).toMatch(/rgba?\(/);
    });

    test('应该支持主题预览', () => {
      const previewId = themeManager.previewTheme('dark-theme', {
        '--primary-color': '#purple'
      });

      expect(previewId).toBeDefined();
      expect(document.documentElement.style.setProperty)
        .toHaveBeenCalledWith('--primary-color', '#purple');

      // 取消预览
      themeManager.cancelPreview(previewId);
      expect(document.documentElement.style.setProperty)
        .toHaveBeenCalledWith('--primary-color', '#007acc'); // 恢复原值
    });
  });

  describe('主题持久化', () => {
    test('应该保存主题配置到存储', () => {
      const mockStorage = {
        setItem: vi.fn(),
        getItem: vi.fn(),
        removeItem: vi.fn()
      };

      global.localStorage = mockStorage as any;

      themeManager.applyTheme('dark-theme');

      expect(mockStorage.setItem).toHaveBeenCalledWith(
        'serialstudio.theme.current',
        'dark-theme'
      );
    });

    test('应该从存储恢复主题配置', () => {
      const mockStorage = {
        getItem: vi.fn().mockReturnValue('dark-theme'),
        setItem: vi.fn(),
        removeItem: vi.fn()
      };

      global.localStorage = mockStorage as any;

      themeManager.registerTheme(mockTheme);
      themeManager.restoreTheme();

      expect(themeManager.getCurrentTheme()).toBe('dark-theme');
    });

    test('应该保存自定义变量', () => {
      const mockStorage = {
        setItem: vi.fn(),
        getItem: vi.fn(),
        removeItem: vi.fn()
      };

      global.localStorage = mockStorage as any;

      themeManager.setThemeVariable('--primary-color', '#custom');

      expect(mockStorage.setItem).toHaveBeenCalledWith(
        'serialstudio.theme.customVariables',
        JSON.stringify({ '--primary-color': '#custom' })
      );
    });

    test('应该支持主题配置导出导入', () => {
      themeManager.applyTheme('dark-theme');
      themeManager.setThemeVariable('--primary-color', '#custom');

      const exported = themeManager.exportThemeConfig();

      expect(exported).toEqual({
        currentTheme: 'dark-theme',
        customVariables: { '--primary-color': '#custom' },
        autoTheme: false
      });

      // 重置管理器
      const newManager = new ThemeManager();
      newManager.registerTheme(mockTheme);
      newManager.importThemeConfig(exported);

      expect(newManager.getCurrentTheme()).toBe('dark-theme');
      expect(newManager.getThemeVariable('--primary-color')).toBe('#custom');
    });
  });

  describe('组件主题集成', () => {
    test('应该为组件生成主题样式', () => {
      themeManager.registerTheme(mockTheme);
      themeManager.applyTheme('dark-theme');

      const componentStyles = themeManager.getComponentStyles('base-widget');

      expect(componentStyles).toEqual({
        backgroundColor: 'var(--background-color)',
        color: 'var(--text-color)',
        border: '1px solid var(--border-color)'
      });
    });

    test('应该支持组件主题继承', () => {
      const extendedTheme: Theme = {
        ...mockTheme,
        id: 'extended-theme',
        components: {
          'base-widget': {
            ...mockTheme.components['base-widget'],
            borderRadius: '4px'
          },
          'custom-widget': {
            extends: 'base-widget',
            padding: '8px'
          }
        }
      };

      themeManager.registerTheme(extendedTheme);
      themeManager.applyTheme('extended-theme');

      const customStyles = themeManager.getComponentStyles('custom-widget');

      expect(customStyles).toMatchObject({
        backgroundColor: 'var(--background-color)', // 继承
        color: 'var(--text-color)',                 // 继承
        border: '1px solid var(--border-color)',   // 继承
        borderRadius: '4px',                       // 继承
        padding: '8px'                             // 自己的
      });
    });

    test('应该生成CSS类名', () => {
      themeManager.registerTheme(mockTheme);
      themeManager.applyTheme('dark-theme');

      const cssClass = themeManager.generateCSSClass('widget-container', {
        backgroundColor: 'var(--background-color)',
        padding: '16px'
      });

      expect(cssClass).toMatch(/^widget-container-[\w]+$/);

      // 验证样式注入
      const styleElement = document.querySelector('style[data-theme]');
      expect(styleElement).toBeTruthy();
    });
  });
});
```

### 3.3 国际化引擎测试

```typescript
// tests/extensions/i18n-engine.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { I18nEngine } from '@/extensions/i18n-engine';
import { Locale, TranslationResource, I18nConfig } from '@/types/i18n';

describe('国际化引擎测试', () => {
  let i18nEngine: I18nEngine;
  let mockTranslations: Record<string, TranslationResource>;

  beforeEach(() => {
    mockTranslations = {
      'en-US': {
        locale: 'en-US',
        name: 'English (US)',
        messages: {
          'app.title': 'Serial Studio',
          'menu.file': 'File',
          'menu.edit': 'Edit',
          'widget.temperature': 'Temperature: {value}°C',
          'validation.required': 'This field is required',
          'validation.minLength': 'Minimum length is {min} characters',
          'time.relative.now': 'just now',
          'time.relative.minute': '{count} minute ago | {count} minutes ago'
        },
        formats: {
          number: {
            decimal: { minimumFractionDigits: 2 },
            percent: { style: 'percent' }
          },
          date: {
            short: { month: 'numeric', day: 'numeric', year: '2-digit' },
            long: { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }
          }
        }
      },
      'zh-CN': {
        locale: 'zh-CN',
        name: '中文 (简体)',
        direction: 'ltr',
        messages: {
          'app.title': 'Serial Studio',
          'menu.file': '文件',
          'menu.edit': '编辑',
          'widget.temperature': '温度：{value}°C',
          'validation.required': '此字段为必填项',
          'validation.minLength': '最小长度为 {min} 个字符',
          'time.relative.now': '刚刚',
          'time.relative.minute': '{count} 分钟前'
        }
      },
      'ar-SA': {
        locale: 'ar-SA',
        name: 'العربية',
        direction: 'rtl',
        messages: {
          'app.title': 'Serial Studio',
          'menu.file': 'ملف',
          'menu.edit': 'تحرير',
          'widget.temperature': 'درجة الحرارة: {value}°م',
          'validation.required': 'هذا الحقل مطلوب'
        }
      }
    };

    i18nEngine = new I18nEngine({
      defaultLocale: 'en-US',
      fallbackLocale: 'en-US',
      autoDetect: false
    });
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('本地化资源管理', () => {
    test('应该正确加载翻译资源', () => {
      const loaded = i18nEngine.loadTranslations(mockTranslations['en-US']);

      expect(loaded).toBe(true);
      expect(i18nEngine.getAvailableLocales()).toContain('en-US');
    });

    test('应该验证翻译资源格式', () => {
      const invalidResource = {
        locale: '', // 无效的locale
        messages: {}
      };

      expect(() => {
        i18nEngine.loadTranslations(invalidResource as TranslationResource);
      }).toThrow('Invalid translation resource');
    });

    test('应该支持异步加载翻译', async () => {
      const mockFetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(mockTranslations['zh-CN'])
      });

      global.fetch = mockFetch;

      const loaded = await i18nEngine.loadTranslationsAsync('zh-CN', '/locales/zh-CN.json');

      expect(loaded).toBe(true);
      expect(mockFetch).toHaveBeenCalledWith('/locales/zh-CN.json');
      expect(i18nEngine.getAvailableLocales()).toContain('zh-CN');
    });

    test('应该支持翻译资源合并', () => {
      i18nEngine.loadTranslations(mockTranslations['en-US']);

      const additionalTranslations: TranslationResource = {
        locale: 'en-US',
        name: 'English (US)',
        messages: {
          'new.message': 'New Message',
          'menu.file': 'File (Updated)' // 覆盖现有翻译
        }
      };

      i18nEngine.mergeTranslations('en-US', additionalTranslations);

      expect(i18nEngine.t('new.message')).toBe('New Message');
      expect(i18nEngine.t('menu.file')).toBe('File (Updated)');
      expect(i18nEngine.t('menu.edit')).toBe('Edit'); // 保持不变
    });

    test('应该支持命名空间', () => {
      const namespacedTranslations: TranslationResource = {
        locale: 'en-US',
        name: 'English (US)',
        messages: {
          'widgets.plot.title': 'Plot Widget',
          'widgets.gauge.title': 'Gauge Widget',
          'dialogs.settings.title': 'Settings'
        }
      };

      i18nEngine.loadTranslations(namespacedTranslations);

      expect(i18nEngine.t('widgets.plot.title')).toBe('Plot Widget');
      expect(i18nEngine.t('dialogs.settings.title')).toBe('Settings');
    });
  });

  describe('本地化切换', () => {
    beforeEach(() => {
      Object.values(mockTranslations).forEach(translations => {
        i18nEngine.loadTranslations(translations);
      });
    });

    test('应该正确切换语言', () => {
      const changed = i18nEngine.setLocale('zh-CN');

      expect(changed).toBe(true);
      expect(i18nEngine.getCurrentLocale()).toBe('zh-CN');
      expect(i18nEngine.t('menu.file')).toBe('文件');
    });

    test('应该处理不存在的语言', () => {
      const changed = i18nEngine.setLocale('fr-FR');

      expect(changed).toBe(false);
      expect(i18nEngine.getCurrentLocale()).toBe('en-US'); // 保持原有语言
    });

    test('应该自动检测系统语言', () => {
      const mockNavigator = {
        language: 'zh-CN',
        languages: ['zh-CN', 'en-US']
      };

      Object.defineProperty(global, 'navigator', {
        value: mockNavigator,
        writable: true
      });

      const engine = new I18nEngine({
        defaultLocale: 'en-US',
        autoDetect: true
      });

      Object.values(mockTranslations).forEach(translations => {
        engine.loadTranslations(translations);
      });

      expect(engine.getCurrentLocale()).toBe('zh-CN');
    });

    test('应该支持语言回退机制', () => {
      i18nEngine.setLocale('zh-CN');

      // 请求zh-CN中不存在的翻译
      const translation = i18nEngine.t('validation.minLength', { min: 5 });

      // 应该回退到fallback语言(en-US)
      expect(translation).toBe('Minimum length is 5 characters');
    });

    test('应该触发语言变化事件', () => {
      const changeHandler = vi.fn();

      i18nEngine.on('localeChanged', changeHandler);
      i18nEngine.setLocale('zh-CN');

      expect(changeHandler).toHaveBeenCalledWith({
        from: 'en-US',
        to: 'zh-CN',
        timestamp: expect.any(Number)
      });
    });
  });

  describe('文本翻译和插值', () => {
    beforeEach(() => {
      i18nEngine.loadTranslations(mockTranslations['en-US']);
    });

    test('应该正确翻译简单文本', () => {
      expect(i18nEngine.t('app.title')).toBe('Serial Studio');
      expect(i18nEngine.t('menu.file')).toBe('File');
    });

    test('应该处理不存在的翻译键', () => {
      expect(i18nEngine.t('nonexistent.key')).toBe('nonexistent.key');
    });

    test('应该支持变量插值', () => {
      const translated = i18nEngine.t('widget.temperature', { value: 25.6 });
      expect(translated).toBe('Temperature: 25.6°C');
    });

    test('应该支持复杂插值', () => {
      const translated = i18nEngine.t('validation.minLength', { min: 8 });
      expect(translated).toBe('Minimum length is 8 characters');
    });

    test('应该支持复数形式', () => {
      i18nEngine.loadTranslations(mockTranslations['en-US']);

      const singular = i18nEngine.t('time.relative.minute', { count: 1 });
      const plural = i18nEngine.t('time.relative.minute', { count: 5 });

      expect(singular).toBe('1 minute ago');
      expect(plural).toBe('5 minutes ago');
    });

    test('应该支持嵌套对象插值', () => {
      const nestedTranslations: TranslationResource = {
        locale: 'en-US',
        name: 'English (US)',
        messages: {
          'user.profile': 'User: {user.name} ({user.email})'
        }
      };

      i18nEngine.loadTranslations(nestedTranslations);

      const translated = i18nEngine.t('user.profile', {
        user: { name: 'John Doe', email: 'john@example.com' }
      });

      expect(translated).toBe('User: John Doe (john@example.com)');
    });

    test('应该支持HTML转义', () => {
      const htmlTranslations: TranslationResource = {
        locale: 'en-US',
        name: 'English (US)',
        messages: {
          'html.message': 'Welcome <strong>{name}</strong>!'
        }
      };

      i18nEngine.loadTranslations(htmlTranslations);

      const escaped = i18nEngine.t('html.message', { name: '<script>' }, { escapeHtml: true });
      const unescaped = i18nEngine.t('html.message', { name: 'John' }, { escapeHtml: false });

      expect(escaped).toBe('Welcome <strong>&lt;script&gt;</strong>!');
      expect(unescaped).toBe('Welcome <strong>John</strong>!');
    });
  });

  describe('数字和日期格式化', () => {
    beforeEach(() => {
      i18nEngine.loadTranslations(mockTranslations['en-US']);
    });

    test('应该格式化数字', () => {
      const number = 1234.56;

      const decimal = i18nEngine.formatNumber(number, 'decimal');
      const percent = i18nEngine.formatNumber(0.856, 'percent');

      expect(decimal).toBe('1,234.56');
      expect(percent).toBe('85.6%');
    });

    test('应该格式化日期', () => {
      const date = new Date('2023-12-25T10:30:00');

      const short = i18nEngine.formatDate(date, 'short');
      const long = i18nEngine.formatDate(date, 'long');

      expect(short).toMatch(/12\/25\/23/);
      expect(long).toMatch(/Monday, December 25, 2023/);
    });

    test('应该支持相对时间格式化', () => {
      const now = Date.now();
      const minuteAgo = now - 60 * 1000;
      const hoursAgo = now - 2 * 60 * 60 * 1000;

      expect(i18nEngine.formatRelativeTime(now)).toBe('just now');
      expect(i18nEngine.formatRelativeTime(minuteAgo)).toBe('1 minute ago');
      expect(i18nEngine.formatRelativeTime(hoursAgo)).toMatch(/2 hours ago/);
    });

    test('应该根据语言环境格式化', () => {
      i18nEngine.loadTranslations(mockTranslations['zh-CN']);
      i18nEngine.setLocale('zh-CN');

      const number = 1234.56;
      const formatted = i18nEngine.formatNumber(number, 'decimal');

      // 中文环境下的数字格式
      expect(formatted).toMatch(/1,234\.56|1 234,56/);
    });
  });

  describe('RTL语言支持', () => {
    beforeEach(() => {
      i18nEngine.loadTranslations(mockTranslations['ar-SA']);
    });

    test('应该检测RTL语言', () => {
      i18nEngine.setLocale('ar-SA');

      expect(i18nEngine.isRTL()).toBe(true);
      expect(i18nEngine.getTextDirection()).toBe('rtl');
    });

    test('应该应用RTL样式', () => {
      i18nEngine.setLocale('ar-SA');

      const mockElement = {
        setAttribute: vi.fn(),
        style: {
          direction: '',
          textAlign: ''
        }
      };

      i18nEngine.applyRTL(mockElement as any);

      expect(mockElement.setAttribute).toHaveBeenCalledWith('dir', 'rtl');
      expect(mockElement.style.direction).toBe('rtl');
    });

    test('应该处理RTL文本对齐', () => {
      i18nEngine.setLocale('ar-SA');

      const rtlAlignment = i18nEngine.getTextAlign('start');
      expect(rtlAlignment).toBe('right');

      i18nEngine.setLocale('en-US');
      const ltrAlignment = i18nEngine.getTextAlign('start');
      expect(ltrAlignment).toBe('left');
    });
  });

  describe('性能优化', () => {
    test('应该缓存翻译结果', () => {
      i18nEngine.loadTranslations(mockTranslations['en-US']);

      const translateSpy = vi.spyOn(i18nEngine, 'translateMessage');

      // 多次调用相同翻译
      const result1 = i18nEngine.t('app.title');
      const result2 = i18nEngine.t('app.title');
      const result3 = i18nEngine.t('app.title');

      expect(result1).toBe(result2);
      expect(result2).toBe(result3);
      expect(translateSpy).toHaveBeenCalledTimes(1); // 应该只计算一次
    });

    test('应该延迟加载翻译资源', async () => {
      const lazyLoader = vi.fn().mockResolvedValue(mockTranslations['zh-CN']);

      i18nEngine.registerLazyLoader('zh-CN', lazyLoader);

      // 首次访问时应该触发加载
      await i18nEngine.setLocale('zh-CN');

      expect(lazyLoader).toHaveBeenCalled();
      expect(i18nEngine.t('menu.file')).toBe('文件');
    });

    test('应该预加载翻译资源', async () => {
      const preloadSpy = vi.spyOn(i18nEngine, 'loadTranslationsAsync');

      await i18nEngine.preloadLocales(['zh-CN', 'ar-SA']);

      expect(preloadSpy).toHaveBeenCalledTimes(2);
      expect(preloadSpy).toHaveBeenCalledWith('zh-CN', expect.any(String));
      expect(preloadSpy).toHaveBeenCalledWith('ar-SA', expect.any(String));
    });
  });

  describe('Vue.js集成', () => {
    test('应该提供Vue插件接口', () => {
      const vuePlugin = i18nEngine.createVuePlugin();

      expect(vuePlugin).toHaveProperty('install');
      expect(typeof vuePlugin.install).toBe('function');
    });

    test('应该注册全局方法', () => {
      const mockApp = {
        config: {
          globalProperties: {}
        },
        provide: vi.fn()
      };

      const vuePlugin = i18nEngine.createVuePlugin();
      vuePlugin.install(mockApp);

      expect(mockApp.config.globalProperties.$t).toBe(i18nEngine.t);
      expect(mockApp.config.globalProperties.$d).toBe(i18nEngine.formatDate);
      expect(mockApp.config.globalProperties.$n).toBe(i18nEngine.formatNumber);
    });

    test('应该提供响应式语言状态', () => {
      const reactiveState = i18nEngine.getReactiveState();

      expect(reactiveState).toHaveProperty('locale');
      expect(reactiveState).toHaveProperty('isRTL');
      expect(reactiveState).toHaveProperty('direction');

      i18nEngine.setLocale('ar-SA');

      expect(reactiveState.locale).toBe('ar-SA');
      expect(reactiveState.isRTL).toBe(true);
      expect(reactiveState.direction).toBe('rtl');
    });
  });
});
```

### 3.4 许可证管理和配置系统测试

```typescript
// tests/extensions/license-config.test.ts
import { describe, test, expect, vi, beforeEach, afterEach } from 'vitest';
import { LicenseManager } from '@/extensions/license-manager';
import { ConfigManager } from '@/extensions/config-manager';
import { License, LicenseType, FeatureGate } from '@/types/license';

describe('许可证管理和配置系统测试', () => {
  let licenseManager: LicenseManager;
  let configManager: ConfigManager;

  beforeEach(() => {
    licenseManager = new LicenseManager();
    configManager = new ConfigManager();

    // Mock VSCode API
    global.vscode = {
      workspace: {
        getConfiguration: vi.fn().mockReturnValue({
          get: vi.fn(),
          update: vi.fn().mockResolvedValue(undefined),
          has: vi.fn()
        }),
        onDidChangeConfiguration: vi.fn()
      },
      window: {
        showInformationMessage: vi.fn(),
        showWarningMessage: vi.fn(),
        showErrorMessage: vi.fn()
      }
    } as any;
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('许可证管理测试', () => {
    test('应该验证有效许可证', () => {
      const validLicense: License = {
        id: 'pro-license-123',
        type: LicenseType.Professional,
        issuer: 'Serial Studio Inc.',
        issuedTo: 'John Doe',
        email: 'john@example.com',
        issuedAt: Date.now(),
        expiresAt: Date.now() + 365 * 24 * 60 * 60 * 1000, // 1年后
        features: [
          FeatureGate.ADVANCED_VISUALIZATION,
          FeatureGate.DATA_EXPORT,
          FeatureGate.PLUGIN_SYSTEM
        ],
        signature: 'valid-signature'
      };

      const isValid = licenseManager.validateLicense(validLicense);
      expect(isValid).toBe(true);
    });

    test('应该拒绝过期许可证', () => {
      const expiredLicense: License = {
        id: 'expired-license',
        type: LicenseType.Professional,
        issuer: 'Serial Studio Inc.',
        issuedTo: 'John Doe',
        email: 'john@example.com',
        issuedAt: Date.now() - 400 * 24 * 60 * 60 * 1000,
        expiresAt: Date.now() - 10 * 24 * 60 * 60 * 1000, // 10天前过期
        features: [FeatureGate.ADVANCED_VISUALIZATION],
        signature: 'valid-signature'
      };

      const isValid = licenseManager.validateLicense(expiredLicense);
      expect(isValid).toBe(false);
    });

    test('应该检查特性授权', () => {
      const license: License = {
        id: 'basic-license',
        type: LicenseType.Basic,
        issuer: 'Serial Studio Inc.',
        issuedTo: 'User',
        email: 'user@example.com',
        issuedAt: Date.now(),
        expiresAt: Date.now() + 365 * 24 * 60 * 60 * 1000,
        features: [FeatureGate.BASIC_VISUALIZATION],
        signature: 'valid-signature'
      };

      licenseManager.setLicense(license);

      expect(licenseManager.hasFeature(FeatureGate.BASIC_VISUALIZATION)).toBe(true);
      expect(licenseManager.hasFeature(FeatureGate.ADVANCED_VISUALIZATION)).toBe(false);
      expect(licenseManager.hasFeature(FeatureGate.PLUGIN_SYSTEM)).toBe(false);
    });

    test('应该处理免费版本限制', () => {
      // 没有许可证 = 免费版本
      expect(licenseManager.hasFeature(FeatureGate.BASIC_VISUALIZATION)).toBe(true);
      expect(licenseManager.hasFeature(FeatureGate.ADVANCED_VISUALIZATION)).toBe(false);
      expect(licenseManager.hasFeature(FeatureGate.DATA_EXPORT)).toBe(false);
      expect(licenseManager.hasFeature(FeatureGate.PLUGIN_SYSTEM)).toBe(false);
    });

    test('应该支持许可证升级', async () => {
      const basicLicense: License = {
        id: 'basic-license',
        type: LicenseType.Basic,
        issuer: 'Serial Studio Inc.',
        issuedTo: 'User',
        email: 'user@example.com',
        issuedAt: Date.now(),
        expiresAt: Date.now() + 365 * 24 * 60 * 60 * 1000,
        features: [FeatureGate.BASIC_VISUALIZATION],
        signature: 'basic-signature'
      };

      const proLicense: License = {
        ...basicLicense,
        id: 'pro-license-upgrade',
        type: LicenseType.Professional,
        features: [
          FeatureGate.BASIC_VISUALIZATION,
          FeatureGate.ADVANCED_VISUALIZATION,
          FeatureGate.DATA_EXPORT
        ],
        signature: 'pro-signature'
      };

      licenseManager.setLicense(basicLicense);
      expect(licenseManager.getLicenseType()).toBe(LicenseType.Basic);

      const upgraded = await licenseManager.upgradeLicense(proLicense);
      expect(upgraded).toBe(true);
      expect(licenseManager.getLicenseType()).toBe(LicenseType.Professional);
    });

    test('应该验证许可证签名', () => {
      const mockCrypto = {
        verify: vi.fn().mockReturnValue(true)
      };

      vi.doMock('crypto', () => mockCrypto);

      const license: License = {
        id: 'test-license',
        type: LicenseType.Professional,
        issuer: 'Serial Studio Inc.',
        issuedTo: 'Test User',
        email: 'test@example.com',
        issuedAt: Date.now(),
        expiresAt: Date.now() + 365 * 24 * 60 * 60 * 1000,
        features: [FeatureGate.ADVANCED_VISUALIZATION],
        signature: 'test-signature'
      };

      const isValid = licenseManager.verifySignature(license);
      expect(isValid).toBe(true);
    });
  });

  describe('配置系统测试', () => {
    test('应该加载默认配置', () => {
      const config = configManager.getConfiguration();

      expect(config).toHaveProperty('communication');
      expect(config).toHaveProperty('visualization');
      expect(config).toHaveProperty('performance');
      expect(config).toHaveProperty('ui');
    });

    test('应该获取配置值', () => {
      const mockGet = vi.fn().mockReturnValue(115200);
      global.vscode.workspace.getConfiguration().get = mockGet;

      const baudRate = configManager.get('communication.uart.baudRate');

      expect(mockGet).toHaveBeenCalledWith('communication.uart.baudRate');
      expect(baudRate).toBe(115200);
    });

    test('应该设置配置值', async () => {
      const mockUpdate = vi.fn().mockResolvedValue(undefined);
      global.vscode.workspace.getConfiguration().update = mockUpdate;

      await configManager.set('communication.uart.baudRate', 9600);

      expect(mockUpdate).toHaveBeenCalledWith(
        'communication.uart.baudRate',
        9600
      );
    });

    test('应该验证配置值', () => {
      expect(() => {
        configManager.validateConfig('communication.uart.baudRate', -1);
      }).toThrow('Invalid baud rate');

      expect(() => {
        configManager.validateConfig('visualization.chart.updateRate', 0);
      }).toThrow('Update rate must be positive');
    });

    test('应该监听配置变化', () => {
      const changeHandler = vi.fn();
      const mockOnDidChangeConfiguration = vi.fn().mockReturnValue({
        dispose: vi.fn()
      });

      global.vscode.workspace.onDidChangeConfiguration = mockOnDidChangeConfiguration;

      configManager.onConfigurationChanged(changeHandler);

      expect(mockOnDidChangeConfiguration).toHaveBeenCalled();

      // 模拟配置变化
      const configChangeEvent = {
        affectsConfiguration: vi.fn().mockReturnValue(true)
      };

      const handler = mockOnDidChangeConfiguration.mock.calls[0][0];
      handler(configChangeEvent);

      expect(changeHandler).toHaveBeenCalled();
    });

    test('应该支持配置模板', () => {
      const template = configManager.getConfigurationTemplate('uart-device');

      expect(template).toEqual({
        communication: {
          uart: {
            path: '/dev/ttyUSB0',
            baudRate: 115200,
            dataBits: 8,
            stopBits: 1,
            parity: 'none'
          }
        },
        visualization: {
          refreshRate: 20,
          maxDataPoints: 1000
        }
      });
    });

    test('应该导出导入配置', () => {
      const mockConfig = {
        communication: {
          uart: { baudRate: 9600 }
        },
        ui: {
          theme: 'dark'
        }
      };

      const exported = configManager.exportConfiguration();
      expect(exported).toBeDefined();

      configManager.importConfiguration(mockConfig);
      expect(configManager.get('communication.uart.baudRate')).toBe(9600);
    });

    test('应该支持配置继承', () => {
      const baseConfig = {
        communication: {
          timeout: 5000,
          retries: 3
        }
      };

      const specificConfig = {
        communication: {
          uart: {
            baudRate: 115200
          }
        }
      };

      const merged = configManager.mergeConfigurations(baseConfig, specificConfig);

      expect(merged).toEqual({
        communication: {
          timeout: 5000,
          retries: 3,
          uart: {
            baudRate: 115200
          }
        }
      });
    });

    test('应该支持条件配置', () => {
      const conditionalConfig = {
        'communication.protocol': {
          when: 'licenseType === "Professional"',
          options: ['uart', 'tcp', 'udp', 'bluetooth'],
          default: ['uart', 'tcp']
        }
      };

      licenseManager.setLicense({
        type: LicenseType.Professional,
        features: [FeatureGate.ADVANCED_COMMUNICATION]
      } as License);

      const resolvedOptions = configManager.resolveConditionalConfig(
        'communication.protocol',
        conditionalConfig
      );

      expect(resolvedOptions).toEqual(['uart', 'tcp', 'udp', 'bluetooth']);
    });
  });

  describe('特性门控集成测试', () => {
    test('应该根据许可证限制配置选项', () => {
      // 设置基础许可证
      const basicLicense: License = {
        id: 'basic-license',
        type: LicenseType.Basic,
        features: [FeatureGate.BASIC_VISUALIZATION],
        issuedAt: Date.now(),
        expiresAt: Date.now() + 365 * 24 * 60 * 60 * 1000
      } as License;

      licenseManager.setLicense(basicLicense);

      // 获取可用的可视化组件选项
      const availableWidgets = configManager.getAvailableOptions('visualization.widgets');

      expect(availableWidgets).toEqual(['plot', 'gauge', 'bar', 'led']);
      expect(availableWidgets).not.toContain('plot3d'); // 专业版功能
      expect(availableWidgets).not.toContain('gps');     // 专业版功能
    });

    test('应该在特性不可用时显示升级提示', () => {
      const mockShowInformationMessage = vi.fn();
      global.vscode.window.showInformationMessage = mockShowInformationMessage;

      const result = configManager.trySetAdvancedFeature('visualization.plot3d.enabled', true);

      expect(result).toBe(false);
      expect(mockShowInformationMessage).toHaveBeenCalledWith(
        expect.stringContaining('upgrade'),
        'Upgrade Now',
        'Learn More'
      );
    });

    test('应该在许可证变化时更新配置', () => {
      const updateSpy = vi.spyOn(configManager, 'refreshAvailableOptions');

      // 模拟许可证升级
      licenseManager.emit('licenseChanged', {
        from: LicenseType.Free,
        to: LicenseType.Professional
      });

      expect(updateSpy).toHaveBeenCalled();
    });
  });
});
```

## 4. 性能基准测试

```typescript
// tests/extensions/performance.bench.ts
import { bench, describe } from 'vitest';
import { PluginManager } from '@/extensions/plugin-manager';
import { ThemeManager } from '@/extensions/theme-manager';
import { I18nEngine } from '@/extensions/i18n-engine';

describe('扩展模块性能基准测试', () => {
  bench('插件注册性能', () => {
    const pluginManager = new PluginManager();
    const mockPlugin = createMockPlugin();
    
    pluginManager.registerPlugin(mockPlugin);
  });

  bench('主题切换性能', () => {
    const themeManager = new ThemeManager();
    const mockTheme = createMockTheme();
    
    themeManager.registerTheme(mockTheme);
    themeManager.applyTheme('test-theme');
  });

  bench('翻译性能', () => {
    const i18nEngine = new I18nEngine();
    const mockTranslations = createMockTranslations();
    
    i18nEngine.loadTranslations(mockTranslations);
    
    for (let i = 0; i < 100; i++) {
      i18nEngine.t('test.message', { value: i });
    }
  });

  bench('大量插件加载', async () => {
    const pluginManager = new PluginManager();
    const plugins = Array.from({ length: 100 }, (_, i) => 
      createMockPlugin(`plugin-${i}`)
    );
    
    for (const plugin of plugins) {
      await pluginManager.registerPlugin(plugin);
    }
  });
});

function createMockPlugin(id = 'test-plugin') {
  return {
    manifest: {
      id,
      name: 'Test Plugin',
      version: '1.0.0',
      description: 'A test plugin',
      author: 'Test Author',
      main: 'index.js',
      extensionPoints: ['visualization.widgets'],
      dependencies: [],
      permissions: []
    },
    activate: async () => {},
    deactivate: async () => {},
    contributes: {}
  };
}

function createMockTheme() {
  return {
    id: 'test-theme',
    name: 'Test Theme',
    type: 'dark',
    variables: {
      '--primary-color': '#007acc',
      '--background-color': '#1e1e1e'
    },
    components: {}
  };
}

function createMockTranslations() {
  return {
    locale: 'en-US',
    name: 'English (US)',
    messages: {
      'test.message': 'Test message with {value}'
    }
  };
}
```

这个详细的扩展模块单元测试方案涵盖了插件管理、主题系统、国际化、许可证管理和配置系统等各个核心组件，确保扩展架构的可靠性和可维护性。