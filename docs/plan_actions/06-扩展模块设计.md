# Serial-Studio VSCode 插件扩展模块设计

## 1. 扩展模块概述

基于对 Serial-Studio 源代码的深度分析，扩展模块是支持插件完整功能的重要组成部分，包括主题系统、多语言支持、更新机制、插件系统等核心支撑功能。

### 1.1 模块职责

- **主题系统**：提供完整的主题切换和自定义能力
- **多语言支持**：实现国际化和本地化功能
- **质量保证**：系统测试和监控功能
- **更新机制**：自动检查和更新插件
- **插件系统**：支持第三方扩展和自定义功能
- **配置管理**：统一的配置存储和管理

### 1.2 设计目标

- **模块化架构**：各扩展模块独立且可插拔
- **无缝集成**：与 VSCode 生态系统深度集成
- **用户体验**：提供一致且流畅的用户体验
- **扩展性**：支持未来功能扩展和定制化需求

## 2. 主题系统设计

### 2.1 主题架构

```typescript
// stores/theme.ts
import { defineStore } from 'pinia'
import { ref, computed, watch } from 'vue'

interface ThemeConfig {
  name: string;
  type: 'light' | 'dark';
  colors: ThemeColors;
  fonts: ThemeFonts;
  spacing: ThemeSpacing;
  components: ComponentTheme;
}

interface ThemeColors {
  // 基础色彩
  primary: string;
  secondary: string;
  success: string;
  warning: string;
  danger: string;
  info: string;
  
  // 背景色
  background: string;
  surface: string;
  overlay: string;
  
  // 文本色
  text: string;
  textSecondary: string;
  textDisabled: string;
  
  // 边框色
  border: string;
  borderHover: string;
  borderActive: string;
}

interface ThemeFonts {
  base: FontConfig;
  mono: FontConfig;
  heading: FontConfig;
}

interface FontConfig {
  family: string;
  size: string;
  weight: number;
  lineHeight: number;
}

interface ThemeSpacing {
  xs: string;
  sm: string;
  md: string;
  lg: string;
  xl: string;
}

interface ComponentTheme {
  button: ButtonTheme;
  input: InputTheme;
  card: CardTheme;
  chart: ChartTheme;
}

export const useThemeStore = defineStore('theme', () => {
  const currentTheme = ref<ThemeConfig>(getDefaultTheme());
  const systemTheme = ref<'light' | 'dark'>('light');
  const customThemes = ref<ThemeConfig[]>([]);
  
  // 监听系统主题变化
  const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
  
  const initializeTheme = () => {
    systemTheme.value = mediaQuery.matches ? 'dark' : 'light';
    
    mediaQuery.addEventListener('change', (e) => {
      systemTheme.value = e.matches ? 'dark' : 'light';
      if (currentTheme.value.name === 'auto') {
        applyTheme();
      }
    });
    
    // 同步 VSCode 主题
    syncWithVSCodeTheme();
  };
  
  const applyTheme = () => {
    const theme = getEffectiveTheme();
    
    // 应用 CSS 变量
    const root = document.documentElement;
    Object.entries(theme.colors).forEach(([key, value]) => {
      root.style.setProperty(`--theme-${key}`, value);
    });
    
    // 应用字体
    Object.entries(theme.fonts).forEach(([type, font]) => {
      root.style.setProperty(`--font-${type}-family`, font.family);
      root.style.setProperty(`--font-${type}-size`, font.size);
      root.style.setProperty(`--font-${type}-weight`, font.weight.toString());
      root.style.setProperty(`--font-${type}-line-height`, font.lineHeight.toString());
    });
    
    // 应用间距
    Object.entries(theme.spacing).forEach(([key, value]) => {
      root.style.setProperty(`--spacing-${key}`, value);
    });
    
    // 同步到 Element Plus
    syncElementPlusTheme(theme);
    
    // 通知组件更新
    notifyThemeChange(theme);
  };
  
  const syncWithVSCodeTheme = () => {
    // 监听 VSCode 主题变化
    vscode.postMessage({
      type: 'getTheme'
    });
    
    window.addEventListener('message', (event) => {
      const { type, payload } = event.data;
      if (type === 'themeChanged') {
        adaptToVSCodeTheme(payload);
      }
    });
  };
  
  const getEffectiveTheme = (): ThemeConfig => {
    if (currentTheme.value.name === 'auto') {
      return systemTheme.value === 'dark' ? getDarkTheme() : getLightTheme();
    }
    return currentTheme.value;
  };
  
  const setTheme = (theme: ThemeConfig | string) => {
    if (typeof theme === 'string') {
      const found = predefinedThemes.find(t => t.name === theme);
      if (found) {
        currentTheme.value = found;
      }
    } else {
      currentTheme.value = theme;
    }
    
    applyTheme();
    saveThemePreference();
  };
  
  const createCustomTheme = (baseTheme: ThemeConfig, customizations: Partial<ThemeConfig>): ThemeConfig => {
    return {
      ...baseTheme,
      ...customizations,
      colors: { ...baseTheme.colors, ...customizations.colors },
      fonts: { ...baseTheme.fonts, ...customizations.fonts },
      spacing: { ...baseTheme.spacing, ...customizations.spacing }
    };
  };
  
  const exportTheme = (): string => {
    return JSON.stringify(currentTheme.value, null, 2);
  };
  
  const importTheme = (themeJson: string): boolean => {
    try {
      const theme = JSON.parse(themeJson) as ThemeConfig;
      if (validateTheme(theme)) {
        customThemes.value.push(theme);
        setTheme(theme);
        return true;
      }
    } catch (error) {
      console.error('Failed to import theme:', error);
    }
    return false;
  };
  
  return {
    currentTheme,
    systemTheme,
    customThemes,
    initializeTheme,
    setTheme,
    createCustomTheme,
    exportTheme,
    importTheme,
    getEffectiveTheme
  };
});

// 预定义主题
const predefinedThemes: ThemeConfig[] = [
  {
    name: 'auto',
    type: 'light',
    colors: getLightColors(),
    fonts: getDefaultFonts(),
    spacing: getDefaultSpacing(),
    components: getDefaultComponents()
  },
  {
    name: 'light',
    type: 'light',
    colors: getLightColors(),
    fonts: getDefaultFonts(),
    spacing: getDefaultSpacing(),
    components: getDefaultComponents()
  },
  {
    name: 'dark',
    type: 'dark',
    colors: getDarkColors(),
    fonts: getDefaultFonts(),
    spacing: getDefaultSpacing(),
    components: getDefaultComponents()
  },
  {
    name: 'vscode-default',
    type: 'light',
    colors: getVSCodeLightColors(),
    fonts: getVSCodeFonts(),
    spacing: getDefaultSpacing(),
    components: getVSCodeComponents()
  },
  {
    name: 'vscode-dark',
    type: 'dark',
    colors: getVSCodeDarkColors(),
    fonts: getVSCodeFonts(),
    spacing: getDefaultSpacing(),
    components: getVSCodeComponents()
  }
];
```

### 2.2 主题配置系统

```typescript
// utils/themeManager.ts
export class ThemeManager {
  private static instance: ThemeManager;
  private themeStore = useThemeStore();
  
  static getInstance(): ThemeManager {
    if (!this.instance) {
      this.instance = new ThemeManager();
    }
    return this.instance;
  }
  
  // 主题色生成器
  generateColorPalette(primaryColor: string): ThemeColors {
    const primary = new Color(primaryColor);
    
    return {
      primary: primaryColor,
      secondary: primary.lighten(0.1).hex(),
      success: '#67c23a',
      warning: '#e6a23c',
      danger: '#f56c6c',
      info: '#909399',
      
      background: primary.lightness(0.98).hex(),
      surface: primary.lightness(0.95).hex(),
      overlay: primary.alpha(0.8).hex(),
      
      text: primary.lightness(0.1).hex(),
      textSecondary: primary.lightness(0.3).hex(),
      textDisabled: primary.lightness(0.6).hex(),
      
      border: primary.lightness(0.85).hex(),
      borderHover: primary.lightness(0.75).hex(),
      borderActive: primary.lightness(0.65).hex()
    };
  }
  
  // 响应式设计适配
  getResponsiveConfig(): ResponsiveConfig {
    const viewport = getViewportSize();
    
    if (viewport.width < 768) {
      return {
        spacing: { xs: '4px', sm: '8px', md: '12px', lg: '16px', xl: '20px' },
        fonts: { base: { size: '14px' }, mono: { size: '12px' } }
      };
    } else if (viewport.width < 1200) {
      return {
        spacing: { xs: '6px', sm: '12px', md: '16px', lg: '20px', xl: '24px' },
        fonts: { base: { size: '16px' }, mono: { size: '14px' } }
      };
    } else {
      return {
        spacing: { xs: '8px', sm: '16px', md: '20px', lg: '24px', xl: '32px' },
        fonts: { base: { size: '16px' }, mono: { size: '14px' } }
      };
    }
  }
  
  // 可访问性检查
  validateAccessibility(theme: ThemeConfig): AccessibilityReport {
    const report: AccessibilityReport = {
      contrastRatios: {},
      recommendations: [],
      passed: true
    };
    
    // 检查颜色对比度
    const textContrast = getContrastRatio(theme.colors.text, theme.colors.background);
    report.contrastRatios.text = textContrast;
    
    if (textContrast < 4.5) {
      report.passed = false;
      report.recommendations.push('文本颜色对比度不足，建议调整');
    }
    
    // 检查其他可访问性要求
    validateFontSizes(theme.fonts, report);
    validateColorBlindness(theme.colors, report);
    
    return report;
  }
}

interface ResponsiveConfig {
  spacing: Partial<ThemeSpacing>;
  fonts: Partial<ThemeFonts>;
}

interface AccessibilityReport {
  contrastRatios: Record<string, number>;
  recommendations: string[];
  passed: boolean;
}
```

## 3. 多语言支持系统

### 3.1 国际化架构

```typescript
// stores/i18n.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

interface LocaleConfig {
  code: string;
  name: string;
  nativeName: string;
  flag: string;
  rtl: boolean;
  translations: Record<string, any>;
}

export const useI18nStore = defineStore('i18n', () => {
  const currentLocale = ref<string>('en');
  const availableLocales = ref<LocaleConfig[]>([]);
  const translations = ref<Record<string, Record<string, any>>>({});
  const fallbackLocale = ref<string>('en');
  
  const initializeI18n = async () => {
    // 加载支持的语言列表
    await loadAvailableLocales();
    
    // 检测用户首选语言
    const preferredLocale = detectUserLocale();
    await setLocale(preferredLocale);
    
    // 监听 VSCode 语言变化
    listenToVSCodeLocaleChanges();
  };
  
  const detectUserLocale = (): string => {
    // 1. 检查 VSCode 设置
    const vscodeLocale = getVSCodeLocale();
    if (vscodeLocale && isLocaleSupported(vscodeLocale)) {
      return vscodeLocale;
    }
    
    // 2. 检查浏览器语言
    const browserLocale = navigator.language.split('-')[0];
    if (isLocaleSupported(browserLocale)) {
      return browserLocale;
    }
    
    // 3. 使用默认语言
    return fallbackLocale.value;
  };
  
  const loadAvailableLocales = async () => {
    try {
      const response = await fetch('/locales/index.json');
      availableLocales.value = await response.json();
    } catch (error) {
      console.error('Failed to load available locales:', error);
    }
  };
  
  const loadTranslations = async (locale: string): Promise<Record<string, any>> => {
    if (translations.value[locale]) {
      return translations.value[locale];
    }
    
    try {
      const response = await fetch(`/locales/${locale}.json`);
      const localeTranslations = await response.json();
      translations.value[locale] = localeTranslations;
      return localeTranslations;
    } catch (error) {
      console.error(`Failed to load translations for ${locale}:`, error);
      return {};
    }
  };
  
  const setLocale = async (locale: string) => {
    if (!isLocaleSupported(locale)) {
      console.warn(`Locale ${locale} is not supported, falling back to ${fallbackLocale.value}`);
      locale = fallbackLocale.value;
    }
    
    await loadTranslations(locale);
    currentLocale.value = locale;
    
    // 更新 document 语言属性
    document.documentElement.lang = locale;
    
    // 更新 RTL 方向
    const localeConfig = getLocaleConfig(locale);
    document.documentElement.dir = localeConfig?.rtl ? 'rtl' : 'ltr';
    
    // 保存用户选择
    saveLocalePreference(locale);
    
    // 通知 VSCode
    notifyVSCodeLocaleChange(locale);
  };
  
  const t = (key: string, params?: Record<string, any>): string => {
    const currentTranslations = translations.value[currentLocale.value] || {};
    const fallbackTranslations = translations.value[fallbackLocale.value] || {};
    
    // 递归获取嵌套的翻译
    const getValue = (obj: any, path: string): string => {
      return path.split('.').reduce((o, k) => (o && o[k]) || null, obj);
    };
    
    let translation = getValue(currentTranslations, key) || getValue(fallbackTranslations, key) || key;
    
    // 参数替换
    if (params && typeof translation === 'string') {
      Object.entries(params).forEach(([param, value]) => {
        translation = translation.replace(new RegExp(`\\{${param}\\}`, 'g'), String(value));
      });
    }
    
    return translation;
  };
  
  const isLocaleSupported = (locale: string): boolean => {
    return availableLocales.value.some(l => l.code === locale);
  };
  
  const getLocaleConfig = (locale: string): LocaleConfig | undefined => {
    return availableLocales.value.find(l => l.code === locale);
  };
  
  return {
    currentLocale,
    availableLocales,
    initializeI18n,
    setLocale,
    t,
    isLocaleSupported,
    getLocaleConfig
  };
});
```

### 3.2 翻译管理系统

```typescript
// utils/translationManager.ts
export class TranslationManager {
  private static instance: TranslationManager;
  private i18nStore = useI18nStore();
  
  static getInstance(): TranslationManager {
    if (!this.instance) {
      this.instance = new TranslationManager();
    }
    return this.instance;
  }
  
  // 动态加载翻译
  async loadNamespaceTranslations(namespace: string, locale?: string): Promise<void> {
    const targetLocale = locale || this.i18nStore.currentLocale;
    
    try {
      const response = await fetch(`/locales/${targetLocale}/${namespace}.json`);
      const namespaceTranslations = await response.json();
      
      // 合并到主翻译对象
      const currentTranslations = this.i18nStore.translations[targetLocale] || {};
      currentTranslations[namespace] = namespaceTranslations;
    } catch (error) {
      console.error(`Failed to load namespace ${namespace} for locale ${targetLocale}:`, error);
    }
  }
  
  // 复数形式处理
  plural(key: string, count: number, params?: Record<string, any>): string {
    const pluralKey = this.getPluralKey(key, count);
    return this.i18nStore.t(pluralKey, { ...params, count });
  }
  
  private getPluralKey(key: string, count: number): string {
    const locale = this.i18nStore.currentLocale;
    const rules = getPluralRules(locale);
    
    if (count === 0 && rules.zero) return `${key}.zero`;
    if (count === 1 && rules.one) return `${key}.one`;
    if (count === 2 && rules.two) return `${key}.two`;
    if (count < 5 && rules.few) return `${key}.few`;
    return `${key}.other`;
  }
  
  // 日期时间格式化
  formatDate(date: Date, format: 'short' | 'medium' | 'long' | 'full' = 'medium'): string {
    const locale = this.i18nStore.currentLocale;
    const options = getDateFormatOptions(format);
    
    return new Intl.DateTimeFormat(locale, options).format(date);
  }
  
  // 数字格式化
  formatNumber(number: number, options?: Intl.NumberFormatOptions): string {
    const locale = this.i18nStore.currentLocale;
    return new Intl.NumberFormat(locale, options).format(number);
  }
  
  // 货币格式化
  formatCurrency(amount: number, currency: string): string {
    const locale = this.i18nStore.currentLocale;
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency
    }).format(amount);
  }
  
  // 相对时间格式化
  formatRelativeTime(date: Date): string {
    const locale = this.i18nStore.currentLocale;
    const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
    
    const diff = date.getTime() - Date.now();
    const absDiff = Math.abs(diff);
    
    if (absDiff < 60000) return rtf.format(Math.round(diff / 1000), 'second');
    if (absDiff < 3600000) return rtf.format(Math.round(diff / 60000), 'minute');
    if (absDiff < 86400000) return rtf.format(Math.round(diff / 3600000), 'hour');
    return rtf.format(Math.round(diff / 86400000), 'day');
  }
}

// 支持的语言配置
const supportedLocales: LocaleConfig[] = [
  {
    code: 'en',
    name: 'English',
    nativeName: 'English',
    flag: '🇺🇸',
    rtl: false,
    translations: {}
  },
  {
    code: 'zh',
    name: 'Chinese',
    nativeName: '中文',
    flag: '🇨🇳',
    rtl: false,
    translations: {}
  },
  {
    code: 'ja',
    name: 'Japanese',
    nativeName: '日本語',
    flag: '🇯🇵',
    rtl: false,
    translations: {}
  },
  {
    code: 'ko',
    name: 'Korean',
    nativeName: '한국어',
    flag: '🇰🇷',
    rtl: false,
    translations: {}
  },
  {
    code: 'es',
    name: 'Spanish',
    nativeName: 'Español',
    flag: '🇪🇸',
    rtl: false,
    translations: {}
  },
  {
    code: 'fr',
    name: 'French',
    nativeName: 'Français',
    flag: '🇫🇷',
    rtl: false,
    translations: {}
  },
  {
    code: 'de',
    name: 'German',
    nativeName: 'Deutsch',
    flag: '🇩🇪',
    rtl: false,
    translations: {}
  },
  {
    code: 'ru',
    name: 'Russian',
    nativeName: 'Русский',
    flag: '🇷🇺',
    rtl: false,
    translations: {}
  },
  {
    code: 'ar',
    name: 'Arabic',
    nativeName: 'العربية',
    flag: '🇸🇦',
    rtl: true,
    translations: {}
  }
];
```

## 4. 质量保证系统

### 4.1 测试框架架构

```typescript
// stores/testing.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

interface TestResult {
  testId: string;
  name: string;
  status: 'pending' | 'running' | 'passed' | 'failed';
  duration?: number;
  error?: string;
  timestamp?: Date;
}

interface TestSuite {
  id: string;
  name: string;
  description: string;
  tests: TestResult[];
  coverage?: number;
}

export const useTestingStore = defineStore('testing', () => {
  const currentLicense = ref<LicenseInfo>({
    type: 'free',
    features: ['basic-serial', 'basic-visualization']
  });
  
  const availableFeatures = ref<FeatureConfig[]>([
    {
      id: 'basic-serial',
      name: 'Basic Serial Communication',
      description: 'UART/COM port communication',
      requiresLicense: false,
      licenseTypes: []
    },
    {
      id: 'basic-visualization',
      name: 'Basic Visualization',
      description: 'Plot, Gauge, Bar charts',
      requiresLicense: false,
      licenseTypes: []
    },
    {
      id: 'network-communication',
      name: 'Network Communication',
      description: 'TCP/UDP communication',
      requiresLicense: false,
      licenseTypes: []
    },
    {
      id: 'bluetooth-communication',
      name: 'Bluetooth LE Communication',
      description: 'Bluetooth Low Energy support',
      requiresLicense: false,
      licenseTypes: []
    },
    {
      id: 'advanced-visualization',
      name: 'Advanced Visualization',
      description: '3D plots, FFT analysis, GPS maps',
      requiresLicense: true,
      licenseTypes: ['trial', 'commercial']
    },
    {
      id: 'audio-communication',
      name: 'Audio Communication',
      description: 'Audio stream input',
      requiresLicense: true,
      licenseTypes: ['commercial']
    },
    {
      id: 'modbus-communication',
      name: 'Modbus Communication',
      description: 'Modbus protocol support',
      requiresLicense: true,
      licenseTypes: ['commercial']
    },
    {
      id: 'canbus-communication',
      name: 'CAN Bus Communication',
      description: 'CAN bus protocol support',
      requiresLicense: true,
      licenseTypes: ['commercial']
    },
    {
      id: 'mqtt-integration',
      name: 'MQTT Integration',
      description: 'MQTT client functionality',
      requiresLicense: true,
      licenseTypes: ['trial', 'commercial']
    },
    {
      id: 'cloud-sync',
      name: 'Cloud Synchronization',
      description: 'Cloud-based project sync',
      requiresLicense: true,
      licenseTypes: ['commercial']
    }
  ]);
  
  const isFeatureAvailable = (featureId: string): boolean => {
    const feature = availableFeatures.value.find(f => f.id === featureId);
    if (!feature) return false;
    
    // 免费功能始终可用
    if (!feature.requiresLicense) return true;
    
    // 检查当前许可是否支持该功能
    return feature.licenseTypes.includes(currentLicense.value.type as any);
  };
  
  const getAvailableFeatures = computed(() => {
    return availableFeatures.value.filter(feature => 
      !feature.requiresLicense || 
      feature.licenseTypes.includes(currentLicense.value.type as any)
    );
  });
  
  const getRestrictedFeatures = computed(() => {
    return availableFeatures.value.filter(feature => 
      feature.requiresLicense && 
      !feature.licenseTypes.includes(currentLicense.value.type as any)
    );
  });
  
  const isTrialExpired = computed(() => {
    if (currentLicense.value.type !== 'trial') return false;
    if (!currentLicense.value.expirationDate) return false;
    
    return new Date() > currentLicense.value.expirationDate;
  });
  
  const trialDaysRemaining = computed(() => {
    if (currentLicense.value.type !== 'trial') return 0;
    if (!currentLicense.value.expirationDate) return 0;
    
    const diff = currentLicense.value.expirationDate.getTime() - Date.now();
    return Math.max(0, Math.ceil(diff / (1000 * 60 * 60 * 24)));
  });
  
  const activateLicense = async (licenseKey: string): Promise<boolean> => {
    try {
      const response = await validateLicenseKey(licenseKey);
      if (response.valid) {
        currentLicense.value = {
          type: response.type,
          features: response.features,
          expirationDate: response.expirationDate,
          activationKey: licenseKey,
          userInfo: response.userInfo
        };
        
        saveLicenseInfo();
        return true;
      }
    } catch (error) {
      console.error('License activation failed:', error);
    }
    
    return false;
  };
  
  const startTrial = async (): Promise<boolean> => {
    try {
      const trialInfo = await requestTrialLicense();
      if (trialInfo) {
        currentLicense.value = {
          type: 'trial',
          features: trialInfo.features,
          expirationDate: trialInfo.expirationDate
        };
        
        saveLicenseInfo();
        return true;
      }
    } catch (error) {
      console.error('Trial activation failed:', error);
    }
    
    return false;
  };
  
  const checkLicenseStatus = async (): Promise<void> => {
    if (currentLicense.value.activationKey) {
      const isValid = await validateLicenseKey(currentLicense.value.activationKey);
      if (!isValid.valid) {
        // 许可证无效，回退到免费版
        currentLicense.value = {
          type: 'free',
          features: ['basic-serial', 'basic-visualization']
        };
        saveLicenseInfo();
      }
    }
  };
  
  return {
    currentLicense,
    availableFeatures,
    isFeatureAvailable,
    getAvailableFeatures,
    getRestrictedFeatures,
    isTrialExpired,
    trialDaysRemaining,
    activateLicense,
    startTrial,
    checkLicenseStatus
  };
});
```

### 4.2 功能限制组件

```vue
<!-- FeatureGate.vue -->
<template>
  <div class="feature-gate">
    <slot v-if="hasAccess" />
    
    <div v-else class="feature-restricted">
      <div class="restriction-overlay">
        <div class="restriction-content">
          <el-icon class="restriction-icon"><Lock /></el-icon>
          
          <h3 class="restriction-title">{{ t('license.featureRestricted') }}</h3>
          
          <p class="restriction-description">
            {{ t('license.featureDescription', { feature: featureName }) }}
          </p>
          
          <div class="restriction-actions">
            <el-button 
              v-if="showTrialOption && !licenseStore.isTrialExpired"
              type="primary"
              @click="startTrial"
            >
              {{ t('license.startTrial') }}
            </el-button>
            
            <el-button 
              type="primary"
              @click="showLicenseDialog"
            >
              {{ t('license.upgradeLicense') }}
            </el-button>
            
            <el-button 
              type="info"
              @click="learnMore"
            >
              {{ t('license.learnMore') }}
            </el-button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 许可证激活对话框 -->
    <LicenseActivationDialog 
      v-model="showLicenseActivation"
      @activated="onLicenseActivated"
    />
  </div>
</template>

<script setup lang="ts">
import { computed, ref } from 'vue';
import { useLicenseStore } from '@/stores/license';
import { useI18nStore } from '@/stores/i18n';
import LicenseActivationDialog from './LicenseActivationDialog.vue';

interface Props {
  feature: string;
  showTrialOption?: boolean;
  fallbackContent?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  showTrialOption: true,
  fallbackContent: false
});

const licenseStore = useLicenseStore();
const { t } = useI18nStore();

const showLicenseActivation = ref(false);

const hasAccess = computed(() => {
  return licenseStore.isFeatureAvailable(props.feature);
});

const featureName = computed(() => {
  const feature = licenseStore.availableFeatures.find(f => f.id === props.feature);
  return feature?.name || props.feature;
});

const startTrial = async () => {
  const success = await licenseStore.startTrial();
  if (success) {
    ElMessage.success(t('license.trialStarted'));
  } else {
    ElMessage.error(t('license.trialFailed'));
  }
};

const showLicenseDialog = () => {
  showLicenseActivation.value = true;
};

const learnMore = () => {
  window.open('https://serial-studio.com/pricing', '_blank');
};

const onLicenseActivated = () => {
  ElMessage.success(t('license.activationSuccess'));
};
</script>

<style scoped>
.feature-gate {
  position: relative;
}

.feature-restricted {
  position: relative;
  min-height: 200px;
}

.restriction-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
}

.restriction-content {
  text-align: center;
  max-width: 400px;
  padding: 24px;
}

.restriction-icon {
  font-size: 48px;
  color: var(--el-color-warning);
  margin-bottom: 16px;
}

.restriction-title {
  margin: 0 0 12px 0;
  color: var(--el-text-color-primary);
}

.restriction-description {
  margin: 0 0 24px 0;
  color: var(--el-text-color-regular);
  line-height: 1.5;
}

.restriction-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  flex-wrap: wrap;
}
</style>
```

## 5. 更新机制系统

### 5.1 自动更新架构

```typescript
// services/updateService.ts
export class UpdateService {
  private static instance: UpdateService;
  private updateChannel: 'stable' | 'beta' | 'alpha' = 'stable';
  private checkInterval: number = 24 * 60 * 60 * 1000; // 24小时
  private updateTimer: NodeJS.Timeout | null = null;
  
  static getInstance(): UpdateService {
    if (!this.instance) {
      this.instance = new UpdateService();
    }
    return this.instance;
  }
  
  async checkForUpdates(manual: boolean = false): Promise<UpdateInfo | null> {
    try {
      const currentVersion = await this.getCurrentVersion();
      const response = await fetch(`https://api.serial-studio.com/updates/vscode/${this.updateChannel}`);
      const updateInfo: UpdateInfo = await response.json();
      
      if (this.isNewerVersion(updateInfo.version, currentVersion)) {
        if (manual || updateInfo.critical) {
          this.notifyUpdateAvailable(updateInfo);
        }
        return updateInfo;
      }
    } catch (error) {
      console.error('Failed to check for updates:', error);
    }
    
    return null;
  }
  
  async downloadAndInstallUpdate(updateInfo: UpdateInfo): Promise<boolean> {
    try {
      // 显示下载进度
      const progressDialog = new UpdateProgressDialog();
      progressDialog.show();
      
      // 下载更新包
      const updateFile = await this.downloadUpdate(updateInfo, (progress) => {
        progressDialog.updateProgress(progress);
      });
      
      // 验证更新包
      const isValid = await this.verifyUpdate(updateFile, updateInfo.checksum);
      if (!isValid) {
        throw new Error('Update verification failed');
      }
      
      // 安装更新
      await this.installUpdate(updateFile);
      
      progressDialog.close();
      return true;
    } catch (error) {
      console.error('Update installation failed:', error);
      return false;
    }
  }
  
  private async getCurrentVersion(): Promise<string> {
    // 从 package.json 或 VSCode API 获取当前版本
    return vscode.extensions.getExtension('serial-studio.serial-visualization')?.packageJSON.version || '0.0.0';
  }
  
  private isNewerVersion(remoteVersion: string, currentVersion: string): boolean {
    return semver.gt(remoteVersion, currentVersion);
  }
  
  private async downloadUpdate(updateInfo: UpdateInfo, onProgress: (progress: number) => void): Promise<string> {
    const response = await fetch(updateInfo.downloadUrl);
    const total = parseInt(response.headers.get('content-length') || '0');
    let downloaded = 0;
    
    const chunks: Uint8Array[] = [];
    const reader = response.body?.getReader();
    
    while (true) {
      const { done, value } = await reader!.read();
      if (done) break;
      
      chunks.push(value);
      downloaded += value.length;
      onProgress((downloaded / total) * 100);
    }
    
    // 保存到临时文件
    const updateFile = path.join(os.tmpdir(), `serial-studio-update-${updateInfo.version}.vsix`);
    const buffer = Buffer.concat(chunks);
    await fs.writeFile(updateFile, buffer);
    
    return updateFile;
  }
  
  private async verifyUpdate(filePath: string, expectedChecksum: string): Promise<boolean> {
    const buffer = await fs.readFile(filePath);
    const hash = crypto.createHash('sha256').update(buffer).digest('hex');
    return hash === expectedChecksum;
  }
  
  private async installUpdate(filePath: string): Promise<void> {
    // 使用 VSCode 命令安装扩展
    await vscode.commands.executeCommand('workbench.extensions.installExtension', vscode.Uri.file(filePath));
  }
  
  private notifyUpdateAvailable(updateInfo: UpdateInfo): void {
    const message = `Serial Studio ${updateInfo.version} is available. Would you like to update now?`;
    
    vscode.window.showInformationMessage(
      message,
      'Update Now',
      'View Changes',
      'Remind Later'
    ).then(async (selection) => {
      switch (selection) {
        case 'Update Now':
          await this.downloadAndInstallUpdate(updateInfo);
          break;
        case 'View Changes':
          vscode.env.openExternal(vscode.Uri.parse(updateInfo.releaseNotesUrl));
          break;
        case 'Remind Later':
          // 设置稍后提醒
          setTimeout(() => this.notifyUpdateAvailable(updateInfo), 4 * 60 * 60 * 1000);
          break;
      }
    });
  }
  
  startPeriodicCheck(): void {
    this.updateTimer = setInterval(() => {
      this.checkForUpdates(false);
    }, this.checkInterval);
  }
  
  stopPeriodicCheck(): void {
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
      this.updateTimer = null;
    }
  }
}

interface UpdateInfo {
  version: string;
  releaseDate: string;
  downloadUrl: string;
  checksum: string;
  releaseNotesUrl: string;
  critical: boolean;
  features: string[];
  bugFixes: string[];
  breakingChanges: string[];
}
```

## 6. 插件系统设计

### 6.1 插件架构

```typescript
// types/plugin.ts
export interface PluginManifest {
  id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  license: string;
  
  engines: {
    vscode: string;
    serialStudio: string;
  };
  
  contributes: {
    drivers?: DriverContribution[];
    widgets?: WidgetContribution[];
    parsers?: ParserContribution[];
    themes?: ThemeContribution[];
    commands?: CommandContribution[];
  };
  
  activationEvents: string[];
  main?: string;
  dependencies?: Record<string, string>;
}

export interface DriverContribution {
  id: string;
  name: string;
  protocol: string;
  configSchema: JSONSchema;
  icon?: string;
}

export interface WidgetContribution {
  id: string;
  name: string;
  type: 'dataset' | 'group';
  component: string;
  configSchema: JSONSchema;
  preview?: string;
}

export interface ParserContribution {
  id: string;
  name: string;
  description: string;
  template: string;
  examples?: string[];
}

// services/pluginManager.ts
export class PluginManager {
  private static instance: PluginManager;
  private loadedPlugins = new Map<string, LoadedPlugin>();
  private pluginRegistry = new Map<string, PluginManifest>();
  
  static getInstance(): PluginManager {
    if (!this.instance) {
      this.instance = new PluginManager();
    }
    return this.instance;
  }
  
  async loadPlugin(manifestPath: string): Promise<boolean> {
    try {
      const manifest = await this.loadManifest(manifestPath);
      await this.validatePlugin(manifest);
      
      const plugin = await this.instantiatePlugin(manifest);
      
      // 注册插件贡献
      await this.registerContributions(plugin);
      
      this.loadedPlugins.set(manifest.id, plugin);
      this.pluginRegistry.set(manifest.id, manifest);
      
      return true;
    } catch (error) {
      console.error(`Failed to load plugin from ${manifestPath}:`, error);
      return false;
    }
  }
  
  unloadPlugin(pluginId: string): void {
    const plugin = this.loadedPlugins.get(pluginId);
    if (plugin) {
      // 卸载贡献
      this.unregisterContributions(plugin);
      
      // 调用插件的清理方法
      if (plugin.deactivate) {
        plugin.deactivate();
      }
      
      this.loadedPlugins.delete(pluginId);
      this.pluginRegistry.delete(pluginId);
    }
  }
  
  getPlugin(pluginId: string): LoadedPlugin | undefined {
    return this.loadedPlugins.get(pluginId);
  }
  
  getAvailablePlugins(): PluginManifest[] {
    return Array.from(this.pluginRegistry.values());
  }
  
  private async registerContributions(plugin: LoadedPlugin): Promise<void> {
    const manifest = plugin.manifest;
    
    // 注册驱动
    if (manifest.contributes.drivers) {
      for (const driver of manifest.contributes.drivers) {
        await this.registerDriver(driver, plugin);
      }
    }
    
    // 注册组件
    if (manifest.contributes.widgets) {
      for (const widget of manifest.contributes.widgets) {
        await this.registerWidget(widget, plugin);
      }
    }
    
    // 注册解析器
    if (manifest.contributes.parsers) {
      for (const parser of manifest.contributes.parsers) {
        await this.registerParser(parser, plugin);
      }
    }
    
    // 注册主题
    if (manifest.contributes.themes) {
      for (const theme of manifest.contributes.themes) {
        await this.registerTheme(theme, plugin);
      }
    }
  }
  
  private async registerDriver(driver: DriverContribution, plugin: LoadedPlugin): Promise<void> {
    // 注册到通信管理器
    const driverClass = plugin.exports[driver.id];
    if (driverClass) {
      IOManager.registerDriver(driver.id, driverClass);
    }
  }
  
  private async registerWidget(widget: WidgetContribution, plugin: LoadedPlugin): Promise<void> {
    // 注册到组件系统
    const component = plugin.exports[widget.component];
    if (component) {
      ComponentRegistry.register(widget.id, component);
    }
  }
}

interface LoadedPlugin {
  manifest: PluginManifest;
  exports: any;
  context: PluginContext;
  activate?: () => void;
  deactivate?: () => void;
}

interface PluginContext {
  subscriptions: vscode.Disposable[];
  globalStoragePath: string;
  workspaceStoragePath: string;
  extensionPath: string;
  logger: Logger;
}
```

## 7. 配置管理系统

### 7.1 统一配置架构

```typescript
// services/configManager.ts
export class ConfigManager {
  private static instance: ConfigManager;
  private config = reactive<AppConfig>({});
  private watchers = new Map<string, ConfigWatcher[]>();
  
  static getInstance(): ConfigManager {
    if (!this.instance) {
      this.instance = new ConfigManager();
    }
    return this.instance;
  }
  
  async initialize(): Promise<void> {
    // 加载默认配置
    this.config = { ...defaultConfig };
    
    // 加载用户配置
    await this.loadUserConfig();
    
    // 加载工作区配置
    await this.loadWorkspaceConfig();
    
    // 监听 VSCode 配置变化
    this.setupVSCodeConfigWatcher();
  }
  
  get<T>(key: string): T | undefined {
    return getNestedValue(this.config, key) as T;
  }
  
  set<T>(key: string, value: T): void {
    setNestedValue(this.config, key, value);
    this.saveUserConfig();
    this.notifyWatchers(key, value);
  }
  
  watch(key: string, callback: ConfigWatcher): () => void {
    if (!this.watchers.has(key)) {
      this.watchers.set(key, []);
    }
    
    this.watchers.get(key)!.push(callback);
    
    // 返回取消监听的函数
    return () => {
      const watchers = this.watchers.get(key);
      if (watchers) {
        const index = watchers.indexOf(callback);
        if (index !== -1) {
          watchers.splice(index, 1);
        }
      }
    };
  }
  
  private async loadUserConfig(): Promise<void> {
    try {
      const userConfigPath = this.getUserConfigPath();
      const configData = await fs.readFile(userConfigPath, 'utf8');
      const userConfig = JSON.parse(configData);
      
      // 合并用户配置
      this.config = { ...this.config, ...userConfig };
    } catch (error) {
      // 用户配置文件不存在或损坏，使用默认配置
    }
  }
  
  private async loadWorkspaceConfig(): Promise<void> {
    const workspaceConfig = vscode.workspace.getConfiguration('serialStudio');
    
    // 将 VSCode 配置映射到内部配置
    const mappedConfig = this.mapVSCodeConfig(workspaceConfig);
    this.config = { ...this.config, ...mappedConfig };
  }
  
  private async saveUserConfig(): Promise<void> {
    try {
      const userConfigPath = this.getUserConfigPath();
      const configData = JSON.stringify(this.config, null, 2);
      await fs.writeFile(userConfigPath, configData, 'utf8');
    } catch (error) {
      console.error('Failed to save user config:', error);
    }
  }
  
  private setupVSCodeConfigWatcher(): void {
    vscode.workspace.onDidChangeConfiguration((event) => {
      if (event.affectsConfiguration('serialStudio')) {
        this.loadWorkspaceConfig();
      }
    });
  }
  
  private notifyWatchers(key: string, value: any): void {
    const watchers = this.watchers.get(key) || [];
    watchers.forEach(watcher => watcher(value, key));
    
    // 通知父级键的监听器
    const parentKey = key.split('.').slice(0, -1).join('.');
    if (parentKey) {
      this.notifyWatchers(parentKey, this.get(parentKey));
    }
  }
}

// 配置接口定义
interface AppConfig {
  theme: ThemeConfig;
  language: string;
  communication: CommunicationConfig;
  visualization: VisualizationConfig;
  performance: PerformanceConfig;
  editor: EditorConfig;
  license: LicenseConfig;
  updates: UpdateConfig;
}

interface CommunicationConfig {
  defaultBaudRate: number;
  timeout: number;
  bufferSize: number;
  autoReconnect: boolean;
  reconnectDelay: number;
  maxReconnectAttempts: number;
}

interface VisualizationConfig {
  maxDataPoints: number;
  updateInterval: number;
  theme: string;
  enableAnimations: boolean;
  showGrid: boolean;
  showLegend: boolean;
}

interface PerformanceConfig {
  enableWebWorkers: boolean;
  enableDataCompression: boolean;
  enableVirtualScrolling: boolean;
  maxMemoryUsage: number;
  optimizeForLargeDatasets: boolean;
}

interface EditorConfig {
  fontSize: number;
  fontFamily: string;
  tabSize: number;
  wordWrap: boolean;
  enableSyntaxHighlighting: boolean;
  theme: string;
}

type ConfigWatcher = (value: any, key: string) => void;

// 默认配置
const defaultConfig: AppConfig = {
  theme: {
    name: 'auto',
    type: 'light',
    colors: getLightColors(),
    fonts: getDefaultFonts(),
    spacing: getDefaultSpacing(),
    components: getDefaultComponents()
  },
  language: 'en',
  communication: {
    defaultBaudRate: 9600,
    timeout: 5000,
    bufferSize: 4096,
    autoReconnect: true,
    reconnectDelay: 3000,
    maxReconnectAttempts: 5
  },
  visualization: {
    maxDataPoints: 1000,
    updateInterval: 50,
    theme: 'auto',
    enableAnimations: true,
    showGrid: true,
    showLegend: true
  },
  performance: {
    enableWebWorkers: true,
    enableDataCompression: true,
    enableVirtualScrolling: true,
    maxMemoryUsage: 512, // MB
    optimizeForLargeDatasets: false
  },
  editor: {
    fontSize: 14,
    fontFamily: 'Monaco, Menlo, monospace',
    tabSize: 2,
    wordWrap: true,
    enableSyntaxHighlighting: true,
    theme: 'auto'
  },
  license: {
    type: 'free',
    checkInterval: 24 * 60 * 60 * 1000 // 24小时
  },
  updates: {
    channel: 'stable',
    autoCheck: true,
    checkInterval: 24 * 60 * 60 * 1000 // 24小时
  }
};
```

## 8. 测试和调试支持

### 8.1 调试工具集成

```typescript
// utils/debugManager.ts
export class DebugManager {
  private static instance: DebugManager;
  private debugLevel: 'none' | 'error' | 'warn' | 'info' | 'debug' = 'info';
  private logBuffer: LogEntry[] = [];
  private maxLogEntries = 1000;
  
  static getInstance(): DebugManager {
    if (!this.instance) {
      this.instance = new DebugManager();
    }
    return this.instance;
  }
  
  setDebugLevel(level: 'none' | 'error' | 'warn' | 'info' | 'debug'): void {
    this.debugLevel = level;
  }
  
  log(level: LogLevel, message: string, context?: any): void {
    if (!this.shouldLog(level)) return;
    
    const entry: LogEntry = {
      timestamp: new Date(),
      level,
      message,
      context
    };
    
    this.logBuffer.push(entry);
    
    // 限制日志缓冲区大小
    if (this.logBuffer.length > this.maxLogEntries) {
      this.logBuffer.shift();
    }
    
    // 输出到控制台
    this.outputToConsole(entry);
    
    // 发送到 VSCode 调试控制台
    this.outputToVSCode(entry);
  }
  
  debug(message: string, context?: any): void {
    this.log('debug', message, context);
  }
  
  info(message: string, context?: any): void {
    this.log('info', message, context);
  }
  
  warn(message: string, context?: any): void {
    this.log('warn', message, context);
  }
  
  error(message: string, context?: any): void {
    this.log('error', message, context);
  }
  
  exportLogs(): string {
    return JSON.stringify(this.logBuffer, null, 2);
  }
  
  clearLogs(): void {
    this.logBuffer = [];
  }
  
  private shouldLog(level: LogLevel): boolean {
    const levels = ['none', 'error', 'warn', 'info', 'debug'];
    const currentIndex = levels.indexOf(this.debugLevel);
    const messageIndex = levels.indexOf(level);
    
    return messageIndex <= currentIndex && currentIndex > 0;
  }
  
  private outputToConsole(entry: LogEntry): void {
    const timestamp = entry.timestamp.toISOString();
    const message = `[${timestamp}] [${entry.level.toUpperCase()}] ${entry.message}`;
    
    switch (entry.level) {
      case 'error':
        console.error(message, entry.context);
        break;
      case 'warn':
        console.warn(message, entry.context);
        break;
      case 'info':
        console.info(message, entry.context);
        break;
      case 'debug':
        console.debug(message, entry.context);
        break;
    }
  }
  
  private outputToVSCode(entry: LogEntry): void {
    // 发送到 VSCode 调试控制台
    if (typeof vscode !== 'undefined') {
      vscode.postMessage({
        type: 'log',
        payload: entry
      });
    }
  }
}

type LogLevel = 'error' | 'warn' | 'info' | 'debug';

interface LogEntry {
  timestamp: Date;
  level: LogLevel;
  message: string;
  context?: any;
}
```

这个扩展模块设计文档涵盖了主题系统、多语言支持、许可管理、更新机制、插件系统、配置管理和调试工具等重要模块，为Serial-Studio VSCode插件提供了完整的支撑框架。每个模块都有详细的架构设计和代码实现示例，确保了系统的完整性和可扩展性。