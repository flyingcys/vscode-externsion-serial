# Serial-Studio VSCode æ’ä»¶æ‰©å±•æ¨¡å—è®¾è®¡

## 1. æ‰©å±•æ¨¡å—æ¦‚è¿°

åŸºäºå¯¹ Serial-Studio æºä»£ç çš„æ·±åº¦åˆ†æï¼Œæ‰©å±•æ¨¡å—æ˜¯æ”¯æŒæ’ä»¶å®Œæ•´åŠŸèƒ½çš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼ŒåŒ…æ‹¬ä¸»é¢˜ç³»ç»Ÿã€å¤šè¯­è¨€æ”¯æŒã€æ›´æ–°æœºåˆ¶ã€æ’ä»¶ç³»ç»Ÿç­‰æ ¸å¿ƒæ”¯æ’‘åŠŸèƒ½ã€‚

### 1.1 æ¨¡å—èŒè´£

- **ä¸»é¢˜ç³»ç»Ÿ**ï¼šæä¾›å®Œæ•´çš„ä¸»é¢˜åˆ‡æ¢å’Œè‡ªå®šä¹‰èƒ½åŠ›
- **å¤šè¯­è¨€æ”¯æŒ**ï¼šå®ç°å›½é™…åŒ–å’Œæœ¬åœ°åŒ–åŠŸèƒ½
- **è´¨é‡ä¿è¯**ï¼šç³»ç»Ÿæµ‹è¯•å’Œç›‘æ§åŠŸèƒ½
- **æ›´æ–°æœºåˆ¶**ï¼šè‡ªåŠ¨æ£€æŸ¥å’Œæ›´æ–°æ’ä»¶
- **æ’ä»¶ç³»ç»Ÿ**ï¼šæ”¯æŒç¬¬ä¸‰æ–¹æ‰©å±•å’Œè‡ªå®šä¹‰åŠŸèƒ½
- **é…ç½®ç®¡ç†**ï¼šç»Ÿä¸€çš„é…ç½®å­˜å‚¨å’Œç®¡ç†

### 1.2 è®¾è®¡ç›®æ ‡

- **æ¨¡å—åŒ–æ¶æ„**ï¼šå„æ‰©å±•æ¨¡å—ç‹¬ç«‹ä¸”å¯æ’æ‹”
- **æ— ç¼é›†æˆ**ï¼šä¸ VSCode ç”Ÿæ€ç³»ç»Ÿæ·±åº¦é›†æˆ
- **ç”¨æˆ·ä½“éªŒ**ï¼šæä¾›ä¸€è‡´ä¸”æµç•…çš„ç”¨æˆ·ä½“éªŒ
- **æ‰©å±•æ€§**ï¼šæ”¯æŒæœªæ¥åŠŸèƒ½æ‰©å±•å’Œå®šåˆ¶åŒ–éœ€æ±‚

## 2. ä¸»é¢˜ç³»ç»Ÿè®¾è®¡

### 2.1 ä¸»é¢˜æ¶æ„

```typescript
// stores/theme.ts
import { defineStore } from 'pinia'
import { ref, computed, watch } from 'vue'

interface ThemeConfig {
  name: string;
  type: 'light' | 'dark';
  colors: ThemeColors;
  fonts: ThemeFonts;
  spacing: ThemeSpacing;
  components: ComponentTheme;
}

interface ThemeColors {
  // åŸºç¡€è‰²å½©
  primary: string;
  secondary: string;
  success: string;
  warning: string;
  danger: string;
  info: string;
  
  // èƒŒæ™¯è‰²
  background: string;
  surface: string;
  overlay: string;
  
  // æ–‡æœ¬è‰²
  text: string;
  textSecondary: string;
  textDisabled: string;
  
  // è¾¹æ¡†è‰²
  border: string;
  borderHover: string;
  borderActive: string;
}

interface ThemeFonts {
  base: FontConfig;
  mono: FontConfig;
  heading: FontConfig;
}

interface FontConfig {
  family: string;
  size: string;
  weight: number;
  lineHeight: number;
}

interface ThemeSpacing {
  xs: string;
  sm: string;
  md: string;
  lg: string;
  xl: string;
}

interface ComponentTheme {
  button: ButtonTheme;
  input: InputTheme;
  card: CardTheme;
  chart: ChartTheme;
}

export const useThemeStore = defineStore('theme', () => {
  const currentTheme = ref<ThemeConfig>(getDefaultTheme());
  const systemTheme = ref<'light' | 'dark'>('light');
  const customThemes = ref<ThemeConfig[]>([]);
  
  // ç›‘å¬ç³»ç»Ÿä¸»é¢˜å˜åŒ–
  const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
  
  const initializeTheme = () => {
    systemTheme.value = mediaQuery.matches ? 'dark' : 'light';
    
    mediaQuery.addEventListener('change', (e) => {
      systemTheme.value = e.matches ? 'dark' : 'light';
      if (currentTheme.value.name === 'auto') {
        applyTheme();
      }
    });
    
    // åŒæ­¥ VSCode ä¸»é¢˜
    syncWithVSCodeTheme();
  };
  
  const applyTheme = () => {
    const theme = getEffectiveTheme();
    
    // åº”ç”¨ CSS å˜é‡
    const root = document.documentElement;
    Object.entries(theme.colors).forEach(([key, value]) => {
      root.style.setProperty(`--theme-${key}`, value);
    });
    
    // åº”ç”¨å­—ä½“
    Object.entries(theme.fonts).forEach(([type, font]) => {
      root.style.setProperty(`--font-${type}-family`, font.family);
      root.style.setProperty(`--font-${type}-size`, font.size);
      root.style.setProperty(`--font-${type}-weight`, font.weight.toString());
      root.style.setProperty(`--font-${type}-line-height`, font.lineHeight.toString());
    });
    
    // åº”ç”¨é—´è·
    Object.entries(theme.spacing).forEach(([key, value]) => {
      root.style.setProperty(`--spacing-${key}`, value);
    });
    
    // åŒæ­¥åˆ° Element Plus
    syncElementPlusTheme(theme);
    
    // é€šçŸ¥ç»„ä»¶æ›´æ–°
    notifyThemeChange(theme);
  };
  
  const syncWithVSCodeTheme = () => {
    // ç›‘å¬ VSCode ä¸»é¢˜å˜åŒ–
    vscode.postMessage({
      type: 'getTheme'
    });
    
    window.addEventListener('message', (event) => {
      const { type, payload } = event.data;
      if (type === 'themeChanged') {
        adaptToVSCodeTheme(payload);
      }
    });
  };
  
  const getEffectiveTheme = (): ThemeConfig => {
    if (currentTheme.value.name === 'auto') {
      return systemTheme.value === 'dark' ? getDarkTheme() : getLightTheme();
    }
    return currentTheme.value;
  };
  
  const setTheme = (theme: ThemeConfig | string) => {
    if (typeof theme === 'string') {
      const found = predefinedThemes.find(t => t.name === theme);
      if (found) {
        currentTheme.value = found;
      }
    } else {
      currentTheme.value = theme;
    }
    
    applyTheme();
    saveThemePreference();
  };
  
  const createCustomTheme = (baseTheme: ThemeConfig, customizations: Partial<ThemeConfig>): ThemeConfig => {
    return {
      ...baseTheme,
      ...customizations,
      colors: { ...baseTheme.colors, ...customizations.colors },
      fonts: { ...baseTheme.fonts, ...customizations.fonts },
      spacing: { ...baseTheme.spacing, ...customizations.spacing }
    };
  };
  
  const exportTheme = (): string => {
    return JSON.stringify(currentTheme.value, null, 2);
  };
  
  const importTheme = (themeJson: string): boolean => {
    try {
      const theme = JSON.parse(themeJson) as ThemeConfig;
      if (validateTheme(theme)) {
        customThemes.value.push(theme);
        setTheme(theme);
        return true;
      }
    } catch (error) {
      console.error('Failed to import theme:', error);
    }
    return false;
  };
  
  return {
    currentTheme,
    systemTheme,
    customThemes,
    initializeTheme,
    setTheme,
    createCustomTheme,
    exportTheme,
    importTheme,
    getEffectiveTheme
  };
});

// é¢„å®šä¹‰ä¸»é¢˜
const predefinedThemes: ThemeConfig[] = [
  {
    name: 'auto',
    type: 'light',
    colors: getLightColors(),
    fonts: getDefaultFonts(),
    spacing: getDefaultSpacing(),
    components: getDefaultComponents()
  },
  {
    name: 'light',
    type: 'light',
    colors: getLightColors(),
    fonts: getDefaultFonts(),
    spacing: getDefaultSpacing(),
    components: getDefaultComponents()
  },
  {
    name: 'dark',
    type: 'dark',
    colors: getDarkColors(),
    fonts: getDefaultFonts(),
    spacing: getDefaultSpacing(),
    components: getDefaultComponents()
  },
  {
    name: 'vscode-default',
    type: 'light',
    colors: getVSCodeLightColors(),
    fonts: getVSCodeFonts(),
    spacing: getDefaultSpacing(),
    components: getVSCodeComponents()
  },
  {
    name: 'vscode-dark',
    type: 'dark',
    colors: getVSCodeDarkColors(),
    fonts: getVSCodeFonts(),
    spacing: getDefaultSpacing(),
    components: getVSCodeComponents()
  }
];
```

### 2.2 ä¸»é¢˜é…ç½®ç³»ç»Ÿ

```typescript
// utils/themeManager.ts
export class ThemeManager {
  private static instance: ThemeManager;
  private themeStore = useThemeStore();
  
  static getInstance(): ThemeManager {
    if (!this.instance) {
      this.instance = new ThemeManager();
    }
    return this.instance;
  }
  
  // ä¸»é¢˜è‰²ç”Ÿæˆå™¨
  generateColorPalette(primaryColor: string): ThemeColors {
    const primary = new Color(primaryColor);
    
    return {
      primary: primaryColor,
      secondary: primary.lighten(0.1).hex(),
      success: '#67c23a',
      warning: '#e6a23c',
      danger: '#f56c6c',
      info: '#909399',
      
      background: primary.lightness(0.98).hex(),
      surface: primary.lightness(0.95).hex(),
      overlay: primary.alpha(0.8).hex(),
      
      text: primary.lightness(0.1).hex(),
      textSecondary: primary.lightness(0.3).hex(),
      textDisabled: primary.lightness(0.6).hex(),
      
      border: primary.lightness(0.85).hex(),
      borderHover: primary.lightness(0.75).hex(),
      borderActive: primary.lightness(0.65).hex()
    };
  }
  
  // å“åº”å¼è®¾è®¡é€‚é…
  getResponsiveConfig(): ResponsiveConfig {
    const viewport = getViewportSize();
    
    if (viewport.width < 768) {
      return {
        spacing: { xs: '4px', sm: '8px', md: '12px', lg: '16px', xl: '20px' },
        fonts: { base: { size: '14px' }, mono: { size: '12px' } }
      };
    } else if (viewport.width < 1200) {
      return {
        spacing: { xs: '6px', sm: '12px', md: '16px', lg: '20px', xl: '24px' },
        fonts: { base: { size: '16px' }, mono: { size: '14px' } }
      };
    } else {
      return {
        spacing: { xs: '8px', sm: '16px', md: '20px', lg: '24px', xl: '32px' },
        fonts: { base: { size: '16px' }, mono: { size: '14px' } }
      };
    }
  }
  
  // å¯è®¿é—®æ€§æ£€æŸ¥
  validateAccessibility(theme: ThemeConfig): AccessibilityReport {
    const report: AccessibilityReport = {
      contrastRatios: {},
      recommendations: [],
      passed: true
    };
    
    // æ£€æŸ¥é¢œè‰²å¯¹æ¯”åº¦
    const textContrast = getContrastRatio(theme.colors.text, theme.colors.background);
    report.contrastRatios.text = textContrast;
    
    if (textContrast < 4.5) {
      report.passed = false;
      report.recommendations.push('æ–‡æœ¬é¢œè‰²å¯¹æ¯”åº¦ä¸è¶³ï¼Œå»ºè®®è°ƒæ•´');
    }
    
    // æ£€æŸ¥å…¶ä»–å¯è®¿é—®æ€§è¦æ±‚
    validateFontSizes(theme.fonts, report);
    validateColorBlindness(theme.colors, report);
    
    return report;
  }
}

interface ResponsiveConfig {
  spacing: Partial<ThemeSpacing>;
  fonts: Partial<ThemeFonts>;
}

interface AccessibilityReport {
  contrastRatios: Record<string, number>;
  recommendations: string[];
  passed: boolean;
}
```

## 3. å¤šè¯­è¨€æ”¯æŒç³»ç»Ÿ

### 3.1 å›½é™…åŒ–æ¶æ„

```typescript
// stores/i18n.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

interface LocaleConfig {
  code: string;
  name: string;
  nativeName: string;
  flag: string;
  rtl: boolean;
  translations: Record<string, any>;
}

export const useI18nStore = defineStore('i18n', () => {
  const currentLocale = ref<string>('en');
  const availableLocales = ref<LocaleConfig[]>([]);
  const translations = ref<Record<string, Record<string, any>>>({});
  const fallbackLocale = ref<string>('en');
  
  const initializeI18n = async () => {
    // åŠ è½½æ”¯æŒçš„è¯­è¨€åˆ—è¡¨
    await loadAvailableLocales();
    
    // æ£€æµ‹ç”¨æˆ·é¦–é€‰è¯­è¨€
    const preferredLocale = detectUserLocale();
    await setLocale(preferredLocale);
    
    // ç›‘å¬ VSCode è¯­è¨€å˜åŒ–
    listenToVSCodeLocaleChanges();
  };
  
  const detectUserLocale = (): string => {
    // 1. æ£€æŸ¥ VSCode è®¾ç½®
    const vscodeLocale = getVSCodeLocale();
    if (vscodeLocale && isLocaleSupported(vscodeLocale)) {
      return vscodeLocale;
    }
    
    // 2. æ£€æŸ¥æµè§ˆå™¨è¯­è¨€
    const browserLocale = navigator.language.split('-')[0];
    if (isLocaleSupported(browserLocale)) {
      return browserLocale;
    }
    
    // 3. ä½¿ç”¨é»˜è®¤è¯­è¨€
    return fallbackLocale.value;
  };
  
  const loadAvailableLocales = async () => {
    try {
      const response = await fetch('/locales/index.json');
      availableLocales.value = await response.json();
    } catch (error) {
      console.error('Failed to load available locales:', error);
    }
  };
  
  const loadTranslations = async (locale: string): Promise<Record<string, any>> => {
    if (translations.value[locale]) {
      return translations.value[locale];
    }
    
    try {
      const response = await fetch(`/locales/${locale}.json`);
      const localeTranslations = await response.json();
      translations.value[locale] = localeTranslations;
      return localeTranslations;
    } catch (error) {
      console.error(`Failed to load translations for ${locale}:`, error);
      return {};
    }
  };
  
  const setLocale = async (locale: string) => {
    if (!isLocaleSupported(locale)) {
      console.warn(`Locale ${locale} is not supported, falling back to ${fallbackLocale.value}`);
      locale = fallbackLocale.value;
    }
    
    await loadTranslations(locale);
    currentLocale.value = locale;
    
    // æ›´æ–° document è¯­è¨€å±æ€§
    document.documentElement.lang = locale;
    
    // æ›´æ–° RTL æ–¹å‘
    const localeConfig = getLocaleConfig(locale);
    document.documentElement.dir = localeConfig?.rtl ? 'rtl' : 'ltr';
    
    // ä¿å­˜ç”¨æˆ·é€‰æ‹©
    saveLocalePreference(locale);
    
    // é€šçŸ¥ VSCode
    notifyVSCodeLocaleChange(locale);
  };
  
  const t = (key: string, params?: Record<string, any>): string => {
    const currentTranslations = translations.value[currentLocale.value] || {};
    const fallbackTranslations = translations.value[fallbackLocale.value] || {};
    
    // é€’å½’è·å–åµŒå¥—çš„ç¿»è¯‘
    const getValue = (obj: any, path: string): string => {
      return path.split('.').reduce((o, k) => (o && o[k]) || null, obj);
    };
    
    let translation = getValue(currentTranslations, key) || getValue(fallbackTranslations, key) || key;
    
    // å‚æ•°æ›¿æ¢
    if (params && typeof translation === 'string') {
      Object.entries(params).forEach(([param, value]) => {
        translation = translation.replace(new RegExp(`\\{${param}\\}`, 'g'), String(value));
      });
    }
    
    return translation;
  };
  
  const isLocaleSupported = (locale: string): boolean => {
    return availableLocales.value.some(l => l.code === locale);
  };
  
  const getLocaleConfig = (locale: string): LocaleConfig | undefined => {
    return availableLocales.value.find(l => l.code === locale);
  };
  
  return {
    currentLocale,
    availableLocales,
    initializeI18n,
    setLocale,
    t,
    isLocaleSupported,
    getLocaleConfig
  };
});
```

### 3.2 ç¿»è¯‘ç®¡ç†ç³»ç»Ÿ

```typescript
// utils/translationManager.ts
export class TranslationManager {
  private static instance: TranslationManager;
  private i18nStore = useI18nStore();
  
  static getInstance(): TranslationManager {
    if (!this.instance) {
      this.instance = new TranslationManager();
    }
    return this.instance;
  }
  
  // åŠ¨æ€åŠ è½½ç¿»è¯‘
  async loadNamespaceTranslations(namespace: string, locale?: string): Promise<void> {
    const targetLocale = locale || this.i18nStore.currentLocale;
    
    try {
      const response = await fetch(`/locales/${targetLocale}/${namespace}.json`);
      const namespaceTranslations = await response.json();
      
      // åˆå¹¶åˆ°ä¸»ç¿»è¯‘å¯¹è±¡
      const currentTranslations = this.i18nStore.translations[targetLocale] || {};
      currentTranslations[namespace] = namespaceTranslations;
    } catch (error) {
      console.error(`Failed to load namespace ${namespace} for locale ${targetLocale}:`, error);
    }
  }
  
  // å¤æ•°å½¢å¼å¤„ç†
  plural(key: string, count: number, params?: Record<string, any>): string {
    const pluralKey = this.getPluralKey(key, count);
    return this.i18nStore.t(pluralKey, { ...params, count });
  }
  
  private getPluralKey(key: string, count: number): string {
    const locale = this.i18nStore.currentLocale;
    const rules = getPluralRules(locale);
    
    if (count === 0 && rules.zero) return `${key}.zero`;
    if (count === 1 && rules.one) return `${key}.one`;
    if (count === 2 && rules.two) return `${key}.two`;
    if (count < 5 && rules.few) return `${key}.few`;
    return `${key}.other`;
  }
  
  // æ—¥æœŸæ—¶é—´æ ¼å¼åŒ–
  formatDate(date: Date, format: 'short' | 'medium' | 'long' | 'full' = 'medium'): string {
    const locale = this.i18nStore.currentLocale;
    const options = getDateFormatOptions(format);
    
    return new Intl.DateTimeFormat(locale, options).format(date);
  }
  
  // æ•°å­—æ ¼å¼åŒ–
  formatNumber(number: number, options?: Intl.NumberFormatOptions): string {
    const locale = this.i18nStore.currentLocale;
    return new Intl.NumberFormat(locale, options).format(number);
  }
  
  // è´§å¸æ ¼å¼åŒ–
  formatCurrency(amount: number, currency: string): string {
    const locale = this.i18nStore.currentLocale;
    return new Intl.NumberFormat(locale, {
      style: 'currency',
      currency
    }).format(amount);
  }
  
  // ç›¸å¯¹æ—¶é—´æ ¼å¼åŒ–
  formatRelativeTime(date: Date): string {
    const locale = this.i18nStore.currentLocale;
    const rtf = new Intl.RelativeTimeFormat(locale, { numeric: 'auto' });
    
    const diff = date.getTime() - Date.now();
    const absDiff = Math.abs(diff);
    
    if (absDiff < 60000) return rtf.format(Math.round(diff / 1000), 'second');
    if (absDiff < 3600000) return rtf.format(Math.round(diff / 60000), 'minute');
    if (absDiff < 86400000) return rtf.format(Math.round(diff / 3600000), 'hour');
    return rtf.format(Math.round(diff / 86400000), 'day');
  }
}

// æ”¯æŒçš„è¯­è¨€é…ç½®
const supportedLocales: LocaleConfig[] = [
  {
    code: 'en',
    name: 'English',
    nativeName: 'English',
    flag: 'ğŸ‡ºğŸ‡¸',
    rtl: false,
    translations: {}
  },
  {
    code: 'zh',
    name: 'Chinese',
    nativeName: 'ä¸­æ–‡',
    flag: 'ğŸ‡¨ğŸ‡³',
    rtl: false,
    translations: {}
  },
  {
    code: 'ja',
    name: 'Japanese',
    nativeName: 'æ—¥æœ¬èª',
    flag: 'ğŸ‡¯ğŸ‡µ',
    rtl: false,
    translations: {}
  },
  {
    code: 'ko',
    name: 'Korean',
    nativeName: 'í•œêµ­ì–´',
    flag: 'ğŸ‡°ğŸ‡·',
    rtl: false,
    translations: {}
  },
  {
    code: 'es',
    name: 'Spanish',
    nativeName: 'EspaÃ±ol',
    flag: 'ğŸ‡ªğŸ‡¸',
    rtl: false,
    translations: {}
  },
  {
    code: 'fr',
    name: 'French',
    nativeName: 'FranÃ§ais',
    flag: 'ğŸ‡«ğŸ‡·',
    rtl: false,
    translations: {}
  },
  {
    code: 'de',
    name: 'German',
    nativeName: 'Deutsch',
    flag: 'ğŸ‡©ğŸ‡ª',
    rtl: false,
    translations: {}
  },
  {
    code: 'ru',
    name: 'Russian',
    nativeName: 'Ğ ÑƒÑÑĞºĞ¸Ğ¹',
    flag: 'ğŸ‡·ğŸ‡º',
    rtl: false,
    translations: {}
  },
  {
    code: 'ar',
    name: 'Arabic',
    nativeName: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
    flag: 'ğŸ‡¸ğŸ‡¦',
    rtl: true,
    translations: {}
  }
];
```

## 4. è´¨é‡ä¿è¯ç³»ç»Ÿ

### 4.1 æµ‹è¯•æ¡†æ¶æ¶æ„

```typescript
// stores/testing.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

interface TestResult {
  testId: string;
  name: string;
  status: 'pending' | 'running' | 'passed' | 'failed';
  duration?: number;
  error?: string;
  timestamp?: Date;
}

interface TestSuite {
  id: string;
  name: string;
  description: string;
  tests: TestResult[];
  coverage?: number;
}

export const useTestingStore = defineStore('testing', () => {
  const currentLicense = ref<LicenseInfo>({
    type: 'free',
    features: ['basic-serial', 'basic-visualization']
  });
  
  const availableFeatures = ref<FeatureConfig[]>([
    {
      id: 'basic-serial',
      name: 'Basic Serial Communication',
      description: 'UART/COM port communication',
      requiresLicense: false,
      licenseTypes: []
    },
    {
      id: 'basic-visualization',
      name: 'Basic Visualization',
      description: 'Plot, Gauge, Bar charts',
      requiresLicense: false,
      licenseTypes: []
    },
    {
      id: 'network-communication',
      name: 'Network Communication',
      description: 'TCP/UDP communication',
      requiresLicense: false,
      licenseTypes: []
    },
    {
      id: 'bluetooth-communication',
      name: 'Bluetooth LE Communication',
      description: 'Bluetooth Low Energy support',
      requiresLicense: false,
      licenseTypes: []
    },
    {
      id: 'advanced-visualization',
      name: 'Advanced Visualization',
      description: '3D plots, FFT analysis, GPS maps',
      requiresLicense: true,
      licenseTypes: ['trial', 'commercial']
    },
    {
      id: 'audio-communication',
      name: 'Audio Communication',
      description: 'Audio stream input',
      requiresLicense: true,
      licenseTypes: ['commercial']
    },
    {
      id: 'modbus-communication',
      name: 'Modbus Communication',
      description: 'Modbus protocol support',
      requiresLicense: true,
      licenseTypes: ['commercial']
    },
    {
      id: 'canbus-communication',
      name: 'CAN Bus Communication',
      description: 'CAN bus protocol support',
      requiresLicense: true,
      licenseTypes: ['commercial']
    },
    {
      id: 'mqtt-integration',
      name: 'MQTT Integration',
      description: 'MQTT client functionality',
      requiresLicense: true,
      licenseTypes: ['trial', 'commercial']
    },
    {
      id: 'cloud-sync',
      name: 'Cloud Synchronization',
      description: 'Cloud-based project sync',
      requiresLicense: true,
      licenseTypes: ['commercial']
    }
  ]);
  
  const isFeatureAvailable = (featureId: string): boolean => {
    const feature = availableFeatures.value.find(f => f.id === featureId);
    if (!feature) return false;
    
    // å…è´¹åŠŸèƒ½å§‹ç»ˆå¯ç”¨
    if (!feature.requiresLicense) return true;
    
    // æ£€æŸ¥å½“å‰è®¸å¯æ˜¯å¦æ”¯æŒè¯¥åŠŸèƒ½
    return feature.licenseTypes.includes(currentLicense.value.type as any);
  };
  
  const getAvailableFeatures = computed(() => {
    return availableFeatures.value.filter(feature => 
      !feature.requiresLicense || 
      feature.licenseTypes.includes(currentLicense.value.type as any)
    );
  });
  
  const getRestrictedFeatures = computed(() => {
    return availableFeatures.value.filter(feature => 
      feature.requiresLicense && 
      !feature.licenseTypes.includes(currentLicense.value.type as any)
    );
  });
  
  const isTrialExpired = computed(() => {
    if (currentLicense.value.type !== 'trial') return false;
    if (!currentLicense.value.expirationDate) return false;
    
    return new Date() > currentLicense.value.expirationDate;
  });
  
  const trialDaysRemaining = computed(() => {
    if (currentLicense.value.type !== 'trial') return 0;
    if (!currentLicense.value.expirationDate) return 0;
    
    const diff = currentLicense.value.expirationDate.getTime() - Date.now();
    return Math.max(0, Math.ceil(diff / (1000 * 60 * 60 * 24)));
  });
  
  const activateLicense = async (licenseKey: string): Promise<boolean> => {
    try {
      const response = await validateLicenseKey(licenseKey);
      if (response.valid) {
        currentLicense.value = {
          type: response.type,
          features: response.features,
          expirationDate: response.expirationDate,
          activationKey: licenseKey,
          userInfo: response.userInfo
        };
        
        saveLicenseInfo();
        return true;
      }
    } catch (error) {
      console.error('License activation failed:', error);
    }
    
    return false;
  };
  
  const startTrial = async (): Promise<boolean> => {
    try {
      const trialInfo = await requestTrialLicense();
      if (trialInfo) {
        currentLicense.value = {
          type: 'trial',
          features: trialInfo.features,
          expirationDate: trialInfo.expirationDate
        };
        
        saveLicenseInfo();
        return true;
      }
    } catch (error) {
      console.error('Trial activation failed:', error);
    }
    
    return false;
  };
  
  const checkLicenseStatus = async (): Promise<void> => {
    if (currentLicense.value.activationKey) {
      const isValid = await validateLicenseKey(currentLicense.value.activationKey);
      if (!isValid.valid) {
        // è®¸å¯è¯æ— æ•ˆï¼Œå›é€€åˆ°å…è´¹ç‰ˆ
        currentLicense.value = {
          type: 'free',
          features: ['basic-serial', 'basic-visualization']
        };
        saveLicenseInfo();
      }
    }
  };
  
  return {
    currentLicense,
    availableFeatures,
    isFeatureAvailable,
    getAvailableFeatures,
    getRestrictedFeatures,
    isTrialExpired,
    trialDaysRemaining,
    activateLicense,
    startTrial,
    checkLicenseStatus
  };
});
```

### 4.2 åŠŸèƒ½é™åˆ¶ç»„ä»¶

```vue
<!-- FeatureGate.vue -->
<template>
  <div class="feature-gate">
    <slot v-if="hasAccess" />
    
    <div v-else class="feature-restricted">
      <div class="restriction-overlay">
        <div class="restriction-content">
          <el-icon class="restriction-icon"><Lock /></el-icon>
          
          <h3 class="restriction-title">{{ t('license.featureRestricted') }}</h3>
          
          <p class="restriction-description">
            {{ t('license.featureDescription', { feature: featureName }) }}
          </p>
          
          <div class="restriction-actions">
            <el-button 
              v-if="showTrialOption && !licenseStore.isTrialExpired"
              type="primary"
              @click="startTrial"
            >
              {{ t('license.startTrial') }}
            </el-button>
            
            <el-button 
              type="primary"
              @click="showLicenseDialog"
            >
              {{ t('license.upgradeLicense') }}
            </el-button>
            
            <el-button 
              type="info"
              @click="learnMore"
            >
              {{ t('license.learnMore') }}
            </el-button>
          </div>
        </div>
      </div>
    </div>
    
    <!-- è®¸å¯è¯æ¿€æ´»å¯¹è¯æ¡† -->
    <LicenseActivationDialog 
      v-model="showLicenseActivation"
      @activated="onLicenseActivated"
    />
  </div>
</template>

<script setup lang="ts">
import { computed, ref } from 'vue';
import { useLicenseStore } from '@/stores/license';
import { useI18nStore } from '@/stores/i18n';
import LicenseActivationDialog from './LicenseActivationDialog.vue';

interface Props {
  feature: string;
  showTrialOption?: boolean;
  fallbackContent?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  showTrialOption: true,
  fallbackContent: false
});

const licenseStore = useLicenseStore();
const { t } = useI18nStore();

const showLicenseActivation = ref(false);

const hasAccess = computed(() => {
  return licenseStore.isFeatureAvailable(props.feature);
});

const featureName = computed(() => {
  const feature = licenseStore.availableFeatures.find(f => f.id === props.feature);
  return feature?.name || props.feature;
});

const startTrial = async () => {
  const success = await licenseStore.startTrial();
  if (success) {
    ElMessage.success(t('license.trialStarted'));
  } else {
    ElMessage.error(t('license.trialFailed'));
  }
};

const showLicenseDialog = () => {
  showLicenseActivation.value = true;
};

const learnMore = () => {
  window.open('https://serial-studio.com/pricing', '_blank');
};

const onLicenseActivated = () => {
  ElMessage.success(t('license.activationSuccess'));
};
</script>

<style scoped>
.feature-gate {
  position: relative;
}

.feature-restricted {
  position: relative;
  min-height: 200px;
}

.restriction-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(255, 255, 255, 0.95);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10;
}

.restriction-content {
  text-align: center;
  max-width: 400px;
  padding: 24px;
}

.restriction-icon {
  font-size: 48px;
  color: var(--el-color-warning);
  margin-bottom: 16px;
}

.restriction-title {
  margin: 0 0 12px 0;
  color: var(--el-text-color-primary);
}

.restriction-description {
  margin: 0 0 24px 0;
  color: var(--el-text-color-regular);
  line-height: 1.5;
}

.restriction-actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  flex-wrap: wrap;
}
</style>
```

## 5. æ›´æ–°æœºåˆ¶ç³»ç»Ÿ

### 5.1 è‡ªåŠ¨æ›´æ–°æ¶æ„

```typescript
// services/updateService.ts
export class UpdateService {
  private static instance: UpdateService;
  private updateChannel: 'stable' | 'beta' | 'alpha' = 'stable';
  private checkInterval: number = 24 * 60 * 60 * 1000; // 24å°æ—¶
  private updateTimer: NodeJS.Timeout | null = null;
  
  static getInstance(): UpdateService {
    if (!this.instance) {
      this.instance = new UpdateService();
    }
    return this.instance;
  }
  
  async checkForUpdates(manual: boolean = false): Promise<UpdateInfo | null> {
    try {
      const currentVersion = await this.getCurrentVersion();
      const response = await fetch(`https://api.serial-studio.com/updates/vscode/${this.updateChannel}`);
      const updateInfo: UpdateInfo = await response.json();
      
      if (this.isNewerVersion(updateInfo.version, currentVersion)) {
        if (manual || updateInfo.critical) {
          this.notifyUpdateAvailable(updateInfo);
        }
        return updateInfo;
      }
    } catch (error) {
      console.error('Failed to check for updates:', error);
    }
    
    return null;
  }
  
  async downloadAndInstallUpdate(updateInfo: UpdateInfo): Promise<boolean> {
    try {
      // æ˜¾ç¤ºä¸‹è½½è¿›åº¦
      const progressDialog = new UpdateProgressDialog();
      progressDialog.show();
      
      // ä¸‹è½½æ›´æ–°åŒ…
      const updateFile = await this.downloadUpdate(updateInfo, (progress) => {
        progressDialog.updateProgress(progress);
      });
      
      // éªŒè¯æ›´æ–°åŒ…
      const isValid = await this.verifyUpdate(updateFile, updateInfo.checksum);
      if (!isValid) {
        throw new Error('Update verification failed');
      }
      
      // å®‰è£…æ›´æ–°
      await this.installUpdate(updateFile);
      
      progressDialog.close();
      return true;
    } catch (error) {
      console.error('Update installation failed:', error);
      return false;
    }
  }
  
  private async getCurrentVersion(): Promise<string> {
    // ä» package.json æˆ– VSCode API è·å–å½“å‰ç‰ˆæœ¬
    return vscode.extensions.getExtension('serial-studio.serial-visualization')?.packageJSON.version || '0.0.0';
  }
  
  private isNewerVersion(remoteVersion: string, currentVersion: string): boolean {
    return semver.gt(remoteVersion, currentVersion);
  }
  
  private async downloadUpdate(updateInfo: UpdateInfo, onProgress: (progress: number) => void): Promise<string> {
    const response = await fetch(updateInfo.downloadUrl);
    const total = parseInt(response.headers.get('content-length') || '0');
    let downloaded = 0;
    
    const chunks: Uint8Array[] = [];
    const reader = response.body?.getReader();
    
    while (true) {
      const { done, value } = await reader!.read();
      if (done) break;
      
      chunks.push(value);
      downloaded += value.length;
      onProgress((downloaded / total) * 100);
    }
    
    // ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶
    const updateFile = path.join(os.tmpdir(), `serial-studio-update-${updateInfo.version}.vsix`);
    const buffer = Buffer.concat(chunks);
    await fs.writeFile(updateFile, buffer);
    
    return updateFile;
  }
  
  private async verifyUpdate(filePath: string, expectedChecksum: string): Promise<boolean> {
    const buffer = await fs.readFile(filePath);
    const hash = crypto.createHash('sha256').update(buffer).digest('hex');
    return hash === expectedChecksum;
  }
  
  private async installUpdate(filePath: string): Promise<void> {
    // ä½¿ç”¨ VSCode å‘½ä»¤å®‰è£…æ‰©å±•
    await vscode.commands.executeCommand('workbench.extensions.installExtension', vscode.Uri.file(filePath));
  }
  
  private notifyUpdateAvailable(updateInfo: UpdateInfo): void {
    const message = `Serial Studio ${updateInfo.version} is available. Would you like to update now?`;
    
    vscode.window.showInformationMessage(
      message,
      'Update Now',
      'View Changes',
      'Remind Later'
    ).then(async (selection) => {
      switch (selection) {
        case 'Update Now':
          await this.downloadAndInstallUpdate(updateInfo);
          break;
        case 'View Changes':
          vscode.env.openExternal(vscode.Uri.parse(updateInfo.releaseNotesUrl));
          break;
        case 'Remind Later':
          // è®¾ç½®ç¨åæé†’
          setTimeout(() => this.notifyUpdateAvailable(updateInfo), 4 * 60 * 60 * 1000);
          break;
      }
    });
  }
  
  startPeriodicCheck(): void {
    this.updateTimer = setInterval(() => {
      this.checkForUpdates(false);
    }, this.checkInterval);
  }
  
  stopPeriodicCheck(): void {
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
      this.updateTimer = null;
    }
  }
}

interface UpdateInfo {
  version: string;
  releaseDate: string;
  downloadUrl: string;
  checksum: string;
  releaseNotesUrl: string;
  critical: boolean;
  features: string[];
  bugFixes: string[];
  breakingChanges: string[];
}
```

## 6. æ’ä»¶ç³»ç»Ÿè®¾è®¡

### 6.1 æ’ä»¶æ¶æ„

```typescript
// types/plugin.ts
export interface PluginManifest {
  id: string;
  name: string;
  version: string;
  description: string;
  author: string;
  license: string;
  
  engines: {
    vscode: string;
    serialStudio: string;
  };
  
  contributes: {
    drivers?: DriverContribution[];
    widgets?: WidgetContribution[];
    parsers?: ParserContribution[];
    themes?: ThemeContribution[];
    commands?: CommandContribution[];
  };
  
  activationEvents: string[];
  main?: string;
  dependencies?: Record<string, string>;
}

export interface DriverContribution {
  id: string;
  name: string;
  protocol: string;
  configSchema: JSONSchema;
  icon?: string;
}

export interface WidgetContribution {
  id: string;
  name: string;
  type: 'dataset' | 'group';
  component: string;
  configSchema: JSONSchema;
  preview?: string;
}

export interface ParserContribution {
  id: string;
  name: string;
  description: string;
  template: string;
  examples?: string[];
}

// services/pluginManager.ts
export class PluginManager {
  private static instance: PluginManager;
  private loadedPlugins = new Map<string, LoadedPlugin>();
  private pluginRegistry = new Map<string, PluginManifest>();
  
  static getInstance(): PluginManager {
    if (!this.instance) {
      this.instance = new PluginManager();
    }
    return this.instance;
  }
  
  async loadPlugin(manifestPath: string): Promise<boolean> {
    try {
      const manifest = await this.loadManifest(manifestPath);
      await this.validatePlugin(manifest);
      
      const plugin = await this.instantiatePlugin(manifest);
      
      // æ³¨å†Œæ’ä»¶è´¡çŒ®
      await this.registerContributions(plugin);
      
      this.loadedPlugins.set(manifest.id, plugin);
      this.pluginRegistry.set(manifest.id, manifest);
      
      return true;
    } catch (error) {
      console.error(`Failed to load plugin from ${manifestPath}:`, error);
      return false;
    }
  }
  
  unloadPlugin(pluginId: string): void {
    const plugin = this.loadedPlugins.get(pluginId);
    if (plugin) {
      // å¸è½½è´¡çŒ®
      this.unregisterContributions(plugin);
      
      // è°ƒç”¨æ’ä»¶çš„æ¸…ç†æ–¹æ³•
      if (plugin.deactivate) {
        plugin.deactivate();
      }
      
      this.loadedPlugins.delete(pluginId);
      this.pluginRegistry.delete(pluginId);
    }
  }
  
  getPlugin(pluginId: string): LoadedPlugin | undefined {
    return this.loadedPlugins.get(pluginId);
  }
  
  getAvailablePlugins(): PluginManifest[] {
    return Array.from(this.pluginRegistry.values());
  }
  
  private async registerContributions(plugin: LoadedPlugin): Promise<void> {
    const manifest = plugin.manifest;
    
    // æ³¨å†Œé©±åŠ¨
    if (manifest.contributes.drivers) {
      for (const driver of manifest.contributes.drivers) {
        await this.registerDriver(driver, plugin);
      }
    }
    
    // æ³¨å†Œç»„ä»¶
    if (manifest.contributes.widgets) {
      for (const widget of manifest.contributes.widgets) {
        await this.registerWidget(widget, plugin);
      }
    }
    
    // æ³¨å†Œè§£æå™¨
    if (manifest.contributes.parsers) {
      for (const parser of manifest.contributes.parsers) {
        await this.registerParser(parser, plugin);
      }
    }
    
    // æ³¨å†Œä¸»é¢˜
    if (manifest.contributes.themes) {
      for (const theme of manifest.contributes.themes) {
        await this.registerTheme(theme, plugin);
      }
    }
  }
  
  private async registerDriver(driver: DriverContribution, plugin: LoadedPlugin): Promise<void> {
    // æ³¨å†Œåˆ°é€šä¿¡ç®¡ç†å™¨
    const driverClass = plugin.exports[driver.id];
    if (driverClass) {
      IOManager.registerDriver(driver.id, driverClass);
    }
  }
  
  private async registerWidget(widget: WidgetContribution, plugin: LoadedPlugin): Promise<void> {
    // æ³¨å†Œåˆ°ç»„ä»¶ç³»ç»Ÿ
    const component = plugin.exports[widget.component];
    if (component) {
      ComponentRegistry.register(widget.id, component);
    }
  }
}

interface LoadedPlugin {
  manifest: PluginManifest;
  exports: any;
  context: PluginContext;
  activate?: () => void;
  deactivate?: () => void;
}

interface PluginContext {
  subscriptions: vscode.Disposable[];
  globalStoragePath: string;
  workspaceStoragePath: string;
  extensionPath: string;
  logger: Logger;
}
```

## 7. é…ç½®ç®¡ç†ç³»ç»Ÿ

### 7.1 ç»Ÿä¸€é…ç½®æ¶æ„

```typescript
// services/configManager.ts
export class ConfigManager {
  private static instance: ConfigManager;
  private config = reactive<AppConfig>({});
  private watchers = new Map<string, ConfigWatcher[]>();
  
  static getInstance(): ConfigManager {
    if (!this.instance) {
      this.instance = new ConfigManager();
    }
    return this.instance;
  }
  
  async initialize(): Promise<void> {
    // åŠ è½½é»˜è®¤é…ç½®
    this.config = { ...defaultConfig };
    
    // åŠ è½½ç”¨æˆ·é…ç½®
    await this.loadUserConfig();
    
    // åŠ è½½å·¥ä½œåŒºé…ç½®
    await this.loadWorkspaceConfig();
    
    // ç›‘å¬ VSCode é…ç½®å˜åŒ–
    this.setupVSCodeConfigWatcher();
  }
  
  get<T>(key: string): T | undefined {
    return getNestedValue(this.config, key) as T;
  }
  
  set<T>(key: string, value: T): void {
    setNestedValue(this.config, key, value);
    this.saveUserConfig();
    this.notifyWatchers(key, value);
  }
  
  watch(key: string, callback: ConfigWatcher): () => void {
    if (!this.watchers.has(key)) {
      this.watchers.set(key, []);
    }
    
    this.watchers.get(key)!.push(callback);
    
    // è¿”å›å–æ¶ˆç›‘å¬çš„å‡½æ•°
    return () => {
      const watchers = this.watchers.get(key);
      if (watchers) {
        const index = watchers.indexOf(callback);
        if (index !== -1) {
          watchers.splice(index, 1);
        }
      }
    };
  }
  
  private async loadUserConfig(): Promise<void> {
    try {
      const userConfigPath = this.getUserConfigPath();
      const configData = await fs.readFile(userConfigPath, 'utf8');
      const userConfig = JSON.parse(configData);
      
      // åˆå¹¶ç”¨æˆ·é…ç½®
      this.config = { ...this.config, ...userConfig };
    } catch (error) {
      // ç”¨æˆ·é…ç½®æ–‡ä»¶ä¸å­˜åœ¨æˆ–æŸåï¼Œä½¿ç”¨é»˜è®¤é…ç½®
    }
  }
  
  private async loadWorkspaceConfig(): Promise<void> {
    const workspaceConfig = vscode.workspace.getConfiguration('serialStudio');
    
    // å°† VSCode é…ç½®æ˜ å°„åˆ°å†…éƒ¨é…ç½®
    const mappedConfig = this.mapVSCodeConfig(workspaceConfig);
    this.config = { ...this.config, ...mappedConfig };
  }
  
  private async saveUserConfig(): Promise<void> {
    try {
      const userConfigPath = this.getUserConfigPath();
      const configData = JSON.stringify(this.config, null, 2);
      await fs.writeFile(userConfigPath, configData, 'utf8');
    } catch (error) {
      console.error('Failed to save user config:', error);
    }
  }
  
  private setupVSCodeConfigWatcher(): void {
    vscode.workspace.onDidChangeConfiguration((event) => {
      if (event.affectsConfiguration('serialStudio')) {
        this.loadWorkspaceConfig();
      }
    });
  }
  
  private notifyWatchers(key: string, value: any): void {
    const watchers = this.watchers.get(key) || [];
    watchers.forEach(watcher => watcher(value, key));
    
    // é€šçŸ¥çˆ¶çº§é”®çš„ç›‘å¬å™¨
    const parentKey = key.split('.').slice(0, -1).join('.');
    if (parentKey) {
      this.notifyWatchers(parentKey, this.get(parentKey));
    }
  }
}

// é…ç½®æ¥å£å®šä¹‰
interface AppConfig {
  theme: ThemeConfig;
  language: string;
  communication: CommunicationConfig;
  visualization: VisualizationConfig;
  performance: PerformanceConfig;
  editor: EditorConfig;
  license: LicenseConfig;
  updates: UpdateConfig;
}

interface CommunicationConfig {
  defaultBaudRate: number;
  timeout: number;
  bufferSize: number;
  autoReconnect: boolean;
  reconnectDelay: number;
  maxReconnectAttempts: number;
}

interface VisualizationConfig {
  maxDataPoints: number;
  updateInterval: number;
  theme: string;
  enableAnimations: boolean;
  showGrid: boolean;
  showLegend: boolean;
}

interface PerformanceConfig {
  enableWebWorkers: boolean;
  enableDataCompression: boolean;
  enableVirtualScrolling: boolean;
  maxMemoryUsage: number;
  optimizeForLargeDatasets: boolean;
}

interface EditorConfig {
  fontSize: number;
  fontFamily: string;
  tabSize: number;
  wordWrap: boolean;
  enableSyntaxHighlighting: boolean;
  theme: string;
}

type ConfigWatcher = (value: any, key: string) => void;

// é»˜è®¤é…ç½®
const defaultConfig: AppConfig = {
  theme: {
    name: 'auto',
    type: 'light',
    colors: getLightColors(),
    fonts: getDefaultFonts(),
    spacing: getDefaultSpacing(),
    components: getDefaultComponents()
  },
  language: 'en',
  communication: {
    defaultBaudRate: 9600,
    timeout: 5000,
    bufferSize: 4096,
    autoReconnect: true,
    reconnectDelay: 3000,
    maxReconnectAttempts: 5
  },
  visualization: {
    maxDataPoints: 1000,
    updateInterval: 50,
    theme: 'auto',
    enableAnimations: true,
    showGrid: true,
    showLegend: true
  },
  performance: {
    enableWebWorkers: true,
    enableDataCompression: true,
    enableVirtualScrolling: true,
    maxMemoryUsage: 512, // MB
    optimizeForLargeDatasets: false
  },
  editor: {
    fontSize: 14,
    fontFamily: 'Monaco, Menlo, monospace',
    tabSize: 2,
    wordWrap: true,
    enableSyntaxHighlighting: true,
    theme: 'auto'
  },
  license: {
    type: 'free',
    checkInterval: 24 * 60 * 60 * 1000 // 24å°æ—¶
  },
  updates: {
    channel: 'stable',
    autoCheck: true,
    checkInterval: 24 * 60 * 60 * 1000 // 24å°æ—¶
  }
};
```

## 8. æµ‹è¯•å’Œè°ƒè¯•æ”¯æŒ

### 8.1 è°ƒè¯•å·¥å…·é›†æˆ

```typescript
// utils/debugManager.ts
export class DebugManager {
  private static instance: DebugManager;
  private debugLevel: 'none' | 'error' | 'warn' | 'info' | 'debug' = 'info';
  private logBuffer: LogEntry[] = [];
  private maxLogEntries = 1000;
  
  static getInstance(): DebugManager {
    if (!this.instance) {
      this.instance = new DebugManager();
    }
    return this.instance;
  }
  
  setDebugLevel(level: 'none' | 'error' | 'warn' | 'info' | 'debug'): void {
    this.debugLevel = level;
  }
  
  log(level: LogLevel, message: string, context?: any): void {
    if (!this.shouldLog(level)) return;
    
    const entry: LogEntry = {
      timestamp: new Date(),
      level,
      message,
      context
    };
    
    this.logBuffer.push(entry);
    
    // é™åˆ¶æ—¥å¿—ç¼“å†²åŒºå¤§å°
    if (this.logBuffer.length > this.maxLogEntries) {
      this.logBuffer.shift();
    }
    
    // è¾“å‡ºåˆ°æ§åˆ¶å°
    this.outputToConsole(entry);
    
    // å‘é€åˆ° VSCode è°ƒè¯•æ§åˆ¶å°
    this.outputToVSCode(entry);
  }
  
  debug(message: string, context?: any): void {
    this.log('debug', message, context);
  }
  
  info(message: string, context?: any): void {
    this.log('info', message, context);
  }
  
  warn(message: string, context?: any): void {
    this.log('warn', message, context);
  }
  
  error(message: string, context?: any): void {
    this.log('error', message, context);
  }
  
  exportLogs(): string {
    return JSON.stringify(this.logBuffer, null, 2);
  }
  
  clearLogs(): void {
    this.logBuffer = [];
  }
  
  private shouldLog(level: LogLevel): boolean {
    const levels = ['none', 'error', 'warn', 'info', 'debug'];
    const currentIndex = levels.indexOf(this.debugLevel);
    const messageIndex = levels.indexOf(level);
    
    return messageIndex <= currentIndex && currentIndex > 0;
  }
  
  private outputToConsole(entry: LogEntry): void {
    const timestamp = entry.timestamp.toISOString();
    const message = `[${timestamp}] [${entry.level.toUpperCase()}] ${entry.message}`;
    
    switch (entry.level) {
      case 'error':
        console.error(message, entry.context);
        break;
      case 'warn':
        console.warn(message, entry.context);
        break;
      case 'info':
        console.info(message, entry.context);
        break;
      case 'debug':
        console.debug(message, entry.context);
        break;
    }
  }
  
  private outputToVSCode(entry: LogEntry): void {
    // å‘é€åˆ° VSCode è°ƒè¯•æ§åˆ¶å°
    if (typeof vscode !== 'undefined') {
      vscode.postMessage({
        type: 'log',
        payload: entry
      });
    }
  }
}

type LogLevel = 'error' | 'warn' | 'info' | 'debug';

interface LogEntry {
  timestamp: Date;
  level: LogLevel;
  message: string;
  context?: any;
}
```

è¿™ä¸ªæ‰©å±•æ¨¡å—è®¾è®¡æ–‡æ¡£æ¶µç›–äº†ä¸»é¢˜ç³»ç»Ÿã€å¤šè¯­è¨€æ”¯æŒã€è®¸å¯ç®¡ç†ã€æ›´æ–°æœºåˆ¶ã€æ’ä»¶ç³»ç»Ÿã€é…ç½®ç®¡ç†å’Œè°ƒè¯•å·¥å…·ç­‰é‡è¦æ¨¡å—ï¼Œä¸ºSerial-Studio VSCodeæ’ä»¶æä¾›äº†å®Œæ•´çš„æ”¯æ’‘æ¡†æ¶ã€‚æ¯ä¸ªæ¨¡å—éƒ½æœ‰è¯¦ç»†çš„æ¶æ„è®¾è®¡å’Œä»£ç å®ç°ç¤ºä¾‹ï¼Œç¡®ä¿äº†ç³»ç»Ÿçš„å®Œæ•´æ€§å’Œå¯æ‰©å±•æ€§ã€‚