# Serial-Studio VSCode 插件数据导出模块设计

## 1. 数据导出模块概述

数据导出模块是 Serial-Studio VSCode 插件的重要功能组件，提供全面的数据导出能力，支持多种格式和导出方式。该模块基于对 Serial-Studio 原版软件数据导出功能的深度分析，确保用户能够方便地保存、分析和分享数据。

### 1.1 模块目标

- **格式多样性**：支持 CSV、JSON、Excel、XML 等多种导出格式
- **数据完整性**：确保导出数据的准确性和完整性
- **用户友好性**：提供直观的导出界面和操作流程
- **性能优化**：支持大数据集的高效导出
- **可扩展性**：支持自定义导出格式和处理器

### 1.2 支持的导出格式

1. **CSV 格式**：标准逗号分隔值文件
2. **JSON 格式**：结构化 JSON 数据文件
3. **Excel 格式**：.xlsx 电子表格文件
4. **XML 格式**：可扩展标记语言文件
5. **TXT 格式**：纯文本格式
6. **Binary 格式**：二进制数据文件
7. **自定义格式**：通过插件系统支持

## 2. 数据导出架构设计

### 2.1 模块架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Data Export Module                      │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │  Export Manager │  │ Format Registry │  │ Export UI    │ │
│  │  - Coordination │  │ - Format Types  │  │ - Dialogs    │ │
│  │  - Validation   │  │ - Registration  │  │ - Progress   │ │
│  │  - Progress     │  │ - Discovery     │  │ - Settings   │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │ Data Processor  │  │ Format Writers  │  │File System   │ │
│  │ - Filtering     │  │ - CSV Writer    │  │ - Path Mgmt  │ │
│  │ - Transformation│  │ - JSON Writer   │  │ - Permission │ │
│  │ - Aggregation   │  │ - Excel Writer  │  │ - Validation │ │
│  │ - Compression   │  │ - XML Writer    │  │ - Streaming  │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                 Plugin System                           │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ │ │
│  │  │Custom Writer│  │Format Plugin│  │Export Extension │ │ │
│  │  │ Interfaces  │  │  Registry   │  │   Hooks         │ │ │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘ │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 核心接口设计

```typescript
// 导出管理器接口
interface ExportManager {
  // 导出配置
  exportData(config: ExportConfig): Promise<ExportResult>;
  
  // 支持的格式
  getSupportedFormats(): ExportFormat[];
  
  // 导出进度监控
  onProgress(callback: (progress: ExportProgress) => void): void;
  
  // 取消导出
  cancelExport(taskId: string): Promise<void>;
}

// 导出配置
interface ExportConfig {
  // 数据源配置
  dataSource: {
    type: 'current' | 'historical' | 'range' | 'selection';
    range?: {
      startTime: Date;
      endTime: Date;
    };
    datasets?: string[]; // 指定数据集
    groups?: string[];   // 指定数据组
  };
  
  // 导出格式配置
  format: {
    type: ExportFormatType;
    options: FormatOptions;
  };
  
  // 文件配置
  file: {
    path: string;
    name: string;
    overwrite: boolean;
  };
  
  // 处理选项
  processing: {
    includeMetadata: boolean;
    includeTimestamps: boolean;
    compression: boolean;
    encoding: string;
    precision: number;
  };
  
  // 过滤选项
  filters: {
    timeRange?: [Date, Date];
    valueRange?: [number, number];
    conditions?: FilterCondition[];
  };
}

// 导出格式类型
enum ExportFormatType {
  CSV = 'csv',
  JSON = 'json',
  EXCEL = 'excel',
  XML = 'xml',
  TXT = 'txt',
  BINARY = 'binary',
  CUSTOM = 'custom'
}

// 导出结果
interface ExportResult {
  success: boolean;
  filePath: string;
  fileSize: number;
  recordCount: number;
  duration: number;
  checksum?: string;
  errors?: ExportError[];
}

// 导出进度
interface ExportProgress {
  taskId: string;
  stage: 'preparing' | 'processing' | 'writing' | 'finalizing';
  percentage: number;
  processedRecords: number;
  totalRecords: number;
  estimatedTimeRemaining: number;
  currentFile?: string;
}
```

## 3. 格式化写入器实现

### 3.1 CSV 格式写入器

```typescript
// CSV 导出器
class CSVExporter implements DataExporter {
  private options: CSVOptions;
  
  constructor(options: CSVOptions = {}) {
    this.options = {
      delimiter: ',',
      quote: '"',
      escape: '"',
      encoding: 'utf-8',
      includeHeader: true,
      lineEnding: '\n',
      ...options
    };
  }
  
  async exportData(data: ExportData, filePath: string): Promise<ExportResult> {
    const startTime = performance.now();
    let recordCount = 0;
    let fileSize = 0;
    
    try {
      // 创建写入流
      const writeStream = fs.createWriteStream(filePath, {
        encoding: this.options.encoding
      });
      
      // 写入表头
      if (this.options.includeHeader && data.headers) {
        const headerLine = this.formatCSVLine(data.headers);
        writeStream.write(headerLine + this.options.lineEnding);
        fileSize += Buffer.byteLength(headerLine, this.options.encoding);
      }
      
      // 流式写入数据
      for await (const record of data.records) {
        const csvLine = this.formatCSVLine(record);
        writeStream.write(csvLine + this.options.lineEnding);
        fileSize += Buffer.byteLength(csvLine, this.options.encoding);
        recordCount++;
        
        // 报告进度
        if (recordCount % 1000 === 0) {
          this.reportProgress(recordCount, data.totalRecords);
        }
      }
      
      await this.closeStream(writeStream);
      
      return {
        success: true,
        filePath,
        fileSize,
        recordCount,
        duration: performance.now() - startTime
      };
      
    } catch (error) {
      throw new ExportError(`CSV export failed: ${error.message}`);
    }
  }
  
  private formatCSVLine(values: any[]): string {
    return values.map(value => this.formatCSVValue(value)).join(this.options.delimiter);
  }
  
  private formatCSVValue(value: any): string {
    if (value === null || value === undefined) {
      return '';
    }
    
    const stringValue = String(value);
    
    // 检查是否需要引号
    if (this.needsQuoting(stringValue)) {
      return this.options.quote + stringValue.replace(
        new RegExp(this.options.quote, 'g'),
        this.options.escape + this.options.quote
      ) + this.options.quote;
    }
    
    return stringValue;
  }
  
  private needsQuoting(value: string): boolean {
    return value.includes(this.options.delimiter) ||
           value.includes(this.options.quote) ||
           value.includes('\n') ||
           value.includes('\r');
  }
}

// CSV 导出选项
interface CSVOptions {
  delimiter?: string;
  quote?: string;
  escape?: string;
  encoding?: string;
  includeHeader?: boolean;
  lineEnding?: string;
  precision?: number;
  dateFormat?: string;
}
```

### 3.2 JSON 格式写入器

```typescript
// JSON 导出器
class JSONExporter implements DataExporter {
  private options: JSONOptions;
  
  constructor(options: JSONOptions = {}) {
    this.options = {
      pretty: true,
      indent: 2,
      encoding: 'utf-8',
      includeMetadata: true,
      arrayFormat: true,
      ...options
    };
  }
  
  async exportData(data: ExportData, filePath: string): Promise<ExportResult> {
    const startTime = performance.now();
    
    try {
      const exportObject = await this.buildExportObject(data);
      
      // 格式化 JSON
      const jsonString = this.options.pretty
        ? JSON.stringify(exportObject, null, this.options.indent)
        : JSON.stringify(exportObject);
      
      // 写入文件
      await fs.promises.writeFile(filePath, jsonString, {
        encoding: this.options.encoding
      });
      
      const fileStats = await fs.promises.stat(filePath);
      
      return {
        success: true,
        filePath,
        fileSize: fileStats.size,
        recordCount: data.totalRecords,
        duration: performance.now() - startTime
      };
      
    } catch (error) {
      throw new ExportError(`JSON export failed: ${error.message}`);
    }
  }
  
  private async buildExportObject(data: ExportData): Promise<any> {
    const exportObject: any = {};
    
    // 添加元数据
    if (this.options.includeMetadata) {
      exportObject.metadata = {
        exportTime: new Date().toISOString(),
        version: '1.0',
        source: 'Serial-Studio VSCode Extension',
        recordCount: data.totalRecords,
        datasetInfo: data.datasets.map(ds => ({
          id: ds.id,
          title: ds.title,
          units: ds.units,
          type: ds.dataType
        }))
      };
    }
    
    // 添加数据
    if (this.options.arrayFormat) {
      exportObject.data = [];
      
      for await (const record of data.records) {
        const recordObject = this.formatRecord(record, data.headers);
        exportObject.data.push(recordObject);
      }
    } else {
      // 按数据集分组
      exportObject.datasets = {};
      
      for (const dataset of data.datasets) {
        exportObject.datasets[dataset.id] = {
          info: {
            title: dataset.title,
            units: dataset.units,
            type: dataset.dataType
          },
          values: []
        };
      }
      
      for await (const record of data.records) {
        this.addRecordToDatasets(record, data.headers, exportObject.datasets);
      }
    }
    
    return exportObject;
  }
  
  private formatRecord(record: any[], headers: string[]): any {
    const recordObject: any = {};
    
    for (let i = 0; i < headers.length; i++) {
      recordObject[headers[i]] = record[i];
    }
    
    return recordObject;
  }
}

// JSON 导出选项
interface JSONOptions {
  pretty?: boolean;
  indent?: number;
  encoding?: string;
  includeMetadata?: boolean;
  arrayFormat?: boolean; // true: 数组格式, false: 按数据集分组
  compression?: boolean;
}
```

### 3.3 Excel 格式写入器

```typescript
// Excel 导出器（使用 ExcelJS）
import * as ExcelJS from 'exceljs';

class ExcelExporter implements DataExporter {
  private options: ExcelOptions;
  
  constructor(options: ExcelOptions = {}) {
    this.options = {
      sheetName: 'Data',
      includeChart: false,
      autoFitColumns: true,
      includeMetadata: true,
      dateFormat: 'yyyy-mm-dd hh:mm:ss',
      ...options
    };
  }
  
  async exportData(data: ExportData, filePath: string): Promise<ExportResult> {
    const startTime = performance.now();
    
    try {
      const workbook = new ExcelJS.Workbook();
      
      // 设置工作簿属性
      workbook.creator = 'Serial-Studio VSCode Extension';
      workbook.lastModifiedBy = 'Serial-Studio VSCode Extension';
      workbook.created = new Date();
      workbook.modified = new Date();
      
      // 创建数据工作表
      const worksheet = workbook.addWorksheet(this.options.sheetName);
      
      // 添加标题行
      if (data.headers) {
        const headerRow = worksheet.addRow(data.headers);
        this.styleHeaderRow(headerRow);
      }
      
      // 添加数据行
      let recordCount = 0;
      for await (const record of data.records) {
        const formattedRecord = this.formatExcelRecord(record);
        worksheet.addRow(formattedRecord);
        recordCount++;
        
        if (recordCount % 1000 === 0) {
          this.reportProgress(recordCount, data.totalRecords);
        }
      }
      
      // 自动调整列宽
      if (this.options.autoFitColumns) {
        this.autoFitColumns(worksheet);
      }
      
      // 添加图表
      if (this.options.includeChart && data.chartConfig) {
        await this.addChart(worksheet, data.chartConfig);
      }
      
      // 添加元数据工作表
      if (this.options.includeMetadata) {
        this.addMetadataSheet(workbook, data);
      }
      
      // 保存文件
      await workbook.xlsx.writeFile(filePath);
      
      const fileStats = await fs.promises.stat(filePath);
      
      return {
        success: true,
        filePath,
        fileSize: fileStats.size,
        recordCount,
        duration: performance.now() - startTime
      };
      
    } catch (error) {
      throw new ExportError(`Excel export failed: ${error.message}`);
    }
  }
  
  private styleHeaderRow(row: ExcelJS.Row): void {
    row.eachCell(cell => {
      cell.font = { bold: true, color: { argb: 'FFFFFF' } };
      cell.fill = {
        type: 'pattern',
        pattern: 'solid',
        fgColor: { argb: '366092' }
      };
      cell.border = {
        top: { style: 'thin' },
        left: { style: 'thin' },
        bottom: { style: 'thin' },
        right: { style: 'thin' }
      };
    });
  }
  
  private autoFitColumns(worksheet: ExcelJS.Worksheet): void {
    worksheet.columns.forEach(column => {
      let maxLength = 0;
      
      if (column.eachCell) {
        column.eachCell({ includeEmpty: false }, cell => {
          const cellLength = cell.value ? cell.value.toString().length : 0;
          maxLength = Math.max(maxLength, cellLength);
        });
      }
      
      column.width = Math.min(Math.max(maxLength + 2, 10), 50);
    });
  }
  
  private async addChart(worksheet: ExcelJS.Worksheet, chartConfig: ChartConfig): Promise<void> {
    // 实现图表添加逻辑
    const chart = worksheet.addChart({
      type: chartConfig.type,
      position: chartConfig.position,
      size: chartConfig.size
    });
    
    // 配置图表数据系列
    chart.addSeries({
      name: chartConfig.series.name,
      categories: chartConfig.series.categories,
      values: chartConfig.series.values
    });
  }
  
  private addMetadataSheet(workbook: ExcelJS.Workbook, data: ExportData): void {
    const metadataSheet = workbook.addWorksheet('Metadata');
    
    // 添加导出信息
    metadataSheet.addRow(['Export Information']);
    metadataSheet.addRow(['Export Time', new Date().toISOString()]);
    metadataSheet.addRow(['Record Count', data.totalRecords]);
    metadataSheet.addRow(['Dataset Count', data.datasets.length]);
    
    // 添加数据集信息
    metadataSheet.addRow([]);
    metadataSheet.addRow(['Dataset Information']);
    metadataSheet.addRow(['ID', 'Title', 'Units', 'Type']);
    
    for (const dataset of data.datasets) {
      metadataSheet.addRow([
        dataset.id,
        dataset.title,
        dataset.units,
        dataset.dataType
      ]);
    }
  }
}

// Excel 导出选项
interface ExcelOptions {
  sheetName?: string;
  includeChart?: boolean;
  autoFitColumns?: boolean;
  includeMetadata?: boolean;
  dateFormat?: string;
  numberFormat?: string;
  chartConfig?: ChartConfig;
}

interface ChartConfig {
  type: 'line' | 'bar' | 'scatter';
  position: { x: number; y: number };
  size: { width: number; height: number };
  series: {
    name: string;
    categories: string;
    values: string;
  };
}
```

## 4. 数据处理和过滤

### 4.1 数据过滤器

```typescript
// 数据过滤器
class DataFilter {
  private conditions: FilterCondition[];
  
  constructor(conditions: FilterCondition[] = []) {
    this.conditions = conditions;
  }
  
  filter(records: any[][]): any[][] {
    if (this.conditions.length === 0) {
      return records;
    }
    
    return records.filter(record => this.evaluateRecord(record));
  }
  
  private evaluateRecord(record: any[]): boolean {
    return this.conditions.every(condition => this.evaluateCondition(record, condition));
  }
  
  private evaluateCondition(record: any[], condition: FilterCondition): boolean {
    const value = record[condition.columnIndex];
    
    switch (condition.operator) {
      case 'equals':
        return value === condition.value;
      case 'not_equals':
        return value !== condition.value;
      case 'greater_than':
        return Number(value) > Number(condition.value);
      case 'less_than':
        return Number(value) < Number(condition.value);
      case 'greater_equal':
        return Number(value) >= Number(condition.value);
      case 'less_equal':
        return Number(value) <= Number(condition.value);
      case 'contains':
        return String(value).includes(String(condition.value));
      case 'starts_with':
        return String(value).startsWith(String(condition.value));
      case 'ends_with':
        return String(value).endsWith(String(condition.value));
      case 'regex':
        return new RegExp(String(condition.value)).test(String(value));
      case 'in_range':
        const numValue = Number(value);
        return numValue >= condition.value[0] && numValue <= condition.value[1];
      default:
        return true;
    }
  }
}

// 过滤条件
interface FilterCondition {
  columnIndex: number;
  operator: FilterOperator;
  value: any;
  logicalOperator?: 'AND' | 'OR';
}

type FilterOperator = 
  | 'equals' | 'not_equals'
  | 'greater_than' | 'less_than' | 'greater_equal' | 'less_equal'
  | 'contains' | 'starts_with' | 'ends_with'
  | 'regex' | 'in_range';
```

### 4.2 数据转换器

```typescript
// 数据转换器
class DataTransformer {
  private transformations: DataTransformation[];
  
  constructor(transformations: DataTransformation[] = []) {
    this.transformations = transformations;
  }
  
  transform(records: any[][]): any[][] {
    let transformedRecords = records;
    
    for (const transformation of this.transformations) {
      transformedRecords = this.applyTransformation(transformedRecords, transformation);
    }
    
    return transformedRecords;
  }
  
  private applyTransformation(records: any[][], transformation: DataTransformation): any[][] {
    switch (transformation.type) {
      case 'unit_conversion':
        return this.convertUnits(records, transformation);
      case 'precision_round':
        return this.roundPrecision(records, transformation);
      case 'date_format':
        return this.formatDates(records, transformation);
      case 'custom_function':
        return this.applyCustomFunction(records, transformation);
      default:
        return records;
    }
  }
  
  private convertUnits(records: any[][], transformation: DataTransformation): any[][] {
    const { columnIndex, fromUnit, toUnit, conversionFactor } = transformation.config;
    
    return records.map(record => {
      const newRecord = [...record];
      const value = Number(record[columnIndex]);
      
      if (!isNaN(value)) {
        newRecord[columnIndex] = value * conversionFactor;
      }
      
      return newRecord;
    });
  }
  
  private roundPrecision(records: any[][], transformation: DataTransformation): any[][] {
    const { columnIndex, precision } = transformation.config;
    
    return records.map(record => {
      const newRecord = [...record];
      const value = Number(record[columnIndex]);
      
      if (!isNaN(value)) {
        newRecord[columnIndex] = Number(value.toFixed(precision));
      }
      
      return newRecord;
    });
  }
  
  private formatDates(records: any[][], transformation: DataTransformation): any[][] {
    const { columnIndex, format } = transformation.config;
    
    return records.map(record => {
      const newRecord = [...record];
      const dateValue = record[columnIndex];
      
      if (dateValue instanceof Date || (typeof dateValue === 'string' && !isNaN(Date.parse(dateValue)))) {
        const date = new Date(dateValue);
        newRecord[columnIndex] = this.formatDate(date, format);
      }
      
      return newRecord;
    });
  }
  
  private formatDate(date: Date, format: string): string {
    // 实现日期格式化逻辑
    const formatMap: { [key: string]: string } = {
      'YYYY': date.getFullYear().toString(),
      'MM': (date.getMonth() + 1).toString().padStart(2, '0'),
      'DD': date.getDate().toString().padStart(2, '0'),
      'HH': date.getHours().toString().padStart(2, '0'),
      'mm': date.getMinutes().toString().padStart(2, '0'),
      'ss': date.getSeconds().toString().padStart(2, '0')
    };
    
    let formattedDate = format;
    for (const [token, value] of Object.entries(formatMap)) {
      formattedDate = formattedDate.replace(new RegExp(token, 'g'), value);
    }
    
    return formattedDate;
  }
}

// 数据转换配置
interface DataTransformation {
  type: TransformationType;
  config: TransformationConfig;
}

type TransformationType = 
  | 'unit_conversion' | 'precision_round' | 'date_format' | 'custom_function';

interface TransformationConfig {
  columnIndex: number;
  [key: string]: any;
}
```

## 5. 用户界面设计

### 5.1 导出对话框组件

```vue
<template>
  <el-dialog
    v-model="visible"
    title="数据导出"
    width="800px"
    :close-on-click-modal="false"
    @close="handleClose"
  >
    <el-form ref="formRef" :model="exportConfig" :rules="rules" label-width="120px">
      <!-- 数据源配置 -->
      <el-form-item label="数据源" prop="dataSource.type">
        <el-radio-group v-model="exportConfig.dataSource.type">
          <el-radio label="current">当前数据</el-radio>
          <el-radio label="historical">历史数据</el-radio>
          <el-radio label="range">时间范围</el-radio>
          <el-radio label="selection">选中数据</el-radio>
        </el-radio-group>
      </el-form-item>
      
      <!-- 时间范围选择 -->
      <el-form-item 
        v-if="exportConfig.dataSource.type === 'range'"
        label="时间范围"
        prop="dataSource.range"
      >
        <el-date-picker
          v-model="timeRange"
          type="datetimerange"
          range-separator="至"
          start-placeholder="开始时间"
          end-placeholder="结束时间"
          @change="handleTimeRangeChange"
        />
      </el-form-item>
      
      <!-- 数据集选择 -->
      <el-form-item label="数据集">
        <el-select
          v-model="exportConfig.dataSource.datasets"
          multiple
          placeholder="选择要导出的数据集"
          style="width: 100%"
        >
          <el-option
            v-for="dataset in availableDatasets"
            :key="dataset.id"
            :label="dataset.title"
            :value="dataset.id"
          />
        </el-select>
      </el-form-item>
      
      <!-- 导出格式 -->
      <el-form-item label="导出格式" prop="format.type">
        <el-select v-model="exportConfig.format.type" @change="handleFormatChange">
          <el-option label="CSV" value="csv" />
          <el-option label="JSON" value="json" />
          <el-option label="Excel" value="excel" />
          <el-option label="XML" value="xml" />
          <el-option label="纯文本" value="txt" />
        </el-select>
      </el-form-item>
      
      <!-- 格式特定选项 -->
      <template v-if="exportConfig.format.type === 'csv'">
        <el-form-item label="分隔符">
          <el-select v-model="csvOptions.delimiter" style="width: 120px">
            <el-option label="逗号 (,)" value="," />
            <el-option label="分号 (;)" value=";" />
            <el-option label="制表符" value="\t" />
          </el-select>
        </el-form-item>
        
        <el-form-item label="编码">
          <el-select v-model="csvOptions.encoding" style="width: 120px">
            <el-option label="UTF-8" value="utf-8" />
            <el-option label="GBK" value="gbk" />
            <el-option label="ASCII" value="ascii" />
          </el-select>
        </el-form-item>
      </template>
      
      <template v-if="exportConfig.format.type === 'json'">
        <el-form-item label="格式化">
          <el-switch v-model="jsonOptions.pretty" active-text="美化输出" />
        </el-form-item>
        
        <el-form-item label="包含元数据">
          <el-switch v-model="jsonOptions.includeMetadata" active-text="包含" />
        </el-form-item>
      </template>
      
      <!-- 处理选项 -->
      <el-form-item label="处理选项">
        <el-checkbox-group v-model="processingOptions">
          <el-checkbox label="includeTimestamps">包含时间戳</el-checkbox>
          <el-checkbox label="includeMetadata">包含元数据</el-checkbox>
          <el-checkbox label="compression">启用压缩</el-checkbox>
        </el-checkbox-group>
      </el-form-item>
      
      <!-- 数值精度 -->
      <el-form-item label="数值精度">
        <el-input-number
          v-model="exportConfig.processing.precision"
          :min="0"
          :max="10"
          style="width: 120px"
        />
        <span style="margin-left: 10px; color: #666;">小数位数</span>
      </el-form-item>
      
      <!-- 文件路径 -->
      <el-form-item label="保存路径" prop="file.path">
        <el-input
          v-model="exportConfig.file.path"
          placeholder="选择保存路径"
          readonly
        >
          <template #append>
            <el-button @click="selectFilePath">浏览</el-button>
          </template>
        </el-input>
      </el-form-item>
    </el-form>
    
    <!-- 进度显示 -->
    <div v-if="exporting" class="export-progress">
      <el-progress
        :percentage="progress.percentage"
        :status="progress.status"
        :stroke-width="6"
      />
      <div class="progress-info">
        <span>{{ progress.stage }}</span>
        <span>{{ progress.processedRecords }}/{{ progress.totalRecords }}</span>
        <span v-if="progress.estimatedTimeRemaining > 0">
          剩余时间: {{ formatTime(progress.estimatedTimeRemaining) }}
        </span>
      </div>
    </div>
    
    <template #footer>
      <el-button @click="handleClose" :disabled="exporting">取消</el-button>
      <el-button type="primary" @click="handleExport" :loading="exporting">
        {{ exporting ? '导出中...' : '开始导出' }}
      </el-button>
    </template>
  </el-dialog>
</template>

<script setup lang="ts">
import { ref, reactive, computed, watch } from 'vue';
import { ElMessage, ElMessageBox } from 'element-plus';
import type { FormInstance, FormRules } from 'element-plus';

// 响应式数据
const visible = ref(false);
const exporting = ref(false);
const formRef = ref<FormInstance>();

const exportConfig = reactive<ExportConfig>({
  dataSource: {
    type: 'current',
    datasets: [],
    groups: []
  },
  format: {
    type: 'csv',
    options: {}
  },
  file: {
    path: '',
    name: '',
    overwrite: false
  },
  processing: {
    includeMetadata: true,
    includeTimestamps: true,
    compression: false,
    encoding: 'utf-8',
    precision: 3
  },
  filters: {}
});

const progress = reactive<ExportProgress>({
  taskId: '',
  stage: 'preparing',
  percentage: 0,
  processedRecords: 0,
  totalRecords: 0,
  estimatedTimeRemaining: 0
});

// 格式特定选项
const csvOptions = reactive({
  delimiter: ',',
  encoding: 'utf-8',
  includeHeader: true
});

const jsonOptions = reactive({
  pretty: true,
  includeMetadata: true,
  arrayFormat: true
});

// 验证规则
const rules: FormRules = {
  'dataSource.type': [
    { required: true, message: '请选择数据源类型', trigger: 'change' }
  ],
  'format.type': [
    { required: true, message: '请选择导出格式', trigger: 'change' }
  ],
  'file.path': [
    { required: true, message: '请选择保存路径', trigger: 'blur' }
  ]
};

// 处理函数
const handleExport = async () => {
  if (!formRef.value) return;
  
  try {
    await formRef.value.validate();
    
    exporting.value = true;
    
    // 准备导出配置
    const finalConfig = {
      ...exportConfig,
      format: {
        ...exportConfig.format,
        options: getFormatOptions()
      }
    };
    
    // 执行导出
    const result = await exportManager.exportData(finalConfig);
    
    if (result.success) {
      ElMessage.success(`导出成功！文件保存至: ${result.filePath}`);
      visible.value = false;
    } else {
      throw new Error('导出失败');
    }
    
  } catch (error) {
    ElMessage.error(`导出失败: ${error.message}`);
  } finally {
    exporting.value = false;
  }
};

const getFormatOptions = () => {
  switch (exportConfig.format.type) {
    case 'csv':
      return csvOptions;
    case 'json':
      return jsonOptions;
    default:
      return {};
  }
};
</script>
```

## 6. 导出管理器实现

### 6.1 核心导出管理器

```typescript
// 导出管理器实现
class ExportManagerImpl implements ExportManager {
  private formatRegistry: Map<ExportFormatType, DataExporter> = new Map();
  private activeExports: Map<string, ExportTask> = new Map();
  private progressCallbacks: Set<(progress: ExportProgress) => void> = new Set();
  
  constructor() {
    this.registerDefaultExporters();
  }
  
  private registerDefaultExporters(): void {
    this.formatRegistry.set(ExportFormatType.CSV, new CSVExporter());
    this.formatRegistry.set(ExportFormatType.JSON, new JSONExporter());
    this.formatRegistry.set(ExportFormatType.EXCEL, new ExcelExporter());
    this.formatRegistry.set(ExportFormatType.XML, new XMLExporter());
    this.formatRegistry.set(ExportFormatType.TXT, new TXTExporter());
  }
  
  async exportData(config: ExportConfig): Promise<ExportResult> {
    const taskId = this.generateTaskId();
    const startTime = performance.now();
    
    try {
      // 验证配置
      this.validateConfig(config);
      
      // 获取导出器
      const exporter = this.getExporter(config.format.type);
      if (!exporter) {
        throw new ExportError(`Unsupported export format: ${config.format.type}`);
      }
      
      // 准备数据
      this.reportProgress(taskId, 'preparing', 0, 0, 0);
      const exportData = await this.prepareExportData(config);
      
      // 应用过滤和转换
      this.reportProgress(taskId, 'processing', 10, 0, exportData.totalRecords);
      const processedData = await this.processData(exportData, config);
      
      // 执行导出
      this.reportProgress(taskId, 'writing', 30, 0, processedData.totalRecords);
      const result = await exporter.exportData(processedData, config.file.path);
      
      // 完成处理
      this.reportProgress(taskId, 'finalizing', 100, result.recordCount, result.recordCount);
      
      // 清理任务
      this.activeExports.delete(taskId);
      
      return {
        ...result,
        duration: performance.now() - startTime
      };
      
    } catch (error) {
      this.activeExports.delete(taskId);
      throw error;
    }
  }
  
  getSupportedFormats(): ExportFormat[] {
    return Array.from(this.formatRegistry.keys()).map(type => ({
      type,
      name: this.getFormatName(type),
      extensions: this.getFormatExtensions(type),
      description: this.getFormatDescription(type),
      options: this.getFormatOptions(type)
    }));
  }
  
  onProgress(callback: (progress: ExportProgress) => void): void {
    this.progressCallbacks.add(callback);
  }
  
  async cancelExport(taskId: string): Promise<void> {
    const task = this.activeExports.get(taskId);
    if (task) {
      task.cancelled = true;
      this.activeExports.delete(taskId);
    }
  }
  
  private async prepareExportData(config: ExportConfig): Promise<ExportData> {
    const dataProvider = this.getDataProvider(config.dataSource.type);
    return await dataProvider.getData(config.dataSource);
  }
  
  private async processData(data: ExportData, config: ExportConfig): Promise<ExportData> {
    let processedData = data;
    
    // 应用过滤器
    if (config.filters && Object.keys(config.filters).length > 0) {
      const filter = new DataFilter(this.buildFilterConditions(config.filters));
      processedData = {
        ...processedData,
        records: filter.filter(Array.from(processedData.records))
      };
    }
    
    // 应用数据转换
    if (config.processing) {
      const transformer = new DataTransformer(this.buildTransformations(config.processing));
      processedData = {
        ...processedData,
        records: transformer.transform(Array.from(processedData.records))
      };
    }
    
    return processedData;
  }
  
  private reportProgress(
    taskId: string,
    stage: ExportProgress['stage'],
    percentage: number,
    processedRecords: number,
    totalRecords: number
  ): void {
    const progress: ExportProgress = {
      taskId,
      stage,
      percentage,
      processedRecords,
      totalRecords,
      estimatedTimeRemaining: this.calculateETA(percentage, Date.now())
    };
    
    for (const callback of this.progressCallbacks) {
      callback(progress);
    }
  }
  
  private generateTaskId(): string {
    return `export_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  private validateConfig(config: ExportConfig): void {
    if (!config.format.type) {
      throw new ExportError('Export format type is required');
    }
    
    if (!config.file.path) {
      throw new ExportError('Export file path is required');
    }
    
    if (!this.formatRegistry.has(config.format.type)) {
      throw new ExportError(`Unsupported format: ${config.format.type}`);
    }
  }
}

// 导出任务
interface ExportTask {
  id: string;
  config: ExportConfig;
  startTime: number;
  cancelled: boolean;
}

// 导出错误
class ExportError extends Error {
  constructor(message: string, public code?: string) {
    super(message);
    this.name = 'ExportError';
  }
}
```

## 7. 扩展性和插件支持

### 7.1 自定义导出器插件接口

```typescript
// 插件导出器接口
interface PluginExporter extends DataExporter {
  readonly id: string;
  readonly name: string;
  readonly version: string;
  readonly description: string;
  readonly supportedExtensions: string[];
  
  // 插件特定配置
  getConfigSchema(): JSONSchema;
  validateConfig(config: any): boolean;
  
  // 插件生命周期
  initialize(): Promise<void>;
  cleanup(): Promise<void>;
}

// 导出器注册管理
class ExporterRegistry {
  private static instance: ExporterRegistry;
  private exporters: Map<string, PluginExporter> = new Map();
  
  static getInstance(): ExporterRegistry {
    if (!ExporterRegistry.instance) {
      ExporterRegistry.instance = new ExporterRegistry();
    }
    return ExporterRegistry.instance;
  }
  
  registerExporter(exporter: PluginExporter): void {
    if (this.exporters.has(exporter.id)) {
      throw new Error(`Exporter with id '${exporter.id}' already registered`);
    }
    
    this.exporters.set(exporter.id, exporter);
  }
  
  unregisterExporter(id: string): void {
    const exporter = this.exporters.get(id);
    if (exporter) {
      exporter.cleanup();
      this.exporters.delete(id);
    }
  }
  
  getExporter(id: string): PluginExporter | undefined {
    return this.exporters.get(id);
  }
  
  getAllExporters(): PluginExporter[] {
    return Array.from(this.exporters.values());
  }
}

// 自定义导出器示例
class CustomXMLExporter implements PluginExporter {
  readonly id = 'custom-xml-exporter';
  readonly name = 'Custom XML Exporter';
  readonly version = '1.0.0';
  readonly description = 'Export data to custom XML format';
  readonly supportedExtensions = ['.xml', '.customxml'];
  
  async initialize(): Promise<void> {
    // 初始化逻辑
  }
  
  async cleanup(): Promise<void> {
    // 清理逻辑
  }
  
  getConfigSchema(): JSONSchema {
    return {
      type: 'object',
      properties: {
        rootElement: { type: 'string', default: 'data' },
        recordElement: { type: 'string', default: 'record' },
        includeAttributes: { type: 'boolean', default: true },
        prettyPrint: { type: 'boolean', default: true }
      }
    };
  }
  
  validateConfig(config: any): boolean {
    // 验证配置
    return typeof config.rootElement === 'string' && 
           typeof config.recordElement === 'string';
  }
  
  async exportData(data: ExportData, filePath: string): Promise<ExportResult> {
    // 实现自定义 XML 导出逻辑
    const startTime = performance.now();
    
    try {
      const xmlContent = this.buildXMLContent(data);
      await fs.promises.writeFile(filePath, xmlContent, 'utf-8');
      
      const fileStats = await fs.promises.stat(filePath);
      
      return {
        success: true,
        filePath,
        fileSize: fileStats.size,
        recordCount: data.totalRecords,
        duration: performance.now() - startTime
      };
      
    } catch (error) {
      throw new ExportError(`Custom XML export failed: ${error.message}`);
    }
  }
  
  private buildXMLContent(data: ExportData): string {
    // 构建 XML 内容
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    xml += `<${this.config.rootElement}>\n`;
    
    for (const record of data.records) {
      xml += `  <${this.config.recordElement}>\n`;
      
      for (let i = 0; i < data.headers.length; i++) {
        const header = data.headers[i];
        const value = record[i];
        xml += `    <${header}>${this.escapeXML(String(value))}</${header}>\n`;
      }
      
      xml += `  </${this.config.recordElement}>\n`;
    }
    
    xml += `</${this.config.rootElement}>`;
    
    return xml;
  }
  
  private escapeXML(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }
}
```

这个数据导出模块设计提供了完整的数据导出解决方案，包括多种格式支持、高性能处理、用户友好界面和强大的扩展性。通过模块化设计，可以轻松添加新的导出格式和处理器，满足各种复杂的数据导出需求。