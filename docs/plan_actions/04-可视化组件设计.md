# Serial-Studio VSCode 插件可视化组件设计

## 1. 可视化组件架构概述

基于对 Serial-Studio UI 模块的深度分析，可视化组件是用户界面的核心部分，负责将结构化数据转换为直观的图形界面。本设计采用 Vue3 + Element Plus + 专业图表库的技术栈，实现高性能、可扩展的数据可视化系统。

### 1.1 组件分类体系

根据 Serial-Studio 的组件分析，可视化组件分为三个层次：

1. **数据集组件**（Dataset Widgets）
   - Plot（数据图表）
   - Bar（条形图）
   - Gauge（仪表盘）
   - Compass（指南针）
   - FFT（频谱分析）
   - LED（指示灯）

2. **分组组件**（Group Widgets）
   - DataGrid（数据网格）
   - MultiPlot（多数据图表）
   - Accelerometer（加速度计）
   - Gyroscope（陀螺仪）
   - GPS（地图显示）
   - Terminal（终端显示）
   - Plot3D（3D绘图）

3. **系统组件**（System Widgets）
   - Dashboard（仪表板容器）
   - ActionPanel（操作面板）
   - ConnectionPanel（连接面板）
   - ProjectEditor（项目编辑器）

### 1.2 技术栈选择

```typescript
// 核心框架
Vue3 (Composition API)
Element Plus (UI组件库)
Pinia (状态管理)

// 图表和可视化库
Chart.js (基础图表)
D3.js (自定义可视化)
Three.js (3D可视化)
Leaflet (地图组件)
WebGL (高性能渲染)

// 工具库
ResizeObserver (响应式布局)
Lodash (工具函数)
Color.js (颜色处理)
Moment.js (时间处理)
```

## 2. 组件基础架构设计

### 2.1 可视化组件基类

```vue
<!-- BaseWidget.vue -->
<template>
  <div 
    class="base-widget"
    :class="[`widget-${type}`, { 'widget-loading': loading, 'widget-error': hasError }]"
    :style="widgetStyle"
    ref="widgetContainer"
  >
    <div class="widget-header" v-if="showHeader">
      <h3 class="widget-title">{{ title }}</h3>
      <div class="widget-controls">
        <el-button 
          v-if="showFullscreen"
          size="small" 
          type="text" 
          @click="toggleFullscreen"
        >
          <el-icon><FullScreen /></el-icon>
        </el-button>
        <el-button 
          v-if="showExport"
          size="small" 
          type="text" 
          @click="exportData"
        >
          <el-icon><Download /></el-icon>
        </el-button>
      </div>
    </div>
    
    <div class="widget-content" ref="contentContainer">
      <div v-if="loading" class="widget-loading-state">
        <el-skeleton :rows="3" animated />
      </div>
      
      <div v-else-if="hasError" class="widget-error-state">
        <el-alert 
          :title="errorMessage" 
          type="error" 
          :closable="false"
          show-icon 
        />
      </div>
      
      <slot v-else :data="processedData" :config="widgetConfig" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, onMounted, onUnmounted, watch } from 'vue'
import { useDashboardStore } from '@/stores/dashboard'
import { useThemeStore } from '@/stores/theme'

interface Props {
  type: string
  title: string
  dataset?: Dataset
  group?: Group
  config?: WidgetConfig
  showHeader?: boolean
  showFullscreen?: boolean
  showExport?: boolean
  autoResize?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  showHeader: true,
  showFullscreen: true,
  showExport: true,
  autoResize: true
})

const emit = defineEmits<{
  fullscreen: [value: boolean]
  export: [data: any]
  error: [error: Error]
  resize: [size: { width: number; height: number }]
}>()

// 响应式引用
const widgetContainer = ref<HTMLElement>()
const contentContainer = ref<HTMLElement>()
const loading = ref(false)
const hasError = ref(false)
const errorMessage = ref('')
const isFullscreen = ref(false)

// 状态管理
const dashboardStore = useDashboardStore()
const themeStore = useThemeStore()

// 计算属性
const widgetStyle = computed(() => ({
  '--widget-primary-color': themeStore.primaryColor,
  '--widget-background-color': themeStore.backgroundColor,
  '--widget-text-color': themeStore.textColor,
  '--widget-border-color': themeStore.borderColor,
}))

const processedData = computed(() => {
  // 根据组件类型处理数据
  if (props.dataset) {
    return processDatasetData(props.dataset)
  } else if (props.group) {
    return processGroupData(props.group)
  }
  return null
})

const widgetConfig = computed(() => ({
  ...props.config,
  theme: themeStore.currentTheme,
  responsive: props.autoResize
}))

// 生命周期钩子
onMounted(() => {
  if (props.autoResize) {
    setupResizeObserver()
  }
})

onUnmounted(() => {
  cleanupResizeObserver()
})

// 监听器
watch(() => props.dataset, (newDataset) => {
  if (newDataset) {
    updateWidget()
  }
}, { deep: true })

watch(() => props.group, (newGroup) => {
  if (newGroup) {
    updateWidget()
  }
}, { deep: true })

// 方法实现
function processDatasetData(dataset: Dataset) {
  try {
    return {
      value: parseFloat(dataset.value) || 0,
      label: dataset.title,
      units: dataset.units,
      min: dataset.min,
      max: dataset.max,
      alarm: dataset.alarm,
      timestamp: Date.now()
    }
  } catch (error) {
    handleError(error as Error)
    return null
  }
}

function processGroupData(group: Group) {
  try {
    return {
      title: group.title,
      datasets: group.datasets.map(processDatasetData),
      timestamp: Date.now()
    }
  } catch (error) {
    handleError(error as Error)
    return null
  }
}

function toggleFullscreen() {
  isFullscreen.value = !isFullscreen.value
  emit('fullscreen', isFullscreen.value)
}

function exportData() {
  try {
    const data = {
      type: props.type,
      title: props.title,
      data: processedData.value,
      timestamp: new Date().toISOString()
    }
    emit('export', data)
  } catch (error) {
    handleError(error as Error)
  }
}

function updateWidget() {
  loading.value = true
  hasError.value = false
  
  // 模拟异步更新
  nextTick(() => {
    loading.value = false
  })
}

function handleError(error: Error) {
  hasError.value = true
  errorMessage.value = error.message
  emit('error', error)
}

// 响应式布局支持
let resizeObserver: ResizeObserver | null = null

function setupResizeObserver() {
  if (!widgetContainer.value) return
  
  resizeObserver = new ResizeObserver((entries) => {
    for (const entry of entries) {
      const { width, height } = entry.contentRect
      emit('resize', { width, height })
    }
  })
  
  resizeObserver.observe(widgetContainer.value)
}

function cleanupResizeObserver() {
  if (resizeObserver) {
    resizeObserver.disconnect()
    resizeObserver = null
  }
}
</script>

<style scoped>
.base-widget {
  background: var(--widget-background-color);
  border: 1px solid var(--widget-border-color);
  border-radius: 8px;
  padding: 16px;
  position: relative;
  overflow: hidden;
}

.widget-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.widget-title {
  margin: 0;
  color: var(--widget-text-color);
  font-size: 16px;
  font-weight: 500;
}

.widget-content {
  height: calc(100% - 60px);
  position: relative;
}

.widget-loading-state,
.widget-error-state {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
}

.widget-loading {
  opacity: 0.7;
}

.widget-error {
  border-color: var(--el-color-danger);
}
</style>
```

### 2.2 数据管理和状态同步

```typescript
// stores/dashboard.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

interface DashboardState {
  widgets: Widget[]
  layout: LayoutConfig
  theme: ThemeConfig
  performance: PerformanceConfig
}

export const useDashboardStore = defineStore('dashboard', () => {
  // 状态
  const widgets = ref<Widget[]>([])
  const layout = ref<LayoutConfig>({
    columns: 12,
    rowHeight: 150,
    margin: [10, 10],
    containerPadding: [0, 0],
    isDraggable: true,
    isResizable: true
  })
  
  const performance = ref<PerformanceConfig>({
    maxDataPoints: 1000,
    updateInterval: 50, // 20 FPS
    enableVirtualScrolling: true,
    enableDataCompression: true
  })
  
  // 计算属性
  const activeWidgets = computed(() => 
    widgets.value.filter(w => w.visible)
  )
  
  const widgetsByType = computed(() => {
    const groups: Record<string, Widget[]> = {}
    widgets.value.forEach(widget => {
      if (!groups[widget.type]) {
        groups[widget.type] = []
      }
      groups[widget.type].push(widget)
    })
    return groups
  })
  
  // 操作
  function addWidget(widget: Widget) {
    widgets.value.push({
      ...widget,
      id: generateWidgetId(),
      createdAt: Date.now(),
      updatedAt: Date.now()
    })
  }
  
  function removeWidget(id: string) {
    const index = widgets.value.findIndex(w => w.id === id)
    if (index !== -1) {
      widgets.value.splice(index, 1)
    }
  }
  
  function updateWidget(id: string, updates: Partial<Widget>) {
    const widget = widgets.value.find(w => w.id === id)
    if (widget) {
      Object.assign(widget, {
        ...updates,
        updatedAt: Date.now()
      })
    }
  }
  
  function updateWidgetData(id: string, data: any) {
    const widget = widgets.value.find(w => w.id === id)
    if (widget) {
      widget.data = data
      widget.updatedAt = Date.now()
    }
  }
  
  function clearAllWidgets() {
    widgets.value = []
  }
  
  function generateWidgetId(): string {
    return `widget_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
  
  return {
    // 状态
    widgets,
    layout,
    performance,
    
    // 计算属性
    activeWidgets,
    widgetsByType,
    
    // 操作
    addWidget,
    removeWidget,
    updateWidget,
    updateWidgetData,
    clearAllWidgets
  }
})
```

## 3. 具体组件实现

### 3.1 数据图表组件（Plot Widget）

```vue
<!-- PlotWidget.vue -->
<template>
  <BaseWidget
    type="plot"
    :title="dataset?.title || 'Data Plot'"
    :dataset="dataset"
    @resize="handleResize"
  >
    <template #default="{ data }">
      <div class="plot-container" ref="plotContainer">
        <canvas 
          ref="plotCanvas"
          :width="canvasSize.width"
          :height="canvasSize.height"
          @mousemove="handleMouseMove"
          @mousedown="handleMouseDown"
          @mouseup="handleMouseUp"
          @wheel="handleWheel"
        />
        
        <div class="plot-controls" v-if="showControls">
          <el-button-group size="small">
            <el-button @click="resetZoom">
              <el-icon><RefreshLeft /></el-icon>
            </el-button>
            <el-button @click="toggleAutoscale" :type="autoscale ? 'primary' : ''">
              <el-icon><Aim /></el-icon>
            </el-button>
            <el-button @click="togglePause" :type="paused ? 'warning' : ''">
              <el-icon v-if="paused"><VideoPlay /></el-icon>
              <el-icon v-else><VideoPause /></el-icon>
            </el-button>
          </el-button-group>
        </div>
        
        <div class="plot-legend" v-if="showLegend">
          <div class="legend-item">
            <span class="legend-color" :style="{ backgroundColor: lineColor }"></span>
            <span class="legend-label">{{ data?.label }}</span>
            <span class="legend-value">{{ formatValue(data?.value) }} {{ data?.units }}</span>
          </div>
        </div>
      </div>
    </template>
  </BaseWidget>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch, computed, nextTick } from 'vue'
import BaseWidget from './BaseWidget.vue'
import { Chart, registerables } from 'chart.js'
import 'chartjs-adapter-date-fns'

Chart.register(...registerables)

interface Props {
  dataset: Dataset
  maxDataPoints?: number
  showControls?: boolean
  showLegend?: boolean
  enableZoom?: boolean
  enablePan?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  maxDataPoints: 1000,
  showControls: true,
  showLegend: true,
  enableZoom: true,
  enablePan: true
})

// 响应式引用
const plotContainer = ref<HTMLElement>()
const plotCanvas = ref<HTMLCanvasElement>()
const chart = ref<Chart | null>(null)
const canvasSize = ref({ width: 400, height: 300 })

// 组件状态
const paused = ref(false)
const autoscale = ref(true)
const dataPoints = ref<DataPoint[]>([])

// 交互状态
const isDragging = ref(false)
const lastMousePos = ref({ x: 0, y: 0 })

// 计算属性
const lineColor = computed(() => {
  return props.dataset?.color || '#409EFF'
})

const chartConfig = computed(() => ({
  type: 'line' as const,
  data: {
    datasets: [{
      label: props.dataset?.title || 'Data',
      data: dataPoints.value,
      borderColor: lineColor.value,
      backgroundColor: lineColor.value + '20',
      borderWidth: 2,
      pointRadius: 0,
      fill: false,
      tension: 0.1
    }]
  },
  options: {
    responsive: false,
    maintainAspectRatio: false,
    animation: {
      duration: 0 // 禁用动画以提高性能
    },
    interaction: {
      intersect: false,
      mode: 'index' as const
    },
    plugins: {
      legend: {
        display: false
      },
      tooltip: {
        enabled: true,
        callbacks: {
          label: (context: any) => {
            return `${context.parsed.y.toFixed(3)} ${props.dataset?.units || ''}`
          }
        }
      }
    },
    scales: {
      x: {
        type: 'time' as const,
        time: {
          displayFormats: {
            millisecond: 'HH:mm:ss.SSS',
            second: 'HH:mm:ss',
            minute: 'HH:mm',
            hour: 'HH:mm'
          }
        },
        title: {
          display: true,
          text: 'Time'
        }
      },
      y: {
        title: {
          display: true,
          text: props.dataset?.units || 'Value'
        },
        min: autoscale.value ? undefined : props.dataset?.min,
        max: autoscale.value ? undefined : props.dataset?.max
      }
    }
  }
}))

// 生命周期
onMounted(() => {
  initializeChart()
})

onUnmounted(() => {
  destroyChart()
})

// 监听器
watch(() => props.dataset?.value, (newValue) => {
  if (!paused.value && newValue !== undefined) {
    addDataPoint(parseFloat(newValue), Date.now())
  }
})

watch(canvasSize, () => {
  nextTick(() => {
    resizeChart()
  })
}, { deep: true })

// 方法实现
function initializeChart() {
  if (!plotCanvas.value) return
  
  chart.value = new Chart(plotCanvas.value, chartConfig.value)
}

function destroyChart() {
  if (chart.value) {
    chart.value.destroy()
    chart.value = null
  }
}

function addDataPoint(value: number, timestamp: number) {
  dataPoints.value.push({
    x: timestamp,
    y: value
  })
  
  // 限制数据点数量
  if (dataPoints.value.length > props.maxDataPoints) {
    dataPoints.value.shift()
  }
  
  updateChart()
}

function updateChart() {
  if (!chart.value) return
  
  chart.value.data.datasets[0].data = dataPoints.value
  chart.value.update('none') // 无动画更新
}

function resizeChart() {
  if (!chart.value) return
  
  chart.value.resize()
}

function handleResize(size: { width: number; height: number }) {
  canvasSize.value = {
    width: size.width - 32, // 减去padding
    height: size.height - 100 // 减去header和controls高度
  }
}

function resetZoom() {
  if (!chart.value) return
  
  chart.value.resetZoom()
}

function toggleAutoscale() {
  autoscale.value = !autoscale.value
  
  if (chart.value) {
    chart.value.options.scales!.y!.min = autoscale.value ? undefined : props.dataset?.min
    chart.value.options.scales!.y!.max = autoscale.value ? undefined : props.dataset?.max
    chart.value.update()
  }
}

function togglePause() {
  paused.value = !paused.value
}

function formatValue(value: number | undefined): string {
  if (value === undefined) return '--'
  return value.toFixed(3)
}

// 鼠标交互
function handleMouseMove(event: MouseEvent) {
  if (!isDragging.value || !props.enablePan) return
  
  const deltaX = event.clientX - lastMousePos.value.x
  const deltaY = event.clientY - lastMousePos.value.y
  
  // 实现平移逻辑
  if (chart.value) {
    // Chart.js平移实现
  }
  
  lastMousePos.value = { x: event.clientX, y: event.clientY }
}

function handleMouseDown(event: MouseEvent) {
  if (!props.enablePan) return
  
  isDragging.value = true
  lastMousePos.value = { x: event.clientX, y: event.clientY }
}

function handleMouseUp() {
  isDragging.value = false
}

function handleWheel(event: WheelEvent) {
  if (!props.enableZoom) return
  
  event.preventDefault()
  
  // 实现缩放逻辑
  if (chart.value) {
    const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1
    // Chart.js缩放实现
  }
}

interface DataPoint {
  x: number
  y: number
}
</script>

<style scoped>
.plot-container {
  position: relative;
  width: 100%;
  height: 100%;
}

.plot-controls {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 10;
}

.plot-legend {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(255, 255, 255, 0.9);
  padding: 8px 12px;
  border-radius: 4px;
  border: 1px solid #e4e7ed;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
}

.legend-color {
  width: 12px;
  height: 12px;
  border-radius: 2px;
}

.legend-value {
  font-weight: bold;
  margin-left: auto;
}
</style>
```

### 3.2 仪表盘组件（Gauge Widget）

```vue
<!-- GaugeWidget.vue -->
<template>
  <BaseWidget
    type="gauge"
    :title="dataset?.title || 'Gauge'"
    :dataset="dataset"
    @resize="handleResize"
  >
    <template #default="{ data }">
      <div class="gauge-container" ref="gaugeContainer">
        <svg 
          :width="size" 
          :height="size"
          :viewBox="`0 0 ${size} ${size}`"
          class="gauge-svg"
        >
          <!-- 背景圆弧 -->
          <path
            :d="backgroundArc"
            :stroke="backgroundColor"
            :stroke-width="strokeWidth"
            fill="none"
            stroke-linecap="round"
          />
          
          <!-- 数值圆弧 -->
          <path
            :d="valueArc"
            :stroke="valueColor"
            :stroke-width="strokeWidth"
            fill="none"
            stroke-linecap="round"
            class="value-arc"
          />
          
          <!-- 指针 -->
          <g v-if="showNeedle" :transform="`translate(${center.x}, ${center.y})`">
            <line
              :x1="0"
              :y1="0"
              :x2="needleEndX"
              :y2="needleEndY"
              :stroke="needleColor"
              :stroke-width="needleWidth"
              stroke-linecap="round"
            />
            <circle
              :cx="0"
              :cy="0"
              :r="needleWidth * 2"
              :fill="needleColor"
            />
          </g>
          
          <!-- 刻度标记 -->
          <g v-if="showTicks">
            <g
              v-for="(tick, index) in ticks"
              :key="index"
              :transform="`translate(${center.x}, ${center.y})`"
            >
              <line
                :x1="tick.x1"
                :y1="tick.y1"
                :x2="tick.x2"
                :y2="tick.y2"
                :stroke="tickColor"
                :stroke-width="tick.major ? 2 : 1"
              />
              <text
                v-if="tick.major"
                :x="tick.labelX"
                :y="tick.labelY"
                :font-size="fontSize"
                :fill="textColor"
                text-anchor="middle"
                dominant-baseline="central"
              >
                {{ tick.value }}
              </text>
            </g>
          </g>
          
          <!-- 中心数值显示 -->
          <text
            :x="center.x"
            :y="center.y + 20"
            :font-size="valueFontSize"
            :fill="textColor"
            text-anchor="middle"
            dominant-baseline="central"
            class="gauge-value"
          >
            {{ formatValue(data?.value) }}
          </text>
          
          <!-- 单位显示 -->
          <text
            :x="center.x"
            :y="center.y + 45"
            :font-size="unitFontSize"
            :fill="secondaryTextColor"
            text-anchor="middle"
            dominant-baseline="central"
            class="gauge-unit"
          >
            {{ data?.units }}
          </text>
        </svg>
        
        <!-- 状态指示器 -->
        <div v-if="showStatus" class="gauge-status" :class="statusClass">
          <el-icon><Warning /></el-icon>
          <span>{{ statusText }}</span>
        </div>
      </div>
    </template>
  </BaseWidget>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import BaseWidget from './BaseWidget.vue'

interface Props {
  dataset: Dataset
  showNeedle?: boolean
  showTicks?: boolean
  showStatus?: boolean
  startAngle?: number
  endAngle?: number
  tickCount?: number
}

const props = withDefaults(defineProps<Props>(), {
  showNeedle: true,
  showTicks: true,
  showStatus: true,
  startAngle: -150,
  endAngle: 150,
  tickCount: 10
})

// 响应式数据
const gaugeContainer = ref<HTMLElement>()
const size = ref(200)

// 计算属性
const center = computed(() => ({
  x: size.value / 2,
  y: size.value / 2
}))

const radius = computed(() => size.value / 2 - 30)
const strokeWidth = computed(() => Math.max(8, size.value / 25))
const needleWidth = computed(() => Math.max(2, size.value / 100))
const fontSize = computed(() => Math.max(10, size.value / 20))
const valueFontSize = computed(() => Math.max(16, size.value / 12))
const unitFontSize = computed(() => Math.max(12, size.value / 16))

const backgroundColor = computed(() => '#e4e7ed')
const textColor = computed(() => '#606266')
const secondaryTextColor = computed(() => '#909399')
const tickColor = computed(() => '#c0c4cc')
const needleColor = computed(() => '#409eff')

const valueColor = computed(() => {
  const value = parseFloat(props.dataset?.value || '0')
  const alarm = props.dataset?.alarm || 0
  
  if (alarm > 0 && value >= alarm) {
    return '#f56c6c' // 红色警告
  } else if (value >= (props.dataset?.max || 100) * 0.8) {
    return '#e6a23c' // 橙色警告
  }
  return '#67c23a' // 正常绿色
})

const currentValue = computed(() => {
  const value = parseFloat(props.dataset?.value || '0')
  const min = props.dataset?.min || 0
  const max = props.dataset?.max || 100
  return Math.max(min, Math.min(max, value))
})

const valuePercentage = computed(() => {
  const min = props.dataset?.min || 0
  const max = props.dataset?.max || 100
  return (currentValue.value - min) / (max - min)
})

const valueAngle = computed(() => {
  const totalAngle = props.endAngle - props.startAngle
  return props.startAngle + totalAngle * valuePercentage.value
})

const backgroundArc = computed(() => {
  return createArc(
    center.value.x,
    center.value.y,
    radius.value,
    props.startAngle,
    props.endAngle
  )
})

const valueArc = computed(() => {
  return createArc(
    center.value.x,
    center.value.y,
    radius.value,
    props.startAngle,
    valueAngle.value
  )
})

const needleEndX = computed(() => {
  const angle = (valueAngle.value - 90) * Math.PI / 180
  return Math.cos(angle) * (radius.value - 10)
})

const needleEndY = computed(() => {
  const angle = (valueAngle.value - 90) * Math.PI / 180
  return Math.sin(angle) * (radius.value - 10)
})

const ticks = computed(() => {
  const tickList = []
  const min = props.dataset?.min || 0
  const max = props.dataset?.max || 100
  const totalAngle = props.endAngle - props.startAngle
  
  for (let i = 0; i <= props.tickCount; i++) {
    const value = min + (max - min) * (i / props.tickCount)
    const angle = props.startAngle + totalAngle * (i / props.tickCount)
    const radian = (angle - 90) * Math.PI / 180
    const major = i % (props.tickCount / 5) === 0
    
    const innerRadius = radius.value - strokeWidth.value / 2 - (major ? 10 : 5)
    const outerRadius = radius.value - strokeWidth.value / 2
    const labelRadius = innerRadius - 15
    
    tickList.push({
      value: Math.round(value),
      major,
      x1: Math.cos(radian) * innerRadius,
      y1: Math.sin(radian) * innerRadius,
      x2: Math.cos(radian) * outerRadius,
      y2: Math.sin(radian) * outerRadius,
      labelX: Math.cos(radian) * labelRadius,
      labelY: Math.sin(radian) * labelRadius
    })
  }
  
  return tickList
})

const statusClass = computed(() => {
  const value = parseFloat(props.dataset?.value || '0')
  const alarm = props.dataset?.alarm || 0
  
  if (alarm > 0 && value >= alarm) {
    return 'status-alarm'
  } else if (value >= (props.dataset?.max || 100) * 0.8) {
    return 'status-warning'
  }
  return 'status-normal'
})

const statusText = computed(() => {
  const value = parseFloat(props.dataset?.value || '0')
  const alarm = props.dataset?.alarm || 0
  
  if (alarm > 0 && value >= alarm) {
    return 'ALARM'
  } else if (value >= (props.dataset?.max || 100) * 0.8) {
    return 'WARNING'
  }
  return 'NORMAL'
})

// 方法
function createArc(x: number, y: number, radius: number, startAngle: number, endAngle: number): string {
  const start = polarToCartesian(x, y, radius, endAngle)
  const end = polarToCartesian(x, y, radius, startAngle)
  const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1'
  
  return [
    'M', start.x, start.y,
    'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y
  ].join(' ')
}

function polarToCartesian(centerX: number, centerY: number, radius: number, angleInDegrees: number) {
  const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0
  
  return {
    x: centerX + (radius * Math.cos(angleInRadians)),
    y: centerY + (radius * Math.sin(angleInRadians))
  }
}

function formatValue(value: number | undefined): string {
  if (value === undefined) return '--'
  return value.toFixed(1)
}

function handleResize(containerSize: { width: number; height: number }) {
  size.value = Math.min(containerSize.width, containerSize.height) - 40
}
</script>

<style scoped>
.gauge-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  position: relative;
}

.gauge-svg {
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
}

.value-arc {
  transition: stroke-dasharray 0.3s ease;
}

.gauge-value {
  font-weight: bold;
}

.gauge-status {
  position: absolute;
  bottom: 10px;
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: bold;
}

.status-normal {
  background: #f0f9ff;
  color: #67c23a;
}

.status-warning {
  background: #fdf6ec;
  color: #e6a23c;
}

.status-alarm {
  background: #fef0f0;
  color: #f56c6c;
}
</style>
```

### 3.3 GPS地图组件（GPS Widget）

```vue
<!-- GPSWidget.vue -->
<template>
  <BaseWidget
    type="gps"
    :title="group?.title || 'GPS Location'"
    :group="group"
    :show-fullscreen="true"
    @resize="handleResize"
    @fullscreen="handleFullscreen"
  >
    <template #default="{ data }">
      <div class="gps-container" ref="mapContainer">
        <div id="map" class="gps-map" ref="map"></div>
        
        <div class="gps-controls">
          <el-button-group size="small">
            <el-button @click="centerOnPosition" :disabled="!hasValidPosition">
              <el-icon><Aim /></el-icon>
            </el-button>
            <el-button @click="toggleTracking" :type="tracking ? 'primary' : ''">
              <el-icon><Location /></el-icon>
            </el-button>
            <el-button @click="clearTrail">
              <el-icon><Delete /></el-icon>
            </el-button>
            <el-button @click="toggleSatelliteView">
              <el-icon><View /></el-icon>
            </el-button>
          </el-button-group>
        </div>
        
        <div class="gps-info" v-if="showInfo && hasValidPosition">
          <div class="info-row">
            <span class="info-label">Latitude:</span>
            <span class="info-value">{{ formatCoordinate(currentPosition.lat) }}°</span>
          </div>
          <div class="info-row">
            <span class="info-label">Longitude:</span>
            <span class="info-value">{{ formatCoordinate(currentPosition.lng) }}°</span>
          </div>
          <div class="info-row">
            <span class="info-label">Altitude:</span>
            <span class="info-value">{{ formatAltitude(currentPosition.alt) }} m</span>
          </div>
          <div class="info-row">
            <span class="info-label">Speed:</span>
            <span class="info-value">{{ formatSpeed(currentSpeed) }} km/h</span>
          </div>
          <div class="info-row">
            <span class="info-label">Distance:</span>
            <span class="info-value">{{ formatDistance(totalDistance) }} km</span>
          </div>
        </div>
      </div>
    </template>
  </BaseWidget>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch, computed, nextTick } from 'vue'
import BaseWidget from './BaseWidget.vue'
import L from 'leaflet'
import 'leaflet/dist/leaflet.css'

interface Props {
  group: Group
  showInfo?: boolean
  maxTrailPoints?: number
  showAccuracy?: boolean
  enableMeasurement?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  showInfo: true,
  maxTrailPoints: 1000,
  showAccuracy: true,
  enableMeasurement: false
})

// 响应式引用
const mapContainer = ref<HTMLElement>()
const map = ref<HTMLElement>()
const leafletMap = ref<L.Map | null>(null)

// 组件状态
const tracking = ref(true)
const satelliteView = ref(false)
const trailPoints = ref<L.LatLng[]>([])
const totalDistance = ref(0)
const currentSpeed = ref(0)

// Leaflet 图层
const currentMarker = ref<L.Marker | null>(null)
const accuracyCircle = ref<L.Circle | null>(null)
const trailPolyline = ref<L.Polyline | null>(null)

// 计算属性
const latDataset = computed(() => 
  props.group?.datasets.find(d => d.widget === 'lat' || d.title.toLowerCase().includes('lat'))
)

const lngDataset = computed(() => 
  props.group?.datasets.find(d => d.widget === 'lng' || d.title.toLowerCase().includes('lon'))
)

const altDataset = computed(() => 
  props.group?.datasets.find(d => d.widget === 'alt' || d.title.toLowerCase().includes('alt'))
)

const currentPosition = computed(() => ({
  lat: parseFloat(latDataset.value?.value || '0'),
  lng: parseFloat(lngDataset.value?.value || '0'),
  alt: parseFloat(altDataset.value?.value || '0')
}))

const hasValidPosition = computed(() => {
  const pos = currentPosition.value
  return pos.lat !== 0 && pos.lng !== 0 && 
         Math.abs(pos.lat) <= 90 && Math.abs(pos.lng) <= 180
})

// 生命周期
onMounted(() => {
  nextTick(() => {
    initializeMap()
  })
})

onUnmounted(() => {
  destroyMap()
})

// 监听器
watch(currentPosition, (newPos, oldPos) => {
  if (hasValidPosition.value) {
    updatePosition(newPos, oldPos)
  }
}, { deep: true })

// 方法实现
function initializeMap() {
  if (!map.value) return
  
  // 创建地图实例
  leafletMap.value = L.map(map.value, {
    center: [39.9042, 116.4074], // 默认北京
    zoom: 13,
    zoomControl: true,
    attributionControl: true
  })
  
  // 添加瓦片图层
  const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  })
  
  const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: '© Esri'
  })
  
  // 添加默认图层
  osmLayer.addTo(leafletMap.value)
  
  // 创建图层控制
  const baseMaps = {
    'Street': osmLayer,
    'Satellite': satelliteLayer
  }
  
  L.control.layers(baseMaps).addTo(leafletMap.value)
  
  // 创建自定义控件
  createCustomControls()
}

function destroyMap() {
  if (leafletMap.value) {
    leafletMap.value.remove()
    leafletMap.value = null
  }
}

function updatePosition(newPos: Position, oldPos?: Position) {
  if (!leafletMap.value || !hasValidPosition.value) return
  
  const latLng = L.latLng(newPos.lat, newPos.lng)
  
  // 更新当前位置标记
  if (currentMarker.value) {
    currentMarker.value.setLatLng(latLng)
  } else {
    currentMarker.value = L.marker(latLng, {
      icon: createLocationIcon()
    }).addTo(leafletMap.value)
    
    currentMarker.value.bindPopup(`
      <div class="location-popup">
        <strong>Current Position</strong><br>
        Lat: ${formatCoordinate(newPos.lat)}°<br>
        Lng: ${formatCoordinate(newPos.lng)}°<br>
        Alt: ${formatAltitude(newPos.alt)} m
      </div>
    `)
  }
  
  // 更新精度圆圈
  if (props.showAccuracy) {
    const accuracy = 10 // 假设精度为10米
    if (accuracyCircle.value) {
      accuracyCircle.value.setLatLng(latLng).setRadius(accuracy)
    } else {
      accuracyCircle.value = L.circle(latLng, {
        radius: accuracy,
        color: '#409eff',
        fillColor: '#409eff',
        fillOpacity: 0.2,
        weight: 2
      }).addTo(leafletMap.value)
    }
  }
  
  // 更新轨迹
  if (tracking.value) {
    trailPoints.value.push(latLng)
    
    // 限制轨迹点数量
    if (trailPoints.value.length > props.maxTrailPoints) {
      trailPoints.value.shift()
    }
    
    // 更新轨迹线
    if (trailPolyline.value) {
      trailPolyline.value.setLatLngs(trailPoints.value)
    } else if (trailPoints.value.length > 1) {
      trailPolyline.value = L.polyline(trailPoints.value, {
        color: '#67c23a',
        weight: 3,
        opacity: 0.8
      }).addTo(leafletMap.value)
    }
    
    // 计算距离和速度
    if (oldPos && oldPos.lat !== 0 && oldPos.lng !== 0) {
      const distance = calculateDistance(oldPos, newPos)
      totalDistance.value += distance
      
      // 假设更新间隔为1秒，计算速度
      currentSpeed.value = distance * 3.6 // m/s to km/h
    }
    
    // 自动居中到当前位置
    if (tracking.value) {
      leafletMap.value.setView(latLng, leafletMap.value.getZoom())
    }
  }
}

function createLocationIcon(): L.Icon {
  return L.icon({
    iconUrl: 'data:image/svg+xml;base64,' + btoa(`
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="8" fill="#409eff" stroke="white" stroke-width="2"/>
        <circle cx="12" cy="12" r="3" fill="white"/>
      </svg>
    `),
    iconSize: [24, 24],
    iconAnchor: [12, 12],
    popupAnchor: [0, -12]
  })
}

function createCustomControls() {
  if (!leafletMap.value) return
  
  // 创建自定义控件容器
  const customControl = L.control({ position: 'topright' })
  
  customControl.onAdd = function() {
    const div = L.DomUtil.create('div', 'custom-control')
    div.innerHTML = `
      <div class="control-button" id="center-btn" title="Center on position">📍</div>
      <div class="control-button" id="track-btn" title="Toggle tracking">🎯</div>
      <div class="control-button" id="clear-btn" title="Clear trail">🗑️</div>
    `
    
    // 阻止地图事件冒泡
    L.DomEvent.disableClickPropagation(div)
    
    return div
  }
  
  customControl.addTo(leafletMap.value)
}

function centerOnPosition() {
  if (!leafletMap.value || !hasValidPosition.value) return
  
  const pos = currentPosition.value
  leafletMap.value.setView([pos.lat, pos.lng], 16)
}

function toggleTracking() {
  tracking.value = !tracking.value
}

function clearTrail() {
  trailPoints.value = []
  totalDistance.value = 0
  
  if (trailPolyline.value) {
    leafletMap.value?.removeLayer(trailPolyline.value)
    trailPolyline.value = null
  }
}

function toggleSatelliteView() {
  satelliteView.value = !satelliteView.value
  // 切换图层逻辑
}

function calculateDistance(pos1: Position, pos2: Position): number {
  const R = 6371e3 // 地球半径（米）
  const φ1 = pos1.lat * Math.PI / 180
  const φ2 = pos2.lat * Math.PI / 180
  const Δφ = (pos2.lat - pos1.lat) * Math.PI / 180
  const Δλ = (pos2.lng - pos1.lng) * Math.PI / 180
  
  const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))
  
  return R * c // 距离（米）
}

function formatCoordinate(coord: number): string {
  return coord.toFixed(6)
}

function formatAltitude(alt: number): string {
  return alt.toFixed(1)
}

function formatSpeed(speed: number): string {
  return speed.toFixed(1)
}

function formatDistance(distance: number): string {
  return (distance / 1000).toFixed(2)
}

function handleResize(size: { width: number; height: number }) {
  if (leafletMap.value) {
    leafletMap.value.invalidateSize()
  }
}

function handleFullscreen(isFullscreen: boolean) {
  nextTick(() => {
    if (leafletMap.value) {
      leafletMap.value.invalidateSize()
    }
  })
}

interface Position {
  lat: number
  lng: number
  alt: number
}
</script>

<style scoped>
.gps-container {
  position: relative;
  width: 100%;
  height: 100%;
}

.gps-map {
  width: 100%;
  height: 100%;
  border-radius: 6px;
  overflow: hidden;
}

.gps-controls {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 1000;
}

.gps-info {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(255, 255, 255, 0.95);
  padding: 12px;
  border-radius: 6px;
  min-width: 200px;
  font-size: 12px;
  z-index: 1000;
}

.info-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
}

.info-row:last-child {
  margin-bottom: 0;
}

.info-label {
  color: #909399;
}

.info-value {
  font-weight: bold;
  color: #303133;
}

/* Leaflet 自定义样式 */
:deep(.custom-control) {
  background: white;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

:deep(.control-button) {
  padding: 8px;
  cursor: pointer;
  border-bottom: 1px solid #eee;
}

:deep(.control-button:last-child) {
  border-bottom: none;
}

:deep(.control-button:hover) {
  background: #f5f7fa;
}

:deep(.location-popup) {
  text-align: center;
  font-size: 12px;
}
</style>
```

## 4. 性能优化策略

### 4.1 虚拟化渲染系统

```typescript
// composables/useVirtualization.ts
import { ref, computed, nextTick } from 'vue'

export function useVirtualization<T>(
  items: Ref<T[]>,
  itemHeight: number,
  containerHeight: Ref<number>,
  buffer: number = 5
) {
  const scrollTop = ref(0)
  
  const visibleRange = computed(() => {
    const start = Math.floor(scrollTop.value / itemHeight)
    const end = Math.min(
      start + Math.ceil(containerHeight.value / itemHeight) + buffer,
      items.value.length
    )
    
    return {
      start: Math.max(0, start - buffer),
      end
    }
  })
  
  const visibleItems = computed(() => {
    const { start, end } = visibleRange.value
    return items.value.slice(start, end).map((item, index) => ({
      item,
      index: start + index
    }))
  })
  
  const totalHeight = computed(() => items.value.length * itemHeight)
  
  const offsetY = computed(() => visibleRange.value.start * itemHeight)
  
  function handleScroll(event: Event) {
    const target = event.target as HTMLElement
    scrollTop.value = target.scrollTop
  }
  
  return {
    visibleItems,
    totalHeight,
    offsetY,
    handleScroll
  }
}
```

### 4.2 数据缓存和更新优化

```typescript
// composables/useDataCache.ts
import { ref, computed, watch } from 'vue'

interface CacheOptions {
  maxSize: number
  ttl: number // 生存时间（毫秒）
  updateInterval: number // 更新间隔（毫秒）
}

export function useDataCache<T>(options: CacheOptions) {
  const cache = ref(new Map<string, CacheEntry<T>>())
  const lastUpdate = ref(0)
  const pendingUpdates = ref(new Map<string, T>())
  
  let updateTimer: NodeJS.Timeout | null = null
  
  interface CacheEntry<T> {
    data: T
    timestamp: number
    hits: number
  }
  
  function set(key: string, data: T) {
    // 批量更新策略
    pendingUpdates.value.set(key, data)
    
    if (!updateTimer) {
      updateTimer = setTimeout(() => {
        flushUpdates()
        updateTimer = null
      }, options.updateInterval)
    }
  }
  
  function get(key: string): T | null {
    const entry = cache.value.get(key)
    
    if (!entry) return null
    
    // 检查过期
    if (Date.now() - entry.timestamp > options.ttl) {
      cache.value.delete(key)
      return null
    }
    
    // 更新访问计数
    entry.hits++
    return entry.data
  }
  
  function flushUpdates() {
    const now = Date.now()
    
    pendingUpdates.value.forEach((data, key) => {
      cache.value.set(key, {
        data,
        timestamp: now,
        hits: 0
      })
    })
    
    pendingUpdates.value.clear()
    lastUpdate.value = now
    
    // 清理过期数据
    cleanup()
  }
  
  function cleanup() {
    const now = Date.now()
    const entries = Array.from(cache.value.entries())
    
    // 按访问次数和时间排序
    entries.sort((a, b) => {
      const aScore = a[1].hits / (now - a[1].timestamp)
      const bScore = b[1].hits / (now - b[1].timestamp)
      return bScore - aScore
    })
    
    // 保留最常用的数据
    if (entries.length > options.maxSize) {
      const toRemove = entries.slice(options.maxSize)
      toRemove.forEach(([key]) => {
        cache.value.delete(key)
      })
    }
    
    // 移除过期数据
    cache.value.forEach((entry, key) => {
      if (now - entry.timestamp > options.ttl) {
        cache.value.delete(key)
      }
    })
  }
  
  function clear() {
    cache.value.clear()
    pendingUpdates.value.clear()
    if (updateTimer) {
      clearTimeout(updateTimer)
      updateTimer = null
    }
  }
  
  const stats = computed(() => ({
    size: cache.value.size,
    pendingUpdates: pendingUpdates.value.size,
    lastUpdate: lastUpdate.value
  }))
  
  return {
    set,
    get,
    clear,
    stats
  }
}
```

## 5. 响应式设计和主题系统

### 5.1 响应式布局管理

```typescript
// composables/useResponsive.ts
import { ref, computed, onMounted, onUnmounted } from 'vue'

export function useResponsive() {
  const windowWidth = ref(window.innerWidth)
  const windowHeight = ref(window.innerHeight)
  
  const breakpoints = {
    xs: 480,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1920
  }
  
  const currentBreakpoint = computed(() => {
    const width = windowWidth.value
    if (width < breakpoints.xs) return 'xs'
    if (width < breakpoints.sm) return 'sm'
    if (width < breakpoints.md) return 'md'
    if (width < breakpoints.lg) return 'lg'
    return 'xl'
  })
  
  const isMobile = computed(() => ['xs', 'sm'].includes(currentBreakpoint.value))
  const isTablet = computed(() => currentBreakpoint.value === 'md')
  const isDesktop = computed(() => ['lg', 'xl'].includes(currentBreakpoint.value))
  
  const gridCols = computed(() => {
    switch (currentBreakpoint.value) {
      case 'xs': return 1
      case 'sm': return 2
      case 'md': return 3
      case 'lg': return 4
      default: return 6
    }
  })
  
  function handleResize() {
    windowWidth.value = window.innerWidth
    windowHeight.value = window.innerHeight
  }
  
  onMounted(() => {
    window.addEventListener('resize', handleResize)
  })
  
  onUnmounted(() => {
    window.removeEventListener('resize', handleResize)
  })
  
  return {
    windowWidth,
    windowHeight,
    currentBreakpoint,
    isMobile,
    isTablet,
    isDesktop,
    gridCols
  }
}
```

### 5.2 主题系统实现

```typescript
// stores/theme.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useThemeStore = defineStore('theme', () => {
  const currentTheme = ref<'light' | 'dark' | 'auto'>('auto')
  const customColors = ref<Record<string, string>>({})
  
  const systemTheme = ref<'light' | 'dark'>('light')
  
  // 监听系统主题变化
  const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
  systemTheme.value = mediaQuery.matches ? 'dark' : 'light'
  
  mediaQuery.addEventListener('change', (e) => {
    systemTheme.value = e.matches ? 'dark' : 'light'
  })
  
  const effectiveTheme = computed(() => {
    if (currentTheme.value === 'auto') {
      return systemTheme.value
    }
    return currentTheme.value
  })
  
  const themeColors = computed(() => {
    const baseColors = effectiveTheme.value === 'dark' ? darkColors : lightColors
    return { ...baseColors, ...customColors.value }
  })
  
  const primaryColor = computed(() => themeColors.value.primary)
  const backgroundColor = computed(() => themeColors.value.background)
  const textColor = computed(() => themeColors.value.text)
  const borderColor = computed(() => themeColors.value.border)
  
  function setTheme(theme: 'light' | 'dark' | 'auto') {
    currentTheme.value = theme
    applyTheme()
  }
  
  function setCustomColor(key: string, color: string) {
    customColors.value[key] = color
    applyTheme()
  }
  
  function applyTheme() {
    const root = document.documentElement
    const colors = themeColors.value
    
    Object.entries(colors).forEach(([key, value]) => {
      root.style.setProperty(`--theme-${key}`, value)
    })
    
    // 应用到 Element Plus
    root.style.setProperty('--el-color-primary', colors.primary)
    root.style.setProperty('--el-bg-color', colors.background)
    root.style.setProperty('--el-text-color-primary', colors.text)
  }
  
  return {
    currentTheme,
    effectiveTheme,
    themeColors,
    primaryColor,
    backgroundColor,
    textColor,
    borderColor,
    setTheme,
    setCustomColor
  }
})

const lightColors = {
  primary: '#409eff',
  success: '#67c23a',
  warning: '#e6a23c',
  danger: '#f56c6c',
  info: '#909399',
  background: '#ffffff',
  surface: '#f5f7fa',
  text: '#303133',
  textSecondary: '#606266',
  textPlaceholder: '#c0c4cc',
  border: '#dcdfe6',
  borderLight: '#e4e7ed',
  borderLighter: '#ebeef5',
  borderExtraLight: '#f2f6fc'
}

const darkColors = {
  primary: '#409eff',
  success: '#67c23a',
  warning: '#e6a23c',
  danger: '#f56c6c',
  info: '#909399',
  background: '#1a1a1a',
  surface: '#2d2d2d',
  text: '#e0e0e0',
  textSecondary: '#b0b0b0',
  textPlaceholder: '#808080',
  border: '#404040',
  borderLight: '#505050',
  borderLighter: '#606060',
  borderExtraLight: '#707070'
}
```

## 6. 测试和调试工具

### 6.1 组件测试框架

```typescript
// tests/components/PlotWidget.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia } from 'pinia'
import PlotWidget from '@/components/PlotWidget.vue'

describe('PlotWidget', () => {
  let wrapper: any
  let pinia: any
  
  const mockDataset = {
    title: 'Test Dataset',
    value: '25.5',
    units: '°C',
    min: 0,
    max: 100,
    alarm: 80
  }
  
  beforeEach(() => {
    pinia = createPinia()
    
    wrapper = mount(PlotWidget, {
      global: {
        plugins: [pinia]
      },
      props: {
        dataset: mockDataset
      }
    })
  })
  
  it('renders correctly', () => {
    expect(wrapper.exists()).toBe(true)
    expect(wrapper.find('.plot-container').exists()).toBe(true)
  })
  
  it('displays correct title', () => {
    expect(wrapper.find('.widget-title').text()).toBe('Test Dataset')
  })
  
  it('handles data updates', async () => {
    const newDataset = { ...mockDataset, value: '30.2' }
    await wrapper.setProps({ dataset: newDataset })
    
    // 验证数据更新逻辑
  })
  
  it('handles resize events', async () => {
    const resizeSpy = vi.spyOn(wrapper.vm, 'handleResize')
    
    wrapper.vm.handleResize({ width: 500, height: 300 })
    
    expect(resizeSpy).toHaveBeenCalledWith({ width: 500, height: 300 })
  })
  
  it('exports data correctly', async () => {
    const exportSpy = vi.spyOn(wrapper.vm, 'exportData')
    
    await wrapper.find('.export-button').trigger('click')
    
    expect(exportSpy).toHaveBeenCalled()
  })
})
```

### 6.2 性能监控工具

```typescript
// utils/performance.ts
export class PerformanceMonitor {
  private static instance: PerformanceMonitor
  private metrics: Map<string, PerformanceMetrics> = new Map()
  
  static getInstance(): PerformanceMonitor {
    if (!this.instance) {
      this.instance = new PerformanceMonitor()
    }
    return this.instance
  }
  
  startMeasure(name: string): void {
    performance.mark(`${name}-start`)
  }
  
  endMeasure(name: string): number {
    performance.mark(`${name}-end`)
    performance.measure(name, `${name}-start`, `${name}-end`)
    
    const measure = performance.getEntriesByName(name)[0]
    const duration = measure.duration
    
    this.recordMetric(name, duration)
    
    // 清理 marks 和 measures
    performance.clearMarks(`${name}-start`)
    performance.clearMarks(`${name}-end`)
    performance.clearMeasures(name)
    
    return duration
  }
  
  private recordMetric(name: string, duration: number): void {
    let metric = this.metrics.get(name)
    
    if (!metric) {
      metric = {
        name,
        count: 0,
        totalTime: 0,
        minTime: Infinity,
        maxTime: 0,
        avgTime: 0
      }
      this.metrics.set(name, metric)
    }
    
    metric.count++
    metric.totalTime += duration
    metric.minTime = Math.min(metric.minTime, duration)
    metric.maxTime = Math.max(metric.maxTime, duration)
    metric.avgTime = metric.totalTime / metric.count
  }
  
  getMetrics(): PerformanceMetrics[] {
    return Array.from(this.metrics.values())
  }
  
  getMetric(name: string): PerformanceMetrics | undefined {
    return this.metrics.get(name)
  }
  
  reset(): void {
    this.metrics.clear()
  }
  
  generateReport(): string {
    const metrics = this.getMetrics()
    
    if (metrics.length === 0) {
      return 'No performance data available'
    }
    
    let report = 'Performance Report\n==================\n\n'
    
    metrics.forEach(metric => {
      report += `${metric.name}:\n`
      report += `  Count: ${metric.count}\n`
      report += `  Total: ${metric.totalTime.toFixed(2)}ms\n`
      report += `  Average: ${metric.avgTime.toFixed(2)}ms\n`
      report += `  Min: ${metric.minTime.toFixed(2)}ms\n`
      report += `  Max: ${metric.maxTime.toFixed(2)}ms\n\n`
    })
    
    return report
  }
}

interface PerformanceMetrics {
  name: string
  count: number
  totalTime: number
  minTime: number
  maxTime: number
  avgTime: number
}

// 装饰器用法
export function measure(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const method = descriptor.value
  
  descriptor.value = function (...args: any[]) {
    const monitor = PerformanceMonitor.getInstance()
    const measureName = `${target.constructor.name}.${propertyName}`
    
    monitor.startMeasure(measureName)
    const result = method.apply(this, args)
    monitor.endMeasure(measureName)
    
    return result
  }
  
  return descriptor
}
```

这个可视化组件设计提供了完整的组件架构，包括基础组件、具体实现、性能优化、响应式设计和测试框架。通过模块化和可复用的设计，确保了系统的可维护性和可扩展性，同时提供了优秀的用户体验和开发体验。