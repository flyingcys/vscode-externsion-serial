# Serial-Studio VSCode æ’ä»¶å¯è§†åŒ–ç»„ä»¶è®¾è®¡

## 1. å¯è§†åŒ–ç»„ä»¶æ¶æ„æ¦‚è¿°

åŸºäºå¯¹ Serial-Studio UI æ¨¡å—çš„æ·±åº¦åˆ†æï¼Œå¯è§†åŒ–ç»„ä»¶æ˜¯ç”¨æˆ·ç•Œé¢çš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œè´Ÿè´£å°†ç»“æ„åŒ–æ•°æ®è½¬æ¢ä¸ºç›´è§‚çš„å›¾å½¢ç•Œé¢ã€‚æœ¬è®¾è®¡é‡‡ç”¨ Vue3 + Element Plus + ä¸“ä¸šå›¾è¡¨åº“çš„æŠ€æœ¯æ ˆï¼Œå®ç°é«˜æ€§èƒ½ã€å¯æ‰©å±•çš„æ•°æ®å¯è§†åŒ–ç³»ç»Ÿã€‚

### 1.1 ç»„ä»¶åˆ†ç±»ä½“ç³»

æ ¹æ® Serial-Studio çš„ç»„ä»¶åˆ†æï¼Œå¯è§†åŒ–ç»„ä»¶åˆ†ä¸ºä¸‰ä¸ªå±‚æ¬¡ï¼š

1. **æ•°æ®é›†ç»„ä»¶**ï¼ˆDataset Widgetsï¼‰
   - Plotï¼ˆæ•°æ®å›¾è¡¨ï¼‰
   - Barï¼ˆæ¡å½¢å›¾ï¼‰
   - Gaugeï¼ˆä»ªè¡¨ç›˜ï¼‰
   - Compassï¼ˆæŒ‡å—é’ˆï¼‰
   - FFTï¼ˆé¢‘è°±åˆ†æï¼‰
   - LEDï¼ˆæŒ‡ç¤ºç¯ï¼‰

2. **åˆ†ç»„ç»„ä»¶**ï¼ˆGroup Widgetsï¼‰
   - DataGridï¼ˆæ•°æ®ç½‘æ ¼ï¼‰
   - MultiPlotï¼ˆå¤šæ•°æ®å›¾è¡¨ï¼‰
   - Accelerometerï¼ˆåŠ é€Ÿåº¦è®¡ï¼‰
   - Gyroscopeï¼ˆé™€èºä»ªï¼‰
   - GPSï¼ˆåœ°å›¾æ˜¾ç¤ºï¼‰
   - Terminalï¼ˆç»ˆç«¯æ˜¾ç¤ºï¼‰
   - Plot3Dï¼ˆ3Dç»˜å›¾ï¼‰

3. **ç³»ç»Ÿç»„ä»¶**ï¼ˆSystem Widgetsï¼‰
   - Dashboardï¼ˆä»ªè¡¨æ¿å®¹å™¨ï¼‰
   - ActionPanelï¼ˆæ“ä½œé¢æ¿ï¼‰
   - ConnectionPanelï¼ˆè¿æ¥é¢æ¿ï¼‰
   - ProjectEditorï¼ˆé¡¹ç›®ç¼–è¾‘å™¨ï¼‰

### 1.2 æŠ€æœ¯æ ˆé€‰æ‹©

```typescript
// æ ¸å¿ƒæ¡†æ¶
Vue3 (Composition API)
Element Plus (UIç»„ä»¶åº“)
Pinia (çŠ¶æ€ç®¡ç†)

// å›¾è¡¨å’Œå¯è§†åŒ–åº“
Chart.js (åŸºç¡€å›¾è¡¨)
D3.js (è‡ªå®šä¹‰å¯è§†åŒ–)
Three.js (3Då¯è§†åŒ–)
Leaflet (åœ°å›¾ç»„ä»¶)
WebGL (é«˜æ€§èƒ½æ¸²æŸ“)

// å·¥å…·åº“
ResizeObserver (å“åº”å¼å¸ƒå±€)
Lodash (å·¥å…·å‡½æ•°)
Color.js (é¢œè‰²å¤„ç†)
Moment.js (æ—¶é—´å¤„ç†)
```

## 2. ç»„ä»¶åŸºç¡€æ¶æ„è®¾è®¡

### 2.1 å¯è§†åŒ–ç»„ä»¶åŸºç±»

```vue
<!-- BaseWidget.vue -->
<template>
  <div 
    class="base-widget"
    :class="[`widget-${type}`, { 'widget-loading': loading, 'widget-error': hasError }]"
    :style="widgetStyle"
    ref="widgetContainer"
  >
    <div class="widget-header" v-if="showHeader">
      <h3 class="widget-title">{{ title }}</h3>
      <div class="widget-controls">
        <el-button 
          v-if="showFullscreen"
          size="small" 
          type="text" 
          @click="toggleFullscreen"
        >
          <el-icon><FullScreen /></el-icon>
        </el-button>
        <el-button 
          v-if="showExport"
          size="small" 
          type="text" 
          @click="exportData"
        >
          <el-icon><Download /></el-icon>
        </el-button>
      </div>
    </div>
    
    <div class="widget-content" ref="contentContainer">
      <div v-if="loading" class="widget-loading-state">
        <el-skeleton :rows="3" animated />
      </div>
      
      <div v-else-if="hasError" class="widget-error-state">
        <el-alert 
          :title="errorMessage" 
          type="error" 
          :closable="false"
          show-icon 
        />
      </div>
      
      <slot v-else :data="processedData" :config="widgetConfig" />
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed, ref, onMounted, onUnmounted, watch } from 'vue'
import { useDashboardStore } from '@/stores/dashboard'
import { useThemeStore } from '@/stores/theme'

interface Props {
  type: string
  title: string
  dataset?: Dataset
  group?: Group
  config?: WidgetConfig
  showHeader?: boolean
  showFullscreen?: boolean
  showExport?: boolean
  autoResize?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  showHeader: true,
  showFullscreen: true,
  showExport: true,
  autoResize: true
})

const emit = defineEmits<{
  fullscreen: [value: boolean]
  export: [data: any]
  error: [error: Error]
  resize: [size: { width: number; height: number }]
}>()

// å“åº”å¼å¼•ç”¨
const widgetContainer = ref<HTMLElement>()
const contentContainer = ref<HTMLElement>()
const loading = ref(false)
const hasError = ref(false)
const errorMessage = ref('')
const isFullscreen = ref(false)

// çŠ¶æ€ç®¡ç†
const dashboardStore = useDashboardStore()
const themeStore = useThemeStore()

// è®¡ç®—å±æ€§
const widgetStyle = computed(() => ({
  '--widget-primary-color': themeStore.primaryColor,
  '--widget-background-color': themeStore.backgroundColor,
  '--widget-text-color': themeStore.textColor,
  '--widget-border-color': themeStore.borderColor,
}))

const processedData = computed(() => {
  // æ ¹æ®ç»„ä»¶ç±»å‹å¤„ç†æ•°æ®
  if (props.dataset) {
    return processDatasetData(props.dataset)
  } else if (props.group) {
    return processGroupData(props.group)
  }
  return null
})

const widgetConfig = computed(() => ({
  ...props.config,
  theme: themeStore.currentTheme,
  responsive: props.autoResize
}))

// ç”Ÿå‘½å‘¨æœŸé’©å­
onMounted(() => {
  if (props.autoResize) {
    setupResizeObserver()
  }
})

onUnmounted(() => {
  cleanupResizeObserver()
})

// ç›‘å¬å™¨
watch(() => props.dataset, (newDataset) => {
  if (newDataset) {
    updateWidget()
  }
}, { deep: true })

watch(() => props.group, (newGroup) => {
  if (newGroup) {
    updateWidget()
  }
}, { deep: true })

// æ–¹æ³•å®ç°
function processDatasetData(dataset: Dataset) {
  try {
    return {
      value: parseFloat(dataset.value) || 0,
      label: dataset.title,
      units: dataset.units,
      min: dataset.min,
      max: dataset.max,
      alarm: dataset.alarm,
      timestamp: Date.now()
    }
  } catch (error) {
    handleError(error as Error)
    return null
  }
}

function processGroupData(group: Group) {
  try {
    return {
      title: group.title,
      datasets: group.datasets.map(processDatasetData),
      timestamp: Date.now()
    }
  } catch (error) {
    handleError(error as Error)
    return null
  }
}

function toggleFullscreen() {
  isFullscreen.value = !isFullscreen.value
  emit('fullscreen', isFullscreen.value)
}

function exportData() {
  try {
    const data = {
      type: props.type,
      title: props.title,
      data: processedData.value,
      timestamp: new Date().toISOString()
    }
    emit('export', data)
  } catch (error) {
    handleError(error as Error)
  }
}

function updateWidget() {
  loading.value = true
  hasError.value = false
  
  // æ¨¡æ‹Ÿå¼‚æ­¥æ›´æ–°
  nextTick(() => {
    loading.value = false
  })
}

function handleError(error: Error) {
  hasError.value = true
  errorMessage.value = error.message
  emit('error', error)
}

// å“åº”å¼å¸ƒå±€æ”¯æŒ
let resizeObserver: ResizeObserver | null = null

function setupResizeObserver() {
  if (!widgetContainer.value) return
  
  resizeObserver = new ResizeObserver((entries) => {
    for (const entry of entries) {
      const { width, height } = entry.contentRect
      emit('resize', { width, height })
    }
  })
  
  resizeObserver.observe(widgetContainer.value)
}

function cleanupResizeObserver() {
  if (resizeObserver) {
    resizeObserver.disconnect()
    resizeObserver = null
  }
}
</script>

<style scoped>
.base-widget {
  background: var(--widget-background-color);
  border: 1px solid var(--widget-border-color);
  border-radius: 8px;
  padding: 16px;
  position: relative;
  overflow: hidden;
}

.widget-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
}

.widget-title {
  margin: 0;
  color: var(--widget-text-color);
  font-size: 16px;
  font-weight: 500;
}

.widget-content {
  height: calc(100% - 60px);
  position: relative;
}

.widget-loading-state,
.widget-error-state {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
}

.widget-loading {
  opacity: 0.7;
}

.widget-error {
  border-color: var(--el-color-danger);
}
</style>
```

### 2.2 æ•°æ®ç®¡ç†å’ŒçŠ¶æ€åŒæ­¥

```typescript
// stores/dashboard.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

interface DashboardState {
  widgets: Widget[]
  layout: LayoutConfig
  theme: ThemeConfig
  performance: PerformanceConfig
}

export const useDashboardStore = defineStore('dashboard', () => {
  // çŠ¶æ€
  const widgets = ref<Widget[]>([])
  const layout = ref<LayoutConfig>({
    columns: 12,
    rowHeight: 150,
    margin: [10, 10],
    containerPadding: [0, 0],
    isDraggable: true,
    isResizable: true
  })
  
  const performance = ref<PerformanceConfig>({
    maxDataPoints: 1000,
    updateInterval: 50, // 20 FPS
    enableVirtualScrolling: true,
    enableDataCompression: true
  })
  
  // è®¡ç®—å±æ€§
  const activeWidgets = computed(() => 
    widgets.value.filter(w => w.visible)
  )
  
  const widgetsByType = computed(() => {
    const groups: Record<string, Widget[]> = {}
    widgets.value.forEach(widget => {
      if (!groups[widget.type]) {
        groups[widget.type] = []
      }
      groups[widget.type].push(widget)
    })
    return groups
  })
  
  // æ“ä½œ
  function addWidget(widget: Widget) {
    widgets.value.push({
      ...widget,
      id: generateWidgetId(),
      createdAt: Date.now(),
      updatedAt: Date.now()
    })
  }
  
  function removeWidget(id: string) {
    const index = widgets.value.findIndex(w => w.id === id)
    if (index !== -1) {
      widgets.value.splice(index, 1)
    }
  }
  
  function updateWidget(id: string, updates: Partial<Widget>) {
    const widget = widgets.value.find(w => w.id === id)
    if (widget) {
      Object.assign(widget, {
        ...updates,
        updatedAt: Date.now()
      })
    }
  }
  
  function updateWidgetData(id: string, data: any) {
    const widget = widgets.value.find(w => w.id === id)
    if (widget) {
      widget.data = data
      widget.updatedAt = Date.now()
    }
  }
  
  function clearAllWidgets() {
    widgets.value = []
  }
  
  function generateWidgetId(): string {
    return `widget_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
  }
  
  return {
    // çŠ¶æ€
    widgets,
    layout,
    performance,
    
    // è®¡ç®—å±æ€§
    activeWidgets,
    widgetsByType,
    
    // æ“ä½œ
    addWidget,
    removeWidget,
    updateWidget,
    updateWidgetData,
    clearAllWidgets
  }
})
```

## 3. å…·ä½“ç»„ä»¶å®ç°

### 3.1 æ•°æ®å›¾è¡¨ç»„ä»¶ï¼ˆPlot Widgetï¼‰

```vue
<!-- PlotWidget.vue -->
<template>
  <BaseWidget
    type="plot"
    :title="dataset?.title || 'Data Plot'"
    :dataset="dataset"
    @resize="handleResize"
  >
    <template #default="{ data }">
      <div class="plot-container" ref="plotContainer">
        <canvas 
          ref="plotCanvas"
          :width="canvasSize.width"
          :height="canvasSize.height"
          @mousemove="handleMouseMove"
          @mousedown="handleMouseDown"
          @mouseup="handleMouseUp"
          @wheel="handleWheel"
        />
        
        <div class="plot-controls" v-if="showControls">
          <el-button-group size="small">
            <el-button @click="resetZoom">
              <el-icon><RefreshLeft /></el-icon>
            </el-button>
            <el-button @click="toggleAutoscale" :type="autoscale ? 'primary' : ''">
              <el-icon><Aim /></el-icon>
            </el-button>
            <el-button @click="togglePause" :type="paused ? 'warning' : ''">
              <el-icon v-if="paused"><VideoPlay /></el-icon>
              <el-icon v-else><VideoPause /></el-icon>
            </el-button>
          </el-button-group>
        </div>
        
        <div class="plot-legend" v-if="showLegend">
          <div class="legend-item">
            <span class="legend-color" :style="{ backgroundColor: lineColor }"></span>
            <span class="legend-label">{{ data?.label }}</span>
            <span class="legend-value">{{ formatValue(data?.value) }} {{ data?.units }}</span>
          </div>
        </div>
      </div>
    </template>
  </BaseWidget>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch, computed, nextTick } from 'vue'
import BaseWidget from './BaseWidget.vue'
import { Chart, registerables } from 'chart.js'
import 'chartjs-adapter-date-fns'

Chart.register(...registerables)

interface Props {
  dataset: Dataset
  maxDataPoints?: number
  showControls?: boolean
  showLegend?: boolean
  enableZoom?: boolean
  enablePan?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  maxDataPoints: 1000,
  showControls: true,
  showLegend: true,
  enableZoom: true,
  enablePan: true
})

// å“åº”å¼å¼•ç”¨
const plotContainer = ref<HTMLElement>()
const plotCanvas = ref<HTMLCanvasElement>()
const chart = ref<Chart | null>(null)
const canvasSize = ref({ width: 400, height: 300 })

// ç»„ä»¶çŠ¶æ€
const paused = ref(false)
const autoscale = ref(true)
const dataPoints = ref<DataPoint[]>([])

// äº¤äº’çŠ¶æ€
const isDragging = ref(false)
const lastMousePos = ref({ x: 0, y: 0 })

// è®¡ç®—å±æ€§
const lineColor = computed(() => {
  return props.dataset?.color || '#409EFF'
})

const chartConfig = computed(() => ({
  type: 'line' as const,
  data: {
    datasets: [{
      label: props.dataset?.title || 'Data',
      data: dataPoints.value,
      borderColor: lineColor.value,
      backgroundColor: lineColor.value + '20',
      borderWidth: 2,
      pointRadius: 0,
      fill: false,
      tension: 0.1
    }]
  },
  options: {
    responsive: false,
    maintainAspectRatio: false,
    animation: {
      duration: 0 // ç¦ç”¨åŠ¨ç”»ä»¥æé«˜æ€§èƒ½
    },
    interaction: {
      intersect: false,
      mode: 'index' as const
    },
    plugins: {
      legend: {
        display: false
      },
      tooltip: {
        enabled: true,
        callbacks: {
          label: (context: any) => {
            return `${context.parsed.y.toFixed(3)} ${props.dataset?.units || ''}`
          }
        }
      }
    },
    scales: {
      x: {
        type: 'time' as const,
        time: {
          displayFormats: {
            millisecond: 'HH:mm:ss.SSS',
            second: 'HH:mm:ss',
            minute: 'HH:mm',
            hour: 'HH:mm'
          }
        },
        title: {
          display: true,
          text: 'Time'
        }
      },
      y: {
        title: {
          display: true,
          text: props.dataset?.units || 'Value'
        },
        min: autoscale.value ? undefined : props.dataset?.min,
        max: autoscale.value ? undefined : props.dataset?.max
      }
    }
  }
}))

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  initializeChart()
})

onUnmounted(() => {
  destroyChart()
})

// ç›‘å¬å™¨
watch(() => props.dataset?.value, (newValue) => {
  if (!paused.value && newValue !== undefined) {
    addDataPoint(parseFloat(newValue), Date.now())
  }
})

watch(canvasSize, () => {
  nextTick(() => {
    resizeChart()
  })
}, { deep: true })

// æ–¹æ³•å®ç°
function initializeChart() {
  if (!plotCanvas.value) return
  
  chart.value = new Chart(plotCanvas.value, chartConfig.value)
}

function destroyChart() {
  if (chart.value) {
    chart.value.destroy()
    chart.value = null
  }
}

function addDataPoint(value: number, timestamp: number) {
  dataPoints.value.push({
    x: timestamp,
    y: value
  })
  
  // é™åˆ¶æ•°æ®ç‚¹æ•°é‡
  if (dataPoints.value.length > props.maxDataPoints) {
    dataPoints.value.shift()
  }
  
  updateChart()
}

function updateChart() {
  if (!chart.value) return
  
  chart.value.data.datasets[0].data = dataPoints.value
  chart.value.update('none') // æ— åŠ¨ç”»æ›´æ–°
}

function resizeChart() {
  if (!chart.value) return
  
  chart.value.resize()
}

function handleResize(size: { width: number; height: number }) {
  canvasSize.value = {
    width: size.width - 32, // å‡å»padding
    height: size.height - 100 // å‡å»headerå’Œcontrolsé«˜åº¦
  }
}

function resetZoom() {
  if (!chart.value) return
  
  chart.value.resetZoom()
}

function toggleAutoscale() {
  autoscale.value = !autoscale.value
  
  if (chart.value) {
    chart.value.options.scales!.y!.min = autoscale.value ? undefined : props.dataset?.min
    chart.value.options.scales!.y!.max = autoscale.value ? undefined : props.dataset?.max
    chart.value.update()
  }
}

function togglePause() {
  paused.value = !paused.value
}

function formatValue(value: number | undefined): string {
  if (value === undefined) return '--'
  return value.toFixed(3)
}

// é¼ æ ‡äº¤äº’
function handleMouseMove(event: MouseEvent) {
  if (!isDragging.value || !props.enablePan) return
  
  const deltaX = event.clientX - lastMousePos.value.x
  const deltaY = event.clientY - lastMousePos.value.y
  
  // å®ç°å¹³ç§»é€»è¾‘
  if (chart.value) {
    // Chart.jså¹³ç§»å®ç°
  }
  
  lastMousePos.value = { x: event.clientX, y: event.clientY }
}

function handleMouseDown(event: MouseEvent) {
  if (!props.enablePan) return
  
  isDragging.value = true
  lastMousePos.value = { x: event.clientX, y: event.clientY }
}

function handleMouseUp() {
  isDragging.value = false
}

function handleWheel(event: WheelEvent) {
  if (!props.enableZoom) return
  
  event.preventDefault()
  
  // å®ç°ç¼©æ”¾é€»è¾‘
  if (chart.value) {
    const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1
    // Chart.jsç¼©æ”¾å®ç°
  }
}

interface DataPoint {
  x: number
  y: number
}
</script>

<style scoped>
.plot-container {
  position: relative;
  width: 100%;
  height: 100%;
}

.plot-controls {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 10;
}

.plot-legend {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(255, 255, 255, 0.9);
  padding: 8px 12px;
  border-radius: 4px;
  border: 1px solid #e4e7ed;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
}

.legend-color {
  width: 12px;
  height: 12px;
  border-radius: 2px;
}

.legend-value {
  font-weight: bold;
  margin-left: auto;
}
</style>
```

### 3.2 ä»ªè¡¨ç›˜ç»„ä»¶ï¼ˆGauge Widgetï¼‰

```vue
<!-- GaugeWidget.vue -->
<template>
  <BaseWidget
    type="gauge"
    :title="dataset?.title || 'Gauge'"
    :dataset="dataset"
    @resize="handleResize"
  >
    <template #default="{ data }">
      <div class="gauge-container" ref="gaugeContainer">
        <svg 
          :width="size" 
          :height="size"
          :viewBox="`0 0 ${size} ${size}`"
          class="gauge-svg"
        >
          <!-- èƒŒæ™¯åœ†å¼§ -->
          <path
            :d="backgroundArc"
            :stroke="backgroundColor"
            :stroke-width="strokeWidth"
            fill="none"
            stroke-linecap="round"
          />
          
          <!-- æ•°å€¼åœ†å¼§ -->
          <path
            :d="valueArc"
            :stroke="valueColor"
            :stroke-width="strokeWidth"
            fill="none"
            stroke-linecap="round"
            class="value-arc"
          />
          
          <!-- æŒ‡é’ˆ -->
          <g v-if="showNeedle" :transform="`translate(${center.x}, ${center.y})`">
            <line
              :x1="0"
              :y1="0"
              :x2="needleEndX"
              :y2="needleEndY"
              :stroke="needleColor"
              :stroke-width="needleWidth"
              stroke-linecap="round"
            />
            <circle
              :cx="0"
              :cy="0"
              :r="needleWidth * 2"
              :fill="needleColor"
            />
          </g>
          
          <!-- åˆ»åº¦æ ‡è®° -->
          <g v-if="showTicks">
            <g
              v-for="(tick, index) in ticks"
              :key="index"
              :transform="`translate(${center.x}, ${center.y})`"
            >
              <line
                :x1="tick.x1"
                :y1="tick.y1"
                :x2="tick.x2"
                :y2="tick.y2"
                :stroke="tickColor"
                :stroke-width="tick.major ? 2 : 1"
              />
              <text
                v-if="tick.major"
                :x="tick.labelX"
                :y="tick.labelY"
                :font-size="fontSize"
                :fill="textColor"
                text-anchor="middle"
                dominant-baseline="central"
              >
                {{ tick.value }}
              </text>
            </g>
          </g>
          
          <!-- ä¸­å¿ƒæ•°å€¼æ˜¾ç¤º -->
          <text
            :x="center.x"
            :y="center.y + 20"
            :font-size="valueFontSize"
            :fill="textColor"
            text-anchor="middle"
            dominant-baseline="central"
            class="gauge-value"
          >
            {{ formatValue(data?.value) }}
          </text>
          
          <!-- å•ä½æ˜¾ç¤º -->
          <text
            :x="center.x"
            :y="center.y + 45"
            :font-size="unitFontSize"
            :fill="secondaryTextColor"
            text-anchor="middle"
            dominant-baseline="central"
            class="gauge-unit"
          >
            {{ data?.units }}
          </text>
        </svg>
        
        <!-- çŠ¶æ€æŒ‡ç¤ºå™¨ -->
        <div v-if="showStatus" class="gauge-status" :class="statusClass">
          <el-icon><Warning /></el-icon>
          <span>{{ statusText }}</span>
        </div>
      </div>
    </template>
  </BaseWidget>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'
import BaseWidget from './BaseWidget.vue'

interface Props {
  dataset: Dataset
  showNeedle?: boolean
  showTicks?: boolean
  showStatus?: boolean
  startAngle?: number
  endAngle?: number
  tickCount?: number
}

const props = withDefaults(defineProps<Props>(), {
  showNeedle: true,
  showTicks: true,
  showStatus: true,
  startAngle: -150,
  endAngle: 150,
  tickCount: 10
})

// å“åº”å¼æ•°æ®
const gaugeContainer = ref<HTMLElement>()
const size = ref(200)

// è®¡ç®—å±æ€§
const center = computed(() => ({
  x: size.value / 2,
  y: size.value / 2
}))

const radius = computed(() => size.value / 2 - 30)
const strokeWidth = computed(() => Math.max(8, size.value / 25))
const needleWidth = computed(() => Math.max(2, size.value / 100))
const fontSize = computed(() => Math.max(10, size.value / 20))
const valueFontSize = computed(() => Math.max(16, size.value / 12))
const unitFontSize = computed(() => Math.max(12, size.value / 16))

const backgroundColor = computed(() => '#e4e7ed')
const textColor = computed(() => '#606266')
const secondaryTextColor = computed(() => '#909399')
const tickColor = computed(() => '#c0c4cc')
const needleColor = computed(() => '#409eff')

const valueColor = computed(() => {
  const value = parseFloat(props.dataset?.value || '0')
  const alarm = props.dataset?.alarm || 0
  
  if (alarm > 0 && value >= alarm) {
    return '#f56c6c' // çº¢è‰²è­¦å‘Š
  } else if (value >= (props.dataset?.max || 100) * 0.8) {
    return '#e6a23c' // æ©™è‰²è­¦å‘Š
  }
  return '#67c23a' // æ­£å¸¸ç»¿è‰²
})

const currentValue = computed(() => {
  const value = parseFloat(props.dataset?.value || '0')
  const min = props.dataset?.min || 0
  const max = props.dataset?.max || 100
  return Math.max(min, Math.min(max, value))
})

const valuePercentage = computed(() => {
  const min = props.dataset?.min || 0
  const max = props.dataset?.max || 100
  return (currentValue.value - min) / (max - min)
})

const valueAngle = computed(() => {
  const totalAngle = props.endAngle - props.startAngle
  return props.startAngle + totalAngle * valuePercentage.value
})

const backgroundArc = computed(() => {
  return createArc(
    center.value.x,
    center.value.y,
    radius.value,
    props.startAngle,
    props.endAngle
  )
})

const valueArc = computed(() => {
  return createArc(
    center.value.x,
    center.value.y,
    radius.value,
    props.startAngle,
    valueAngle.value
  )
})

const needleEndX = computed(() => {
  const angle = (valueAngle.value - 90) * Math.PI / 180
  return Math.cos(angle) * (radius.value - 10)
})

const needleEndY = computed(() => {
  const angle = (valueAngle.value - 90) * Math.PI / 180
  return Math.sin(angle) * (radius.value - 10)
})

const ticks = computed(() => {
  const tickList = []
  const min = props.dataset?.min || 0
  const max = props.dataset?.max || 100
  const totalAngle = props.endAngle - props.startAngle
  
  for (let i = 0; i <= props.tickCount; i++) {
    const value = min + (max - min) * (i / props.tickCount)
    const angle = props.startAngle + totalAngle * (i / props.tickCount)
    const radian = (angle - 90) * Math.PI / 180
    const major = i % (props.tickCount / 5) === 0
    
    const innerRadius = radius.value - strokeWidth.value / 2 - (major ? 10 : 5)
    const outerRadius = radius.value - strokeWidth.value / 2
    const labelRadius = innerRadius - 15
    
    tickList.push({
      value: Math.round(value),
      major,
      x1: Math.cos(radian) * innerRadius,
      y1: Math.sin(radian) * innerRadius,
      x2: Math.cos(radian) * outerRadius,
      y2: Math.sin(radian) * outerRadius,
      labelX: Math.cos(radian) * labelRadius,
      labelY: Math.sin(radian) * labelRadius
    })
  }
  
  return tickList
})

const statusClass = computed(() => {
  const value = parseFloat(props.dataset?.value || '0')
  const alarm = props.dataset?.alarm || 0
  
  if (alarm > 0 && value >= alarm) {
    return 'status-alarm'
  } else if (value >= (props.dataset?.max || 100) * 0.8) {
    return 'status-warning'
  }
  return 'status-normal'
})

const statusText = computed(() => {
  const value = parseFloat(props.dataset?.value || '0')
  const alarm = props.dataset?.alarm || 0
  
  if (alarm > 0 && value >= alarm) {
    return 'ALARM'
  } else if (value >= (props.dataset?.max || 100) * 0.8) {
    return 'WARNING'
  }
  return 'NORMAL'
})

// æ–¹æ³•
function createArc(x: number, y: number, radius: number, startAngle: number, endAngle: number): string {
  const start = polarToCartesian(x, y, radius, endAngle)
  const end = polarToCartesian(x, y, radius, startAngle)
  const largeArcFlag = endAngle - startAngle <= 180 ? '0' : '1'
  
  return [
    'M', start.x, start.y,
    'A', radius, radius, 0, largeArcFlag, 0, end.x, end.y
  ].join(' ')
}

function polarToCartesian(centerX: number, centerY: number, radius: number, angleInDegrees: number) {
  const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0
  
  return {
    x: centerX + (radius * Math.cos(angleInRadians)),
    y: centerY + (radius * Math.sin(angleInRadians))
  }
}

function formatValue(value: number | undefined): string {
  if (value === undefined) return '--'
  return value.toFixed(1)
}

function handleResize(containerSize: { width: number; height: number }) {
  size.value = Math.min(containerSize.width, containerSize.height) - 40
}
</script>

<style scoped>
.gauge-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  position: relative;
}

.gauge-svg {
  filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
}

.value-arc {
  transition: stroke-dasharray 0.3s ease;
}

.gauge-value {
  font-weight: bold;
}

.gauge-status {
  position: absolute;
  bottom: 10px;
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: bold;
}

.status-normal {
  background: #f0f9ff;
  color: #67c23a;
}

.status-warning {
  background: #fdf6ec;
  color: #e6a23c;
}

.status-alarm {
  background: #fef0f0;
  color: #f56c6c;
}
</style>
```

### 3.3 GPSåœ°å›¾ç»„ä»¶ï¼ˆGPS Widgetï¼‰

```vue
<!-- GPSWidget.vue -->
<template>
  <BaseWidget
    type="gps"
    :title="group?.title || 'GPS Location'"
    :group="group"
    :show-fullscreen="true"
    @resize="handleResize"
    @fullscreen="handleFullscreen"
  >
    <template #default="{ data }">
      <div class="gps-container" ref="mapContainer">
        <div id="map" class="gps-map" ref="map"></div>
        
        <div class="gps-controls">
          <el-button-group size="small">
            <el-button @click="centerOnPosition" :disabled="!hasValidPosition">
              <el-icon><Aim /></el-icon>
            </el-button>
            <el-button @click="toggleTracking" :type="tracking ? 'primary' : ''">
              <el-icon><Location /></el-icon>
            </el-button>
            <el-button @click="clearTrail">
              <el-icon><Delete /></el-icon>
            </el-button>
            <el-button @click="toggleSatelliteView">
              <el-icon><View /></el-icon>
            </el-button>
          </el-button-group>
        </div>
        
        <div class="gps-info" v-if="showInfo && hasValidPosition">
          <div class="info-row">
            <span class="info-label">Latitude:</span>
            <span class="info-value">{{ formatCoordinate(currentPosition.lat) }}Â°</span>
          </div>
          <div class="info-row">
            <span class="info-label">Longitude:</span>
            <span class="info-value">{{ formatCoordinate(currentPosition.lng) }}Â°</span>
          </div>
          <div class="info-row">
            <span class="info-label">Altitude:</span>
            <span class="info-value">{{ formatAltitude(currentPosition.alt) }} m</span>
          </div>
          <div class="info-row">
            <span class="info-label">Speed:</span>
            <span class="info-value">{{ formatSpeed(currentSpeed) }} km/h</span>
          </div>
          <div class="info-row">
            <span class="info-label">Distance:</span>
            <span class="info-value">{{ formatDistance(totalDistance) }} km</span>
          </div>
        </div>
      </div>
    </template>
  </BaseWidget>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, watch, computed, nextTick } from 'vue'
import BaseWidget from './BaseWidget.vue'
import L from 'leaflet'
import 'leaflet/dist/leaflet.css'

interface Props {
  group: Group
  showInfo?: boolean
  maxTrailPoints?: number
  showAccuracy?: boolean
  enableMeasurement?: boolean
}

const props = withDefaults(defineProps<Props>(), {
  showInfo: true,
  maxTrailPoints: 1000,
  showAccuracy: true,
  enableMeasurement: false
})

// å“åº”å¼å¼•ç”¨
const mapContainer = ref<HTMLElement>()
const map = ref<HTMLElement>()
const leafletMap = ref<L.Map | null>(null)

// ç»„ä»¶çŠ¶æ€
const tracking = ref(true)
const satelliteView = ref(false)
const trailPoints = ref<L.LatLng[]>([])
const totalDistance = ref(0)
const currentSpeed = ref(0)

// Leaflet å›¾å±‚
const currentMarker = ref<L.Marker | null>(null)
const accuracyCircle = ref<L.Circle | null>(null)
const trailPolyline = ref<L.Polyline | null>(null)

// è®¡ç®—å±æ€§
const latDataset = computed(() => 
  props.group?.datasets.find(d => d.widget === 'lat' || d.title.toLowerCase().includes('lat'))
)

const lngDataset = computed(() => 
  props.group?.datasets.find(d => d.widget === 'lng' || d.title.toLowerCase().includes('lon'))
)

const altDataset = computed(() => 
  props.group?.datasets.find(d => d.widget === 'alt' || d.title.toLowerCase().includes('alt'))
)

const currentPosition = computed(() => ({
  lat: parseFloat(latDataset.value?.value || '0'),
  lng: parseFloat(lngDataset.value?.value || '0'),
  alt: parseFloat(altDataset.value?.value || '0')
}))

const hasValidPosition = computed(() => {
  const pos = currentPosition.value
  return pos.lat !== 0 && pos.lng !== 0 && 
         Math.abs(pos.lat) <= 90 && Math.abs(pos.lng) <= 180
})

// ç”Ÿå‘½å‘¨æœŸ
onMounted(() => {
  nextTick(() => {
    initializeMap()
  })
})

onUnmounted(() => {
  destroyMap()
})

// ç›‘å¬å™¨
watch(currentPosition, (newPos, oldPos) => {
  if (hasValidPosition.value) {
    updatePosition(newPos, oldPos)
  }
}, { deep: true })

// æ–¹æ³•å®ç°
function initializeMap() {
  if (!map.value) return
  
  // åˆ›å»ºåœ°å›¾å®ä¾‹
  leafletMap.value = L.map(map.value, {
    center: [39.9042, 116.4074], // é»˜è®¤åŒ—äº¬
    zoom: 13,
    zoomControl: true,
    attributionControl: true
  })
  
  // æ·»åŠ ç“¦ç‰‡å›¾å±‚
  const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: 'Â© OpenStreetMap contributors'
  })
  
  const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
    attribution: 'Â© Esri'
  })
  
  // æ·»åŠ é»˜è®¤å›¾å±‚
  osmLayer.addTo(leafletMap.value)
  
  // åˆ›å»ºå›¾å±‚æ§åˆ¶
  const baseMaps = {
    'Street': osmLayer,
    'Satellite': satelliteLayer
  }
  
  L.control.layers(baseMaps).addTo(leafletMap.value)
  
  // åˆ›å»ºè‡ªå®šä¹‰æ§ä»¶
  createCustomControls()
}

function destroyMap() {
  if (leafletMap.value) {
    leafletMap.value.remove()
    leafletMap.value = null
  }
}

function updatePosition(newPos: Position, oldPos?: Position) {
  if (!leafletMap.value || !hasValidPosition.value) return
  
  const latLng = L.latLng(newPos.lat, newPos.lng)
  
  // æ›´æ–°å½“å‰ä½ç½®æ ‡è®°
  if (currentMarker.value) {
    currentMarker.value.setLatLng(latLng)
  } else {
    currentMarker.value = L.marker(latLng, {
      icon: createLocationIcon()
    }).addTo(leafletMap.value)
    
    currentMarker.value.bindPopup(`
      <div class="location-popup">
        <strong>Current Position</strong><br>
        Lat: ${formatCoordinate(newPos.lat)}Â°<br>
        Lng: ${formatCoordinate(newPos.lng)}Â°<br>
        Alt: ${formatAltitude(newPos.alt)} m
      </div>
    `)
  }
  
  // æ›´æ–°ç²¾åº¦åœ†åœˆ
  if (props.showAccuracy) {
    const accuracy = 10 // å‡è®¾ç²¾åº¦ä¸º10ç±³
    if (accuracyCircle.value) {
      accuracyCircle.value.setLatLng(latLng).setRadius(accuracy)
    } else {
      accuracyCircle.value = L.circle(latLng, {
        radius: accuracy,
        color: '#409eff',
        fillColor: '#409eff',
        fillOpacity: 0.2,
        weight: 2
      }).addTo(leafletMap.value)
    }
  }
  
  // æ›´æ–°è½¨è¿¹
  if (tracking.value) {
    trailPoints.value.push(latLng)
    
    // é™åˆ¶è½¨è¿¹ç‚¹æ•°é‡
    if (trailPoints.value.length > props.maxTrailPoints) {
      trailPoints.value.shift()
    }
    
    // æ›´æ–°è½¨è¿¹çº¿
    if (trailPolyline.value) {
      trailPolyline.value.setLatLngs(trailPoints.value)
    } else if (trailPoints.value.length > 1) {
      trailPolyline.value = L.polyline(trailPoints.value, {
        color: '#67c23a',
        weight: 3,
        opacity: 0.8
      }).addTo(leafletMap.value)
    }
    
    // è®¡ç®—è·ç¦»å’Œé€Ÿåº¦
    if (oldPos && oldPos.lat !== 0 && oldPos.lng !== 0) {
      const distance = calculateDistance(oldPos, newPos)
      totalDistance.value += distance
      
      // å‡è®¾æ›´æ–°é—´éš”ä¸º1ç§’ï¼Œè®¡ç®—é€Ÿåº¦
      currentSpeed.value = distance * 3.6 // m/s to km/h
    }
    
    // è‡ªåŠ¨å±…ä¸­åˆ°å½“å‰ä½ç½®
    if (tracking.value) {
      leafletMap.value.setView(latLng, leafletMap.value.getZoom())
    }
  }
}

function createLocationIcon(): L.Icon {
  return L.icon({
    iconUrl: 'data:image/svg+xml;base64,' + btoa(`
      <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="8" fill="#409eff" stroke="white" stroke-width="2"/>
        <circle cx="12" cy="12" r="3" fill="white"/>
      </svg>
    `),
    iconSize: [24, 24],
    iconAnchor: [12, 12],
    popupAnchor: [0, -12]
  })
}

function createCustomControls() {
  if (!leafletMap.value) return
  
  // åˆ›å»ºè‡ªå®šä¹‰æ§ä»¶å®¹å™¨
  const customControl = L.control({ position: 'topright' })
  
  customControl.onAdd = function() {
    const div = L.DomUtil.create('div', 'custom-control')
    div.innerHTML = `
      <div class="control-button" id="center-btn" title="Center on position">ğŸ“</div>
      <div class="control-button" id="track-btn" title="Toggle tracking">ğŸ¯</div>
      <div class="control-button" id="clear-btn" title="Clear trail">ğŸ—‘ï¸</div>
    `
    
    // é˜»æ­¢åœ°å›¾äº‹ä»¶å†’æ³¡
    L.DomEvent.disableClickPropagation(div)
    
    return div
  }
  
  customControl.addTo(leafletMap.value)
}

function centerOnPosition() {
  if (!leafletMap.value || !hasValidPosition.value) return
  
  const pos = currentPosition.value
  leafletMap.value.setView([pos.lat, pos.lng], 16)
}

function toggleTracking() {
  tracking.value = !tracking.value
}

function clearTrail() {
  trailPoints.value = []
  totalDistance.value = 0
  
  if (trailPolyline.value) {
    leafletMap.value?.removeLayer(trailPolyline.value)
    trailPolyline.value = null
  }
}

function toggleSatelliteView() {
  satelliteView.value = !satelliteView.value
  // åˆ‡æ¢å›¾å±‚é€»è¾‘
}

function calculateDistance(pos1: Position, pos2: Position): number {
  const R = 6371e3 // åœ°çƒåŠå¾„ï¼ˆç±³ï¼‰
  const Ï†1 = pos1.lat * Math.PI / 180
  const Ï†2 = pos2.lat * Math.PI / 180
  const Î”Ï† = (pos2.lat - pos1.lat) * Math.PI / 180
  const Î”Î» = (pos2.lng - pos1.lng) * Math.PI / 180
  
  const a = Math.sin(Î”Ï†/2) * Math.sin(Î”Ï†/2) +
            Math.cos(Ï†1) * Math.cos(Ï†2) *
            Math.sin(Î”Î»/2) * Math.sin(Î”Î»/2)
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a))
  
  return R * c // è·ç¦»ï¼ˆç±³ï¼‰
}

function formatCoordinate(coord: number): string {
  return coord.toFixed(6)
}

function formatAltitude(alt: number): string {
  return alt.toFixed(1)
}

function formatSpeed(speed: number): string {
  return speed.toFixed(1)
}

function formatDistance(distance: number): string {
  return (distance / 1000).toFixed(2)
}

function handleResize(size: { width: number; height: number }) {
  if (leafletMap.value) {
    leafletMap.value.invalidateSize()
  }
}

function handleFullscreen(isFullscreen: boolean) {
  nextTick(() => {
    if (leafletMap.value) {
      leafletMap.value.invalidateSize()
    }
  })
}

interface Position {
  lat: number
  lng: number
  alt: number
}
</script>

<style scoped>
.gps-container {
  position: relative;
  width: 100%;
  height: 100%;
}

.gps-map {
  width: 100%;
  height: 100%;
  border-radius: 6px;
  overflow: hidden;
}

.gps-controls {
  position: absolute;
  top: 10px;
  right: 10px;
  z-index: 1000;
}

.gps-info {
  position: absolute;
  bottom: 10px;
  left: 10px;
  background: rgba(255, 255, 255, 0.95);
  padding: 12px;
  border-radius: 6px;
  min-width: 200px;
  font-size: 12px;
  z-index: 1000;
}

.info-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
}

.info-row:last-child {
  margin-bottom: 0;
}

.info-label {
  color: #909399;
}

.info-value {
  font-weight: bold;
  color: #303133;
}

/* Leaflet è‡ªå®šä¹‰æ ·å¼ */
:deep(.custom-control) {
  background: white;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

:deep(.control-button) {
  padding: 8px;
  cursor: pointer;
  border-bottom: 1px solid #eee;
}

:deep(.control-button:last-child) {
  border-bottom: none;
}

:deep(.control-button:hover) {
  background: #f5f7fa;
}

:deep(.location-popup) {
  text-align: center;
  font-size: 12px;
}
</style>
```

## 4. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 4.1 è™šæ‹ŸåŒ–æ¸²æŸ“ç³»ç»Ÿ

```typescript
// composables/useVirtualization.ts
import { ref, computed, nextTick } from 'vue'

export function useVirtualization<T>(
  items: Ref<T[]>,
  itemHeight: number,
  containerHeight: Ref<number>,
  buffer: number = 5
) {
  const scrollTop = ref(0)
  
  const visibleRange = computed(() => {
    const start = Math.floor(scrollTop.value / itemHeight)
    const end = Math.min(
      start + Math.ceil(containerHeight.value / itemHeight) + buffer,
      items.value.length
    )
    
    return {
      start: Math.max(0, start - buffer),
      end
    }
  })
  
  const visibleItems = computed(() => {
    const { start, end } = visibleRange.value
    return items.value.slice(start, end).map((item, index) => ({
      item,
      index: start + index
    }))
  })
  
  const totalHeight = computed(() => items.value.length * itemHeight)
  
  const offsetY = computed(() => visibleRange.value.start * itemHeight)
  
  function handleScroll(event: Event) {
    const target = event.target as HTMLElement
    scrollTop.value = target.scrollTop
  }
  
  return {
    visibleItems,
    totalHeight,
    offsetY,
    handleScroll
  }
}
```

### 4.2 æ•°æ®ç¼“å­˜å’Œæ›´æ–°ä¼˜åŒ–

```typescript
// composables/useDataCache.ts
import { ref, computed, watch } from 'vue'

interface CacheOptions {
  maxSize: number
  ttl: number // ç”Ÿå­˜æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
  updateInterval: number // æ›´æ–°é—´éš”ï¼ˆæ¯«ç§’ï¼‰
}

export function useDataCache<T>(options: CacheOptions) {
  const cache = ref(new Map<string, CacheEntry<T>>())
  const lastUpdate = ref(0)
  const pendingUpdates = ref(new Map<string, T>())
  
  let updateTimer: NodeJS.Timeout | null = null
  
  interface CacheEntry<T> {
    data: T
    timestamp: number
    hits: number
  }
  
  function set(key: string, data: T) {
    // æ‰¹é‡æ›´æ–°ç­–ç•¥
    pendingUpdates.value.set(key, data)
    
    if (!updateTimer) {
      updateTimer = setTimeout(() => {
        flushUpdates()
        updateTimer = null
      }, options.updateInterval)
    }
  }
  
  function get(key: string): T | null {
    const entry = cache.value.get(key)
    
    if (!entry) return null
    
    // æ£€æŸ¥è¿‡æœŸ
    if (Date.now() - entry.timestamp > options.ttl) {
      cache.value.delete(key)
      return null
    }
    
    // æ›´æ–°è®¿é—®è®¡æ•°
    entry.hits++
    return entry.data
  }
  
  function flushUpdates() {
    const now = Date.now()
    
    pendingUpdates.value.forEach((data, key) => {
      cache.value.set(key, {
        data,
        timestamp: now,
        hits: 0
      })
    })
    
    pendingUpdates.value.clear()
    lastUpdate.value = now
    
    // æ¸…ç†è¿‡æœŸæ•°æ®
    cleanup()
  }
  
  function cleanup() {
    const now = Date.now()
    const entries = Array.from(cache.value.entries())
    
    // æŒ‰è®¿é—®æ¬¡æ•°å’Œæ—¶é—´æ’åº
    entries.sort((a, b) => {
      const aScore = a[1].hits / (now - a[1].timestamp)
      const bScore = b[1].hits / (now - b[1].timestamp)
      return bScore - aScore
    })
    
    // ä¿ç•™æœ€å¸¸ç”¨çš„æ•°æ®
    if (entries.length > options.maxSize) {
      const toRemove = entries.slice(options.maxSize)
      toRemove.forEach(([key]) => {
        cache.value.delete(key)
      })
    }
    
    // ç§»é™¤è¿‡æœŸæ•°æ®
    cache.value.forEach((entry, key) => {
      if (now - entry.timestamp > options.ttl) {
        cache.value.delete(key)
      }
    })
  }
  
  function clear() {
    cache.value.clear()
    pendingUpdates.value.clear()
    if (updateTimer) {
      clearTimeout(updateTimer)
      updateTimer = null
    }
  }
  
  const stats = computed(() => ({
    size: cache.value.size,
    pendingUpdates: pendingUpdates.value.size,
    lastUpdate: lastUpdate.value
  }))
  
  return {
    set,
    get,
    clear,
    stats
  }
}
```

## 5. å“åº”å¼è®¾è®¡å’Œä¸»é¢˜ç³»ç»Ÿ

### 5.1 å“åº”å¼å¸ƒå±€ç®¡ç†

```typescript
// composables/useResponsive.ts
import { ref, computed, onMounted, onUnmounted } from 'vue'

export function useResponsive() {
  const windowWidth = ref(window.innerWidth)
  const windowHeight = ref(window.innerHeight)
  
  const breakpoints = {
    xs: 480,
    sm: 768,
    md: 992,
    lg: 1200,
    xl: 1920
  }
  
  const currentBreakpoint = computed(() => {
    const width = windowWidth.value
    if (width < breakpoints.xs) return 'xs'
    if (width < breakpoints.sm) return 'sm'
    if (width < breakpoints.md) return 'md'
    if (width < breakpoints.lg) return 'lg'
    return 'xl'
  })
  
  const isMobile = computed(() => ['xs', 'sm'].includes(currentBreakpoint.value))
  const isTablet = computed(() => currentBreakpoint.value === 'md')
  const isDesktop = computed(() => ['lg', 'xl'].includes(currentBreakpoint.value))
  
  const gridCols = computed(() => {
    switch (currentBreakpoint.value) {
      case 'xs': return 1
      case 'sm': return 2
      case 'md': return 3
      case 'lg': return 4
      default: return 6
    }
  })
  
  function handleResize() {
    windowWidth.value = window.innerWidth
    windowHeight.value = window.innerHeight
  }
  
  onMounted(() => {
    window.addEventListener('resize', handleResize)
  })
  
  onUnmounted(() => {
    window.removeEventListener('resize', handleResize)
  })
  
  return {
    windowWidth,
    windowHeight,
    currentBreakpoint,
    isMobile,
    isTablet,
    isDesktop,
    gridCols
  }
}
```

### 5.2 ä¸»é¢˜ç³»ç»Ÿå®ç°

```typescript
// stores/theme.ts
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useThemeStore = defineStore('theme', () => {
  const currentTheme = ref<'light' | 'dark' | 'auto'>('auto')
  const customColors = ref<Record<string, string>>({})
  
  const systemTheme = ref<'light' | 'dark'>('light')
  
  // ç›‘å¬ç³»ç»Ÿä¸»é¢˜å˜åŒ–
  const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
  systemTheme.value = mediaQuery.matches ? 'dark' : 'light'
  
  mediaQuery.addEventListener('change', (e) => {
    systemTheme.value = e.matches ? 'dark' : 'light'
  })
  
  const effectiveTheme = computed(() => {
    if (currentTheme.value === 'auto') {
      return systemTheme.value
    }
    return currentTheme.value
  })
  
  const themeColors = computed(() => {
    const baseColors = effectiveTheme.value === 'dark' ? darkColors : lightColors
    return { ...baseColors, ...customColors.value }
  })
  
  const primaryColor = computed(() => themeColors.value.primary)
  const backgroundColor = computed(() => themeColors.value.background)
  const textColor = computed(() => themeColors.value.text)
  const borderColor = computed(() => themeColors.value.border)
  
  function setTheme(theme: 'light' | 'dark' | 'auto') {
    currentTheme.value = theme
    applyTheme()
  }
  
  function setCustomColor(key: string, color: string) {
    customColors.value[key] = color
    applyTheme()
  }
  
  function applyTheme() {
    const root = document.documentElement
    const colors = themeColors.value
    
    Object.entries(colors).forEach(([key, value]) => {
      root.style.setProperty(`--theme-${key}`, value)
    })
    
    // åº”ç”¨åˆ° Element Plus
    root.style.setProperty('--el-color-primary', colors.primary)
    root.style.setProperty('--el-bg-color', colors.background)
    root.style.setProperty('--el-text-color-primary', colors.text)
  }
  
  return {
    currentTheme,
    effectiveTheme,
    themeColors,
    primaryColor,
    backgroundColor,
    textColor,
    borderColor,
    setTheme,
    setCustomColor
  }
})

const lightColors = {
  primary: '#409eff',
  success: '#67c23a',
  warning: '#e6a23c',
  danger: '#f56c6c',
  info: '#909399',
  background: '#ffffff',
  surface: '#f5f7fa',
  text: '#303133',
  textSecondary: '#606266',
  textPlaceholder: '#c0c4cc',
  border: '#dcdfe6',
  borderLight: '#e4e7ed',
  borderLighter: '#ebeef5',
  borderExtraLight: '#f2f6fc'
}

const darkColors = {
  primary: '#409eff',
  success: '#67c23a',
  warning: '#e6a23c',
  danger: '#f56c6c',
  info: '#909399',
  background: '#1a1a1a',
  surface: '#2d2d2d',
  text: '#e0e0e0',
  textSecondary: '#b0b0b0',
  textPlaceholder: '#808080',
  border: '#404040',
  borderLight: '#505050',
  borderLighter: '#606060',
  borderExtraLight: '#707070'
}
```

## 6. æµ‹è¯•å’Œè°ƒè¯•å·¥å…·

### 6.1 ç»„ä»¶æµ‹è¯•æ¡†æ¶

```typescript
// tests/components/PlotWidget.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia } from 'pinia'
import PlotWidget from '@/components/PlotWidget.vue'

describe('PlotWidget', () => {
  let wrapper: any
  let pinia: any
  
  const mockDataset = {
    title: 'Test Dataset',
    value: '25.5',
    units: 'Â°C',
    min: 0,
    max: 100,
    alarm: 80
  }
  
  beforeEach(() => {
    pinia = createPinia()
    
    wrapper = mount(PlotWidget, {
      global: {
        plugins: [pinia]
      },
      props: {
        dataset: mockDataset
      }
    })
  })
  
  it('renders correctly', () => {
    expect(wrapper.exists()).toBe(true)
    expect(wrapper.find('.plot-container').exists()).toBe(true)
  })
  
  it('displays correct title', () => {
    expect(wrapper.find('.widget-title').text()).toBe('Test Dataset')
  })
  
  it('handles data updates', async () => {
    const newDataset = { ...mockDataset, value: '30.2' }
    await wrapper.setProps({ dataset: newDataset })
    
    // éªŒè¯æ•°æ®æ›´æ–°é€»è¾‘
  })
  
  it('handles resize events', async () => {
    const resizeSpy = vi.spyOn(wrapper.vm, 'handleResize')
    
    wrapper.vm.handleResize({ width: 500, height: 300 })
    
    expect(resizeSpy).toHaveBeenCalledWith({ width: 500, height: 300 })
  })
  
  it('exports data correctly', async () => {
    const exportSpy = vi.spyOn(wrapper.vm, 'exportData')
    
    await wrapper.find('.export-button').trigger('click')
    
    expect(exportSpy).toHaveBeenCalled()
  })
})
```

### 6.2 æ€§èƒ½ç›‘æ§å·¥å…·

```typescript
// utils/performance.ts
export class PerformanceMonitor {
  private static instance: PerformanceMonitor
  private metrics: Map<string, PerformanceMetrics> = new Map()
  
  static getInstance(): PerformanceMonitor {
    if (!this.instance) {
      this.instance = new PerformanceMonitor()
    }
    return this.instance
  }
  
  startMeasure(name: string): void {
    performance.mark(`${name}-start`)
  }
  
  endMeasure(name: string): number {
    performance.mark(`${name}-end`)
    performance.measure(name, `${name}-start`, `${name}-end`)
    
    const measure = performance.getEntriesByName(name)[0]
    const duration = measure.duration
    
    this.recordMetric(name, duration)
    
    // æ¸…ç† marks å’Œ measures
    performance.clearMarks(`${name}-start`)
    performance.clearMarks(`${name}-end`)
    performance.clearMeasures(name)
    
    return duration
  }
  
  private recordMetric(name: string, duration: number): void {
    let metric = this.metrics.get(name)
    
    if (!metric) {
      metric = {
        name,
        count: 0,
        totalTime: 0,
        minTime: Infinity,
        maxTime: 0,
        avgTime: 0
      }
      this.metrics.set(name, metric)
    }
    
    metric.count++
    metric.totalTime += duration
    metric.minTime = Math.min(metric.minTime, duration)
    metric.maxTime = Math.max(metric.maxTime, duration)
    metric.avgTime = metric.totalTime / metric.count
  }
  
  getMetrics(): PerformanceMetrics[] {
    return Array.from(this.metrics.values())
  }
  
  getMetric(name: string): PerformanceMetrics | undefined {
    return this.metrics.get(name)
  }
  
  reset(): void {
    this.metrics.clear()
  }
  
  generateReport(): string {
    const metrics = this.getMetrics()
    
    if (metrics.length === 0) {
      return 'No performance data available'
    }
    
    let report = 'Performance Report\n==================\n\n'
    
    metrics.forEach(metric => {
      report += `${metric.name}:\n`
      report += `  Count: ${metric.count}\n`
      report += `  Total: ${metric.totalTime.toFixed(2)}ms\n`
      report += `  Average: ${metric.avgTime.toFixed(2)}ms\n`
      report += `  Min: ${metric.minTime.toFixed(2)}ms\n`
      report += `  Max: ${metric.maxTime.toFixed(2)}ms\n\n`
    })
    
    return report
  }
}

interface PerformanceMetrics {
  name: string
  count: number
  totalTime: number
  minTime: number
  maxTime: number
  avgTime: number
}

// è£…é¥°å™¨ç”¨æ³•
export function measure(target: any, propertyName: string, descriptor: PropertyDescriptor) {
  const method = descriptor.value
  
  descriptor.value = function (...args: any[]) {
    const monitor = PerformanceMonitor.getInstance()
    const measureName = `${target.constructor.name}.${propertyName}`
    
    monitor.startMeasure(measureName)
    const result = method.apply(this, args)
    monitor.endMeasure(measureName)
    
    return result
  }
  
  return descriptor
}
```

è¿™ä¸ªå¯è§†åŒ–ç»„ä»¶è®¾è®¡æä¾›äº†å®Œæ•´çš„ç»„ä»¶æ¶æ„ï¼ŒåŒ…æ‹¬åŸºç¡€ç»„ä»¶ã€å…·ä½“å®ç°ã€æ€§èƒ½ä¼˜åŒ–ã€å“åº”å¼è®¾è®¡å’Œæµ‹è¯•æ¡†æ¶ã€‚é€šè¿‡æ¨¡å—åŒ–å’Œå¯å¤ç”¨çš„è®¾è®¡ï¼Œç¡®ä¿äº†ç³»ç»Ÿçš„å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ï¼ŒåŒæ—¶æä¾›äº†ä¼˜ç§€çš„ç”¨æˆ·ä½“éªŒå’Œå¼€å‘ä½“éªŒã€‚