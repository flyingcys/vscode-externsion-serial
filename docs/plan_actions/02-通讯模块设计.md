# Serial-Studio VSCode 插件通讯模块设计

## 1. 通讯模块概述

基于对 Serial-Studio IO 模块的深度分析，通讯模块是整个系统的核心基础设施，负责与各种外部设备和网络进行数据交换。该模块采用硬件抽象层（HAL）设计模式，支持多种通讯协议的统一管理。

### 1.1 设计目标

- **统一接口**：为所有通讯协议提供一致的 API
- **可扩展性**：支持新协议的快速集成
- **高性能**：优化数据传输和处理效率
- **容错性**：提供完善的错误处理和重连机制
- **线程安全**：支持多线程并发操作

### 1.2 支持的通讯协议

1. **UART/串口通信**（基础功能）
2. **TCP/UDP 网络通信**（基础功能）
3. **Bluetooth LE 通信**（基础功能）
4. **音频输入**（扩展功能）
5. **Modbus 通信**（扩展功能）
6. **CAN 总线通信**（扩展功能）

## 2. 硬件抽象层设计

### 2.1 HAL 接口定义

```typescript
// 基础 HAL 驱动接口
abstract class HALDriver extends EventEmitter {
  protected config: DriverConfig;
  protected connected: boolean = false;
  
  abstract connect(): Promise<void>;
  abstract disconnect(): Promise<void>;
  abstract write(data: Buffer): Promise<number>;
  abstract isOpen(): boolean;
  abstract isReadable(): boolean;
  abstract isWritable(): boolean;
  abstract configurationOk(): boolean;
  
  // 事件定义
  // 'data' - 接收到数据
  // 'error' - 发生错误
  // 'connect' - 连接成功
  // 'disconnect' - 连接断开
}

// 驱动配置基类
interface DriverConfig {
  name: string;
  type: BusType;
  autoReconnect: boolean;
  bufferSize: number;
  timeout: number;
}

// 总线类型枚举
enum BusType {
  UART = 'uart',
  Network = 'network',
  BluetoothLE = 'bluetooth-le',
  Audio = 'audio',
  Modbus = 'modbus',
  CANBus = 'canbus'
}
```

### 2.2 驱动管理器

```typescript
class IOManager extends EventEmitter {
  private drivers = new Map<BusType, HALDriver>();
  private currentDriver: HALDriver | null = null;
  private frameReader: FrameReader;
  private paused: boolean = false;
  
  constructor() {
    super();
    this.frameReader = new FrameReader();
    this.setupDrivers();
  }
  
  private setupDrivers(): void {
    this.drivers.set(BusType.UART, new UARTDriver());
    this.drivers.set(BusType.Network, new NetworkDriver());
    this.drivers.set(BusType.BluetoothLE, new BluetoothLEDriver());
    // 扩展驱动按需注册
  }
  
  async selectDriver(type: BusType, config: DriverConfig): Promise<void> {
    const driver = this.drivers.get(type);
    if (!driver) {
      throw new Error(`Unsupported driver type: ${type}`);
    }
    
    // 断开当前连接
    if (this.currentDriver) {
      await this.currentDriver.disconnect();
    }
    
    // 配置新驱动
    this.currentDriver = driver;
    this.currentDriver.configure(config);
    this.setupDriverEvents();
  }
  
  private setupDriverEvents(): void {
    if (!this.currentDriver) return;
    
    this.currentDriver.on('data', (data: Buffer) => {
      if (!this.paused) {
        this.frameReader.processData(data);
      }
    });
    
    this.currentDriver.on('error', (error: Error) => {
      this.emit('connectionError', error);
    });
    
    this.currentDriver.on('connect', () => {
      this.emit('connected');
    });
    
    this.currentDriver.on('disconnect', () => {
      this.emit('disconnected');
    });
  }
  
  async connect(): Promise<void> {
    if (!this.currentDriver) {
      throw new Error('No driver selected');
    }
    
    if (!this.currentDriver.configurationOk()) {
      throw new Error('Driver configuration is invalid');
    }
    
    await this.currentDriver.connect();
  }
  
  async disconnect(): Promise<void> {
    if (this.currentDriver && this.currentDriver.isOpen()) {
      await this.currentDriver.disconnect();
    }
  }
  
  async writeData(data: Buffer): Promise<number> {
    if (!this.currentDriver || !this.currentDriver.isWritable()) {
      throw new Error('Driver not available for writing');
    }
    
    return await this.currentDriver.write(data);
  }
  
  setPaused(paused: boolean): void {
    this.paused = paused;
  }
  
  isConnected(): boolean {
    return this.currentDriver?.isOpen() ?? false;
  }
}
```

## 3. UART 驱动实现

### 3.1 UART 驱动类

```typescript
import { SerialPort } from 'serialport';

interface UARTConfig extends DriverConfig {
  portPath: string;
  baudRate: number;
  dataBits: 5 | 6 | 7 | 8;
  stopBits: 1 | 1.5 | 2;
  parity: 'none' | 'even' | 'odd' | 'mark' | 'space';
  flowControl: 'none' | 'xon-xoff' | 'rts-cts';
  dtrEnabled: boolean;
}

class UARTDriver extends HALDriver {
  private port: SerialPort | null = null;
  private config: UARTConfig;
  
  constructor() {
    super();
  }
  
  configure(config: UARTConfig): void {
    this.config = config;
  }
  
  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.port = new SerialPort({
        path: this.config.portPath,
        baudRate: this.config.baudRate,
        dataBits: this.config.dataBits,
        stopBits: this.config.stopBits,
        parity: this.config.parity,
        autoOpen: false
      });
      
      this.port.open((error) => {
        if (error) {
          reject(new Error(`Failed to open serial port: ${error.message}`));
        } else {
          this.setupPortEvents();
          this.connected = true;
          this.emit('connect');
          resolve();
        }
      });
    });
  }
  
  private setupPortEvents(): void {
    if (!this.port) return;
    
    this.port.on('data', (data: Buffer) => {
      this.emit('data', data);
    });
    
    this.port.on('error', (error: Error) => {
      this.emit('error', error);
    });
    
    this.port.on('close', () => {
      this.connected = false;
      this.emit('disconnect');
      
      // 自动重连逻辑
      if (this.config.autoReconnect) {
        setTimeout(() => {
          this.connect().catch(error => {
            this.emit('error', error);
          });
        }, 3000);
      }
    });
  }
  
  async disconnect(): Promise<void> {
    return new Promise((resolve) => {
      if (this.port && this.port.isOpen) {
        this.port.close(() => {
          this.port = null;
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
  
  async write(data: Buffer): Promise<number> {
    return new Promise((resolve, reject) => {
      if (!this.port || !this.port.isOpen) {
        reject(new Error('Port is not open'));
        return;
      }
      
      this.port.write(data, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve(data.length);
        }
      });
    });
  }
  
  isOpen(): boolean {
    return this.port?.isOpen ?? false;
  }
  
  isReadable(): boolean {
    return this.isOpen();
  }
  
  isWritable(): boolean {
    return this.isOpen();
  }
  
  configurationOk(): boolean {
    return !!(this.config?.portPath && this.config?.baudRate);
  }
  
  // 串口特有方法
  static async listPorts(): Promise<PortInfo[]> {
    return await SerialPort.list();
  }
  
  async setDTR(state: boolean): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.port) {
        reject(new Error('Port not available'));
        return;
      }
      
      this.port.set({ dtr: state }, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }
}
```

### 3.2 串口设备发现

```typescript
interface PortInfo {
  path: string;
  manufacturer?: string;
  serialNumber?: string;
  pnpId?: string;
  locationId?: string;
  vendorId?: string;
  productId?: string;
}

class SerialPortDiscovery {
  private static instance: SerialPortDiscovery;
  private discoveredPorts: PortInfo[] = [];
  
  static getInstance(): SerialPortDiscovery {
    if (!this.instance) {
      this.instance = new SerialPortDiscovery();
    }
    return this.instance;
  }
  
  async discoverPorts(): Promise<PortInfo[]> {
    try {
      this.discoveredPorts = await UARTDriver.listPorts();
      return this.discoveredPorts;
    } catch (error) {
      console.error('Failed to discover serial ports:', error);
      return [];
    }
  }
  
  getAvailablePorts(): PortInfo[] {
    return this.discoveredPorts;
  }
  
  findPortByVendorId(vendorId: string): PortInfo | undefined {
    return this.discoveredPorts.find(port => port.vendorId === vendorId);
  }
  
  findPortByDescription(description: string): PortInfo | undefined {
    return this.discoveredPorts.find(port => 
      port.manufacturer?.includes(description) ||
      port.path.includes(description)
    );
  }
}
```

## 4. 网络驱动实现

### 4.1 网络驱动类

```typescript
import * as net from 'net';
import * as dgram from 'dgram';

interface NetworkConfig extends DriverConfig {
  socketType: 'tcp' | 'udp';
  remoteAddress: string;
  remotePort: number;
  localPort?: number; // UDP 专用
  multicast?: boolean; // UDP 组播
}

class NetworkDriver extends HALDriver {
  private tcpSocket: net.Socket | null = null;
  private udpSocket: dgram.Socket | null = null;
  private config: NetworkConfig;
  
  configure(config: NetworkConfig): void {
    this.config = config;
  }
  
  async connect(): Promise<void> {
    if (this.config.socketType === 'tcp') {
      return this.connectTCP();
    } else {
      return this.connectUDP();
    }
  }
  
  private async connectTCP(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.tcpSocket = new net.Socket();
      
      this.tcpSocket.connect(this.config.remotePort, this.config.remoteAddress, () => {
        this.connected = true;
        this.emit('connect');
        resolve();
      });
      
      this.tcpSocket.on('data', (data: Buffer) => {
        this.emit('data', data);
      });
      
      this.tcpSocket.on('error', (error: Error) => {
        this.emit('error', error);
        reject(error);
      });
      
      this.tcpSocket.on('close', () => {
        this.connected = false;
        this.emit('disconnect');
        
        if (this.config.autoReconnect) {
          setTimeout(() => {
            this.connect().catch(error => {
              this.emit('error', error);
            });
          }, 3000);
        }
      });
      
      this.tcpSocket.setTimeout(this.config.timeout);
      this.tcpSocket.on('timeout', () => {
        this.tcpSocket?.destroy();
        reject(new Error('Connection timeout'));
      });
    });
  }
  
  private async connectUDP(): Promise<void> {
    return new Promise((resolve, reject) => {
      this.udpSocket = dgram.createSocket('udp4');
      
      this.udpSocket.on('message', (data: Buffer, rinfo) => {
        this.emit('data', data);
      });
      
      this.udpSocket.on('error', (error: Error) => {
        this.emit('error', error);
        reject(error);
      });
      
      if (this.config.localPort) {
        this.udpSocket.bind(this.config.localPort, () => {
          if (this.config.multicast) {
            this.udpSocket?.addMembership(this.config.remoteAddress);
          }
          this.connected = true;
          this.emit('connect');
          resolve();
        });
      } else {
        this.connected = true;
        this.emit('connect');
        resolve();
      }
    });
  }
  
  async disconnect(): Promise<void> {
    if (this.tcpSocket) {
      this.tcpSocket.destroy();
      this.tcpSocket = null;
    }
    
    if (this.udpSocket) {
      this.udpSocket.close();
      this.udpSocket = null;
    }
    
    this.connected = false;
  }
  
  async write(data: Buffer): Promise<number> {
    if (this.config.socketType === 'tcp') {
      return this.writeTCP(data);
    } else {
      return this.writeUDP(data);
    }
  }
  
  private async writeTCP(data: Buffer): Promise<number> {
    return new Promise((resolve, reject) => {
      if (!this.tcpSocket) {
        reject(new Error('TCP socket not available'));
        return;
      }
      
      this.tcpSocket.write(data, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve(data.length);
        }
      });
    });
  }
  
  private async writeUDP(data: Buffer): Promise<number> {
    return new Promise((resolve, reject) => {
      if (!this.udpSocket) {
        reject(new Error('UDP socket not available'));
        return;
      }
      
      this.udpSocket.send(
        data,
        this.config.remotePort,
        this.config.remoteAddress,
        (error) => {
          if (error) {
            reject(error);
          } else {
            resolve(data.length);
          }
        }
      );
    });
  }
  
  isOpen(): boolean {
    if (this.config.socketType === 'tcp') {
      return this.tcpSocket?.readyState === 'open';
    } else {
      return this.udpSocket !== null;
    }
  }
  
  isReadable(): boolean {
    return this.isOpen();
  }
  
  isWritable(): boolean {
    return this.isOpen();
  }
  
  configurationOk(): boolean {
    return !!(this.config?.remoteAddress && this.config?.remotePort);
  }
}
```

## 5. Bluetooth LE 驱动实现

### 5.1 蓝牙 LE 驱动类

```typescript
import * as noble from '@abandonware/noble';

interface BluetoothLEConfig extends DriverConfig {
  deviceId: string;
  serviceUuid: string;
  characteristicUuid: string;
  scanTimeout: number;
}

class BluetoothLEDriver extends HALDriver {
  private peripheral: noble.Peripheral | null = null;
  private characteristic: noble.Characteristic | null = null;
  private config: BluetoothLEConfig;
  
  configure(config: BluetoothLEConfig): void {
    this.config = config;
  }
  
  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      noble.on('stateChange', (state) => {
        if (state === 'poweredOn') {
          this.startScanning(resolve, reject);
        } else {
          reject(new Error(`Bluetooth state: ${state}`));
        }
      });
      
      if (noble.state === 'poweredOn') {
        this.startScanning(resolve, reject);
      }
    });
  }
  
  private startScanning(resolve: () => void, reject: (error: Error) => void): void {
    const scanTimeout = setTimeout(() => {
      noble.stopScanning();
      reject(new Error('Device scan timeout'));
    }, this.config.scanTimeout);
    
    noble.on('discover', async (peripheral) => {
      if (peripheral.id === this.config.deviceId || 
          peripheral.advertisement.localName === this.config.deviceId) {
        
        clearTimeout(scanTimeout);
        noble.stopScanning();
        
        try {
          await this.connectToPeripheral(peripheral);
          resolve();
        } catch (error) {
          reject(error as Error);
        }
      }
    });
    
    noble.startScanning();
  }
  
  private async connectToPeripheral(peripheral: noble.Peripheral): Promise<void> {
    this.peripheral = peripheral;
    
    return new Promise((resolve, reject) => {
      peripheral.connect((error) => {
        if (error) {
          reject(error);
          return;
        }
        
        peripheral.discoverServices([this.config.serviceUuid], (error, services) => {
          if (error || !services || services.length === 0) {
            reject(new Error('Service not found'));
            return;
          }
          
          const service = services[0];
          service.discoverCharacteristics([this.config.characteristicUuid], (error, characteristics) => {
            if (error || !characteristics || characteristics.length === 0) {
              reject(new Error('Characteristic not found'));
              return;
            }
            
            this.characteristic = characteristics[0];
            this.setupCharacteristicEvents();
            this.connected = true;
            this.emit('connect');
            resolve();
          });
        });
      });
      
      peripheral.on('disconnect', () => {
        this.connected = false;
        this.emit('disconnect');
        
        if (this.config.autoReconnect) {
          setTimeout(() => {
            this.connect().catch(error => {
              this.emit('error', error);
            });
          }, 3000);
        }
      });
    });
  }
  
  private setupCharacteristicEvents(): void {
    if (!this.characteristic) return;
    
    this.characteristic.subscribe((error) => {
      if (error) {
        this.emit('error', error);
      }
    });
    
    this.characteristic.on('data', (data: Buffer) => {
      this.emit('data', data);
    });
  }
  
  async disconnect(): Promise<void> {
    return new Promise((resolve) => {
      if (this.peripheral) {
        this.peripheral.disconnect(() => {
          this.peripheral = null;
          this.characteristic = null;
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
  
  async write(data: Buffer): Promise<number> {
    return new Promise((resolve, reject) => {
      if (!this.characteristic) {
        reject(new Error('Characteristic not available'));
        return;
      }
      
      this.characteristic.write(data, false, (error) => {
        if (error) {
          reject(error);
        } else {
          resolve(data.length);
        }
      });
    });
  }
  
  isOpen(): boolean {
    return this.peripheral?.state === 'connected';
  }
  
  isReadable(): boolean {
    return this.isOpen();
  }
  
  isWritable(): boolean {
    return this.isOpen() && this.characteristic !== null;
  }
  
  configurationOk(): boolean {
    return !!(this.config?.deviceId && 
              this.config?.serviceUuid && 
              this.config?.characteristicUuid);
  }
  
  // 蓝牙特有方法
  static async scanDevices(timeout: number = 10000): Promise<BluetoothDevice[]> {
    return new Promise((resolve) => {
      const devices: BluetoothDevice[] = [];
      
      const scanTimeout = setTimeout(() => {
        noble.stopScanning();
        resolve(devices);
      }, timeout);
      
      noble.on('discover', (peripheral) => {
        devices.push({
          id: peripheral.id,
          name: peripheral.advertisement.localName || 'Unknown',
          rssi: peripheral.rssi,
          services: peripheral.advertisement.serviceUuids || []
        });
      });
      
      noble.startScanning();
    });
  }
}

interface BluetoothDevice {
  id: string;
  name: string;
  rssi: number;
  services: string[];
}
```

## 6. 缓冲区和数据流管理

### 6.1 环形缓冲区实现

```typescript
class CircularBuffer<T> {
  private buffer: T[];
  private head: number = 0;
  private tail: number = 0;
  private size: number = 0;
  private capacity: number;
  
  constructor(capacity: number) {
    this.capacity = capacity;
    this.buffer = new Array(capacity);
  }
  
  push(item: T): boolean {
    if (this.size >= this.capacity) {
      // 覆盖最旧的数据
      this.head = (this.head + 1) % this.capacity;
    } else {
      this.size++;
    }
    
    this.buffer[this.tail] = item;
    this.tail = (this.tail + 1) % this.capacity;
    return true;
  }
  
  pop(): T | undefined {
    if (this.size === 0) {
      return undefined;
    }
    
    const item = this.buffer[this.head];
    this.head = (this.head + 1) % this.capacity;
    this.size--;
    return item;
  }
  
  peek(): T | undefined {
    return this.size > 0 ? this.buffer[this.head] : undefined;
  }
  
  isFull(): boolean {
    return this.size >= this.capacity;
  }
  
  isEmpty(): boolean {
    return this.size === 0;
  }
  
  getSize(): number {
    return this.size;
  }
  
  clear(): void {
    this.head = 0;
    this.tail = 0;
    this.size = 0;
  }
  
  toArray(): T[] {
    const result: T[] = [];
    for (let i = 0; i < this.size; i++) {
      result.push(this.buffer[(this.head + i) % this.capacity]);
    }
    return result;
  }
}
```

### 6.2 数据流处理器

```typescript
class DataStreamProcessor {
  private inputBuffer: CircularBuffer<Buffer>;
  private outputQueue: Buffer[] = [];
  private processInterval: NodeJS.Timeout | null = null;
  
  constructor(bufferSize: number = 1024) {
    this.inputBuffer = new CircularBuffer<Buffer>(bufferSize);
  }
  
  start(processFrequency: number = 100): void {
    if (this.processInterval) {
      this.stop();
    }
    
    this.processInterval = setInterval(() => {
      this.processBuffer();
    }, 1000 / processFrequency);
  }
  
  stop(): void {
    if (this.processInterval) {
      clearInterval(this.processInterval);
      this.processInterval = null;
    }
  }
  
  pushData(data: Buffer): void {
    this.inputBuffer.push(data);
  }
  
  private processBuffer(): void {
    const batchSize = Math.min(10, this.inputBuffer.getSize());
    const batch: Buffer[] = [];
    
    for (let i = 0; i < batchSize; i++) {
      const data = this.inputBuffer.pop();
      if (data) {
        batch.push(data);
      }
    }
    
    if (batch.length > 0) {
      const combinedData = Buffer.concat(batch);
      this.outputQueue.push(combinedData);
      
      // 触发处理事件
      this.emit('processed', combinedData);
    }
  }
  
  getProcessedData(): Buffer[] {
    const result = [...this.outputQueue];
    this.outputQueue = [];
    return result;
  }
}
```

## 7. 错误处理和重连机制

### 7.1 连接状态管理

```typescript
enum ConnectionState {
  Disconnected = 'disconnected',
  Connecting = 'connecting',
  Connected = 'connected',
  Reconnecting = 'reconnecting',
  Error = 'error'
}

class ConnectionManager {
  private state: ConnectionState = ConnectionState.Disconnected;
  private reconnectAttempts: number = 0;
  private maxReconnectAttempts: number = 5;
  private reconnectDelay: number = 3000;
  private reconnectTimer: NodeJS.Timeout | null = null;
  
  constructor(private driver: HALDriver) {
    this.setupDriverEvents();
  }
  
  private setupDriverEvents(): void {
    this.driver.on('connect', () => {
      this.setState(ConnectionState.Connected);
      this.reconnectAttempts = 0;
    });
    
    this.driver.on('disconnect', () => {
      if (this.state === ConnectionState.Connected) {
        this.setState(ConnectionState.Disconnected);
        this.attemptReconnect();
      }
    });
    
    this.driver.on('error', (error: Error) => {
      this.setState(ConnectionState.Error);
      console.error('Driver error:', error);
      this.attemptReconnect();
    });
  }
  
  private setState(newState: ConnectionState): void {
    const oldState = this.state;
    this.state = newState;
    
    if (oldState !== newState) {
      this.emit('stateChange', newState, oldState);
    }
  }
  
  private attemptReconnect(): void {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      this.setState(ConnectionState.Error);
      return;
    }
    
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }
    
    this.setState(ConnectionState.Reconnecting);
    this.reconnectAttempts++;
    
    this.reconnectTimer = setTimeout(async () => {
      try {
        await this.driver.connect();
      } catch (error) {
        console.error(`Reconnect attempt ${this.reconnectAttempts} failed:`, error);
        this.attemptReconnect();
      }
    }, this.reconnectDelay * this.reconnectAttempts);
  }
  
  async connect(): Promise<void> {
    if (this.state === ConnectionState.Connected) {
      return;
    }
    
    this.setState(ConnectionState.Connecting);
    this.reconnectAttempts = 0;
    
    try {
      await this.driver.connect();
    } catch (error) {
      this.setState(ConnectionState.Error);
      throw error;
    }
  }
  
  async disconnect(): Promise<void> {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    
    this.reconnectAttempts = this.maxReconnectAttempts; // 阻止自动重连
    await this.driver.disconnect();
    this.setState(ConnectionState.Disconnected);
  }
  
  getState(): ConnectionState {
    return this.state;
  }
}
```

## 8. 性能监控和统计

### 8.1 通信统计

```typescript
interface CommunicationStats {
  bytesReceived: number;
  bytesSent: number;
  packetsReceived: number;
  packetsSent: number;
  errors: number;
  connectionTime: number;
  lastActivity: Date;
}

class CommunicationMonitor {
  private stats: CommunicationStats = {
    bytesReceived: 0,
    bytesSent: 0,
    packetsReceived: 0,
    packetsSent: 0,
    errors: 0,
    connectionTime: 0,
    lastActivity: new Date()
  };
  
  private connectionStartTime: Date | null = null;
  
  onConnect(): void {
    this.connectionStartTime = new Date();
    this.stats.lastActivity = new Date();
  }
  
  onDisconnect(): void {
    if (this.connectionStartTime) {
      this.stats.connectionTime += Date.now() - this.connectionStartTime.getTime();
      this.connectionStartTime = null;
    }
  }
  
  onDataReceived(data: Buffer): void {
    this.stats.bytesReceived += data.length;
    this.stats.packetsReceived++;
    this.stats.lastActivity = new Date();
  }
  
  onDataSent(data: Buffer): void {
    this.stats.bytesSent += data.length;
    this.stats.packetsSent++;
    this.stats.lastActivity = new Date();
  }
  
  onError(): void {
    this.stats.errors++;
  }
  
  getStats(): CommunicationStats {
    const current = { ...this.stats };
    
    if (this.connectionStartTime) {
      current.connectionTime += Date.now() - this.connectionStartTime.getTime();
    }
    
    return current;
  }
  
  reset(): void {
    this.stats = {
      bytesReceived: 0,
      bytesSent: 0,
      packetsReceived: 0,
      packetsSent: 0,
      errors: 0,
      connectionTime: 0,
      lastActivity: new Date()
    };
    this.connectionStartTime = null;
  }
  
  getThroughput(): { rx: number; tx: number } {
    const timeSpan = this.stats.connectionTime / 1000; // 转换为秒
    
    return {
      rx: timeSpan > 0 ? this.stats.bytesReceived / timeSpan : 0,
      tx: timeSpan > 0 ? this.stats.bytesSent / timeSpan : 0
    };
  }
}
```

## 9. 测试和验证

### 9.1 单元测试示例

```typescript
import { UARTDriver } from './UARTDriver';

describe('UARTDriver', () => {
  let driver: UARTDriver;
  
  beforeEach(() => {
    driver = new UARTDriver();
  });
  
  afterEach(async () => {
    if (driver.isOpen()) {
      await driver.disconnect();
    }
  });
  
  test('should configure correctly', () => {
    const config = {
      name: 'test',
      type: BusType.UART,
      portPath: '/dev/ttyUSB0',
      baudRate: 9600,
      dataBits: 8,
      stopBits: 1,
      parity: 'none',
      flowControl: 'none',
      dtrEnabled: false,
      autoReconnect: false,
      bufferSize: 1024,
      timeout: 5000
    };
    
    driver.configure(config);
    expect(driver.configurationOk()).toBe(true);
  });
  
  test('should emit data events', (done) => {
    const testData = Buffer.from('Hello, World!');
    
    driver.on('data', (data: Buffer) => {
      expect(data).toEqual(testData);
      done();
    });
    
    // 模拟数据接收
    driver.emit('data', testData);
  });
  
  test('should handle connection errors', (done) => {
    driver.on('error', (error: Error) => {
      expect(error).toBeInstanceOf(Error);
      done();
    });
    
    // 模拟连接错误
    driver.emit('error', new Error('Test error'));
  });
});
```

这个通讯模块设计提供了完整的硬件抽象层，支持多种通讯协议，并包含了完善的错误处理、重连机制和性能监控功能。通过统一的接口设计，可以轻松地扩展新的通讯协议，同时保持代码的可维护性和可测试性。