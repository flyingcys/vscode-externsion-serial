# Serial-Studio VSCode 插件数据解析模块设计

## 1. 数据解析模块概述

数据解析模块是 Serial-Studio VSCode 插件的核心组件，负责将从通讯模块接收到的原始数据流转换为结构化的数据对象。该模块基于对 Serial-Studio JSON 和 FrameReader 模块的深度分析，实现了灵活的数据解析、帧检测、数据验证和项目配置管理功能。

### 1.1 模块职责

- **数据流解析**：将连续的数据流分割为独立的数据帧
- **多格式解码**：支持多种数据编码格式（文本、十六进制、Base64、二进制）
- **帧检测机制**：实现多种帧边界检测策略
- **自定义解析器**：支持 JavaScript 自定义数据解析逻辑
- **数据验证**：提供校验和等数据完整性验证
- **项目管理**：处理项目配置文件的加载、保存和验证

### 1.2 核心特性

- **高性能处理**：使用环形缓冲区和多线程处理大数据流
- **实时解析**：支持实时数据流的增量解析
- **容错机制**：处理数据传输错误和格式异常
- **可扩展性**：支持插件化的解析器扩展
- **调试支持**：提供详细的解析日志和错误诊断

## 2. 数据解析架构设计

### 2.1 模块架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Data Parsing Module                     │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │   Frame Reader  │  │   Data Decoder  │  │ Frame Parser │ │
│  │  - Buffer Mgmt  │  │  - PlainText    │  │ - JS Engine  │ │
│  │  - Frame Detection│  │  - Hexadecimal │  │ - Custom     │ │
│  │  - Validation   │  │  - Base64       │  │ - Validation │ │
│  │  - Threading    │  │  - Binary       │  │              │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────┐  ┌─────────────────┐  ┌──────────────┐ │
│  │ Project Manager │  │  Frame Builder  │  │Data Validator│ │
│  │ - Config Load   │  │ - JSON Schema   │  │ - Checksum   │ │
│  │ - Schema Valid  │  │ - Data Mapping  │  │ - CRC        │ │
│  │ - File I/O      │  │ - Type Convert  │  │ - Custom     │ │
│  └─────────────────┘  └─────────────────┘  └──────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                  Data Model Layer                      │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ │ │
│  │  │    Frame    │  │    Group    │  │    Dataset      │ │ │
│  │  │    Action   │  │             │  │                 │ │ │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘ │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 数据流处理管道

```
Raw Data Stream → Frame Reader → Data Decoder → Frame Parser → Frame Builder → Structured Data
       ↓              ↓              ↓              ↓              ↓              ↓
   Buffer Management   Frame Detection  Format Decode   JS Execute    Data Mapping   Dashboard Update
```

## 3. 帧读取器（Frame Reader）设计

### 3.1 帧检测模式

```typescript
enum FrameDetection {
  EndDelimiterOnly = 0,     // 仅使用结束符
  StartAndEndDelimiter = 1, // 使用开始符和结束符
  NoDelimiters = 2,         // 无分隔符（固定长度或连续数据）
  StartDelimiterOnly = 3    // 仅使用开始符
}

enum DecoderMethod {
  PlainText = 0,   // 纯文本
  Hexadecimal = 1, // 十六进制
  Base64 = 2,      // Base64编码
  Binary = 3       // 二进制数据
}
```

### 3.2 帧读取器实现

```typescript
class FrameReader {
  private buffer: CircularBuffer<number>;
  private frameDetectionMode: FrameDetection;
  private decoderMethod: DecoderMethod;
  private startSequence: Buffer;
  private finishSequence: Buffer;
  private checksumAlgorithm: string;
  private frameQueue: Queue<Buffer> = new Queue();
  
  constructor(bufferSize: number = 8192) {
    this.buffer = new CircularBuffer<number>(bufferSize);
  }
  
  configure(config: FrameReaderConfig): void {
    this.frameDetectionMode = config.frameDetection;
    this.decoderMethod = config.decoder;
    this.startSequence = Buffer.from(config.frameStart, 'utf8');
    this.finishSequence = Buffer.from(config.frameEnd, 'utf8');
    this.checksumAlgorithm = config.checksum || 'none';
  }
  
  processData(data: Buffer): void {
    // 将数据添加到环形缓冲区
    for (const byte of data) {
      this.buffer.push(byte);
    }
    
    // 根据帧检测模式处理数据
    switch (this.frameDetectionMode) {
      case FrameDetection.EndDelimiterOnly:
        this.processEndDelimitedFrames();
        break;
      case FrameDetection.StartAndEndDelimiter:
        this.processStartEndDelimitedFrames();
        break;
      case FrameDetection.NoDelimiters:
        this.processNoDelimiterFrames();
        break;
      case FrameDetection.StartDelimiterOnly:
        this.processStartDelimitedFrames();
        break;
    }
  }
  
  private processEndDelimitedFrames(): void {
    const bufferData = this.buffer.toArray();
    const endDelimiterBytes = Array.from(this.finishSequence);
    
    let frameStart = 0;
    for (let i = 0; i <= bufferData.length - endDelimiterBytes.length; i++) {
      if (this.matchesSequence(bufferData, i, endDelimiterBytes)) {
        // 找到帧结束标志
        const frameData = bufferData.slice(frameStart, i);
        const frame = Buffer.from(frameData);
        
        if (this.validateFrame(frame)) {
          this.frameQueue.enqueue(frame);
          this.emit('frameReady', frame);
        }
        
        // 从缓冲区移除已处理的数据
        this.buffer.removeRange(0, i + endDelimiterBytes.length);
        frameStart = 0;
        i = -1; // 重新开始搜索
      }
    }
  }
  
  private processStartEndDelimitedFrames(): void {
    const bufferData = this.buffer.toArray();
    const startDelimiterBytes = Array.from(this.startSequence);
    const endDelimiterBytes = Array.from(this.finishSequence);
    
    let frameStart = -1;
    
    for (let i = 0; i <= bufferData.length - Math.max(startDelimiterBytes.length, endDelimiterBytes.length); i++) {
      // 寻找帧开始标志
      if (frameStart === -1 && this.matchesSequence(bufferData, i, startDelimiterBytes)) {
        frameStart = i + startDelimiterBytes.length;
        i += startDelimiterBytes.length - 1;
        continue;
      }
      
      // 寻找帧结束标志
      if (frameStart !== -1 && this.matchesSequence(bufferData, i, endDelimiterBytes)) {
        const frameData = bufferData.slice(frameStart, i);
        const frame = Buffer.from(frameData);
        
        if (this.validateFrame(frame)) {
          this.frameQueue.enqueue(frame);
          this.emit('frameReady', frame);
        }
        
        // 从缓冲区移除已处理的数据
        this.buffer.removeRange(0, i + endDelimiterBytes.length);
        frameStart = -1;
        i = -1; // 重新开始搜索
      }
    }
  }
  
  private processNoDelimiterFrames(): void {
    // 对于无分隔符模式，立即处理所有数据
    if (this.buffer.getSize() > 0) {
      const frameData = this.buffer.toArray();
      const frame = Buffer.from(frameData);
      
      if (this.validateFrame(frame)) {
        this.frameQueue.enqueue(frame);
        this.emit('frameReady', frame);
      }
      
      this.buffer.clear();
    }
  }
  
  private matchesSequence(data: number[], startIndex: number, sequence: number[]): boolean {
    if (startIndex + sequence.length > data.length) {
      return false;
    }
    
    for (let i = 0; i < sequence.length; i++) {
      if (data[startIndex + i] !== sequence[i]) {
        return false;
      }
    }
    
    return true;
  }
  
  private validateFrame(frame: Buffer): boolean {
    if (frame.length === 0) {
      return false;
    }
    
    // 校验和验证
    if (this.checksumAlgorithm !== 'none') {
      return this.validateChecksum(frame);
    }
    
    return true;
  }
  
  private validateChecksum(frame: Buffer): boolean {
    switch (this.checksumAlgorithm.toLowerCase()) {
      case 'crc8':
        return this.validateCRC8(frame);
      case 'crc16':
        return this.validateCRC16(frame);
      case 'md5':
        return this.validateMD5(frame);
      case 'checksum':
        return this.validateSimpleChecksum(frame);
      default:
        return true;
    }
  }
  
  getFrames(): Buffer[] {
    const frames: Buffer[] = [];
    while (!this.frameQueue.isEmpty()) {
      frames.push(this.frameQueue.dequeue()!);
    }
    return frames;
  }
}
```

### 3.3 数据解码器

```typescript
class DataDecoder {
  static decode(data: Buffer, method: DecoderMethod): string {
    switch (method) {
      case DecoderMethod.PlainText:
        return data.toString('utf8');
      
      case DecoderMethod.Hexadecimal:
        return this.decodeHexadecimal(data);
      
      case DecoderMethod.Base64:
        return this.decodeBase64(data);
      
      case DecoderMethod.Binary:
        return this.decodeBinary(data);
      
      default:
        throw new Error(`Unsupported decoder method: ${method}`);
    }
  }
  
  private static decodeHexadecimal(data: Buffer): string {
    // 移除空格和分隔符
    const hexString = data.toString().replace(/\s+/g, '');
    
    // 验证十六进制格式
    if (!/^[0-9A-Fa-f]*$/.test(hexString)) {
      throw new Error('Invalid hexadecimal format');
    }
    
    // 确保长度为偶数
    const paddedHex = hexString.length % 2 === 0 ? hexString : '0' + hexString;
    
    // 转换为字节数组然后转为字符串
    const bytes = Buffer.from(paddedHex, 'hex');
    return bytes.toString('utf8');
  }
  
  private static decodeBase64(data: Buffer): string {
    try {
      const base64String = data.toString().replace(/\s+/g, '');
      const decoded = Buffer.from(base64String, 'base64');
      return decoded.toString('utf8');
    } catch (error) {
      throw new Error('Invalid Base64 format');
    }
  }
  
  private static decodeBinary(data: Buffer): string {
    // 对于二进制数据，使用十六进制表示以便显示
    return data.toString('hex').toUpperCase().replace(/(.{2})/g, '$1 ').trim();
  }
  
  static encode(text: string, method: DecoderMethod): Buffer {
    switch (method) {
      case DecoderMethod.PlainText:
        return Buffer.from(text, 'utf8');
      
      case DecoderMethod.Hexadecimal:
        return this.encodeHexadecimal(text);
      
      case DecoderMethod.Base64:
        return this.encodeBase64(text);
      
      case DecoderMethod.Binary:
        return this.encodeBinary(text);
      
      default:
        throw new Error(`Unsupported encoder method: ${method}`);
    }
  }
  
  private static encodeHexadecimal(text: string): Buffer {
    const bytes = Buffer.from(text, 'utf8');
    return Buffer.from(bytes.toString('hex'), 'ascii');
  }
  
  private static encodeBase64(text: string): Buffer {
    const bytes = Buffer.from(text, 'utf8');
    return Buffer.from(bytes.toString('base64'), 'ascii');
  }
  
  private static encodeBinary(text: string): Buffer {
    return Buffer.from(text, 'utf8');
  }
}
```

## 4. JavaScript 解析器引擎

### 4.1 解析器执行环境

```typescript
import { VM } from 'vm2';

class FrameParser {
  private vm: VM;
  private parseFunction: Function | null = null;
  private defaultCode: string;
  
  constructor() {
    this.defaultCode = this.getDefaultParserCode();
    this.initializeVM();
  }
  
  private initializeVM(): void {
    this.vm = new VM({
      timeout: 1000, // 1秒超时
      sandbox: {
        // 提供安全的全局对象
        console: {
          log: (...args: any[]) => console.log('[Parser]', ...args),
          error: (...args: any[]) => console.error('[Parser]', ...args)
        },
        // 数学函数
        Math: Math,
        // 字符串处理函数
        parseFloat: parseFloat,
        parseInt: parseInt,
        isNaN: isNaN,
        isFinite: isFinite
      },
      eval: false, // 禁用 eval
      wasm: false  // 禁用 WebAssembly
    });
  }
  
  loadScript(code: string): boolean {
    try {
      // 执行解析器代码
      const result = this.vm.run(code);
      
      // 验证解析函数是否存在
      const parseFunction = this.vm.run('typeof parse === "function" ? parse : null');
      
      if (!parseFunction) {
        throw new Error('Parse function not found. Please define a "parse" function.');
      }
      
      this.parseFunction = parseFunction;
      return true;
    } catch (error) {
      console.error('Failed to load parser script:', error);
      this.parseFunction = null;
      return false;
    }
  }
  
  parse(frameData: string): string[] {
    if (!this.parseFunction) {
      // 使用默认解析器
      return this.defaultParse(frameData);
    }
    
    try {
      // 在安全的VM环境中执行解析函数
      const result = this.vm.run(`parse(${JSON.stringify(frameData)})`);
      
      // 验证返回结果
      if (!Array.isArray(result)) {
        throw new Error('Parse function must return an array');
      }
      
      return result.map(item => String(item));
    } catch (error) {
      console.error('Parser execution error:', error);
      
      // 回退到默认解析器
      return this.defaultParse(frameData);
    }
  }
  
  private defaultParse(frameData: string): string[] {
    // 默认使用逗号分隔
    return frameData.split(',').map(item => item.trim());
  }
  
  private getDefaultParserCode(): string {
    return `
/**
 * 默认数据帧解析函数
 * 使用逗号分隔符将数据帧分割为数组
 *
 * @param {string} frame - 输入的数据帧字符串
 * @returns {string[]} - 解析后的数据数组
 */
function parse(frame) {
    // 移除首尾空白字符
    frame = frame.trim();
    
    // 如果帧为空，返回空数组
    if (!frame) {
        return [];
    }
    
    // 使用逗号分隔并清理每个元素
    return frame.split(',').map(function(item) {
        return item.trim();
    });
}
`;
  }
  
  validateScript(code: string): { valid: boolean; error?: string } {
    try {
      const testVM = new VM({
        timeout: 100,
        sandbox: {},
        eval: false,
        wasm: false
      });
      
      testVM.run(code);
      
      const parseFunction = testVM.run('typeof parse === "function" ? parse : null');
      if (!parseFunction) {
        return { valid: false, error: 'Parse function not found' };
      }
      
      // 测试解析函数
      const testResult = testVM.run('parse("test,data,frame")');
      if (!Array.isArray(testResult)) {
        return { valid: false, error: 'Parse function must return an array' };
      }
      
      return { valid: true };
    } catch (error) {
      return { valid: false, error: (error as Error).message };
    }
  }
  
  getDefaultCode(): string {
    return this.defaultCode;
  }
}
```

### 4.2 解析器调试工具

```typescript
class ParserDebugger {
  private executionHistory: ExecutionRecord[] = [];
  private maxHistorySize = 100;
  
  debugParse(parser: FrameParser, frameData: string): DebugResult {
    const startTime = Date.now();
    const debugId = this.generateDebugId();
    
    try {
      // 记录输入
      const inputRecord: ExecutionRecord = {
        id: debugId,
        timestamp: new Date(),
        type: 'input',
        data: frameData,
        executionTime: 0
      };
      
      // 执行解析
      const result = parser.parse(frameData);
      const executionTime = Date.now() - startTime;
      
      // 记录输出
      const outputRecord: ExecutionRecord = {
        id: debugId,
        timestamp: new Date(),
        type: 'output',
        data: result,
        executionTime
      };
      
      // 添加到历史记录
      this.addToHistory(inputRecord);
      this.addToHistory(outputRecord);
      
      return {
        success: true,
        result,
        executionTime,
        debugId
      };
    } catch (error) {
      const errorRecord: ExecutionRecord = {
        id: debugId,
        timestamp: new Date(),
        type: 'error',
        data: (error as Error).message,
        executionTime: Date.now() - startTime
      };
      
      this.addToHistory(errorRecord);
      
      return {
        success: false,
        error: (error as Error).message,
        executionTime: Date.now() - startTime,
        debugId
      };
    }
  }
  
  private addToHistory(record: ExecutionRecord): void {
    this.executionHistory.push(record);
    
    if (this.executionHistory.length > this.maxHistorySize) {
      this.executionHistory.shift();
    }
  }
  
  getExecutionHistory(): ExecutionRecord[] {
    return [...this.executionHistory];
  }
  
  clearHistory(): void {
    this.executionHistory = [];
  }
  
  private generateDebugId(): string {
    return Math.random().toString(36).substr(2, 9);
  }
  
  exportDebugLog(): string {
    const log = {
      timestamp: new Date().toISOString(),
      history: this.executionHistory
    };
    
    return JSON.stringify(log, null, 2);
  }
}

interface ExecutionRecord {
  id: string;
  timestamp: Date;
  type: 'input' | 'output' | 'error';
  data: any;
  executionTime: number;
}

interface DebugResult {
  success: boolean;
  result?: string[];
  error?: string;
  executionTime: number;
  debugId: string;
}
```

## 5. 数据校验系统

### 5.1 校验算法实现

```typescript
class ChecksumValidator {
  static validate(data: Buffer, algorithm: string): boolean {
    const algorithms = {
      'crc8': this.validateCRC8,
      'crc16': this.validateCRC16,
      'crc32': this.validateCRC32,
      'md5': this.validateMD5,
      'checksum': this.validateSimpleChecksum,
      'xor': this.validateXOR
    };
    
    const validator = algorithms[algorithm.toLowerCase() as keyof typeof algorithms];
    if (!validator) {
      throw new Error(`Unsupported checksum algorithm: ${algorithm}`);
    }
    
    return validator.call(this, data);
  }
  
  private static validateCRC8(data: Buffer): boolean {
    if (data.length < 2) return false;
    
    const payload = data.slice(0, -1);
    const expectedCRC = data[data.length - 1];
    const calculatedCRC = this.calculateCRC8(payload);
    
    return expectedCRC === calculatedCRC;
  }
  
  private static calculateCRC8(data: Buffer): number {
    let crc = 0x00;
    const polynomial = 0x31; // CRC-8-CCITT
    
    for (const byte of data) {
      crc ^= byte;
      for (let i = 0; i < 8; i++) {
        if (crc & 0x80) {
          crc = (crc << 1) ^ polynomial;
        } else {
          crc = crc << 1;
        }
        crc &= 0xFF;
      }
    }
    
    return crc;
  }
  
  private static validateCRC16(data: Buffer): boolean {
    if (data.length < 3) return false;
    
    const payload = data.slice(0, -2);
    const expectedCRC = data.readUInt16BE(data.length - 2);
    const calculatedCRC = this.calculateCRC16(payload);
    
    return expectedCRC === calculatedCRC;
  }
  
  private static calculateCRC16(data: Buffer): number {
    let crc = 0xFFFF;
    const polynomial = 0x1021; // CRC-16-CCITT
    
    for (const byte of data) {
      crc ^= (byte << 8);
      for (let i = 0; i < 8; i++) {
        if (crc & 0x8000) {
          crc = (crc << 1) ^ polynomial;
        } else {
          crc = crc << 1;
        }
        crc &= 0xFFFF;
      }
    }
    
    return crc;
  }
  
  private static validateSimpleChecksum(data: Buffer): boolean {
    if (data.length < 2) return false;
    
    const payload = data.slice(0, -1);
    const expectedChecksum = data[data.length - 1];
    
    let calculatedChecksum = 0;
    for (const byte of payload) {
      calculatedChecksum += byte;
    }
    calculatedChecksum &= 0xFF;
    
    return expectedChecksum === calculatedChecksum;
  }
  
  private static validateXOR(data: Buffer): boolean {
    if (data.length < 2) return false;
    
    const payload = data.slice(0, -1);
    const expectedXOR = data[data.length - 1];
    
    let calculatedXOR = 0;
    for (const byte of payload) {
      calculatedXOR ^= byte;
    }
    
    return expectedXOR === calculatedXOR;
  }
  
  private static validateMD5(data: Buffer): boolean {
    // MD5 校验需要外部库支持
    const crypto = require('crypto');
    
    if (data.length < 33) return false; // 至少需要1字节数据 + 32字节MD5
    
    const payload = data.slice(0, -32);
    const expectedMD5 = data.slice(-32).toString('hex');
    const calculatedMD5 = crypto.createHash('md5').update(payload).digest('hex');
    
    return expectedMD5.toLowerCase() === calculatedMD5.toLowerCase();
  }
  
  static generateChecksum(data: Buffer, algorithm: string): Buffer {
    switch (algorithm.toLowerCase()) {
      case 'crc8':
        return Buffer.from([this.calculateCRC8(data)]);
      case 'crc16':
        const crc16 = this.calculateCRC16(data);
        return Buffer.from([(crc16 >> 8) & 0xFF, crc16 & 0xFF]);
      case 'checksum':
        let sum = 0;
        for (const byte of data) sum += byte;
        return Buffer.from([sum & 0xFF]);
      case 'xor':
        let xor = 0;
        for (const byte of data) xor ^= byte;
        return Buffer.from([xor]);
      default:
        throw new Error(`Unsupported checksum algorithm: ${algorithm}`);
    }
  }
}
```

## 6. 项目配置管理

### 6.1 项目模型定义

```typescript
interface ProjectConfig {
  title: string;
  decoder: DecoderMethod;
  frameDetection: FrameDetection;
  frameStart: string;
  frameEnd: string;
  frameParser: string;
  checksum?: string;
  groups: GroupConfig[];
  actions: ActionConfig[];
}

interface GroupConfig {
  title: string;
  widget: string;
  datasets: DatasetConfig[];
}

interface DatasetConfig {
  title: string;
  units: string;
  value: string;
  widget: string;
  index: number;
  min: number;
  max: number;
  alarm: number;
  graph: boolean;
  fft: boolean;
  led: boolean;
  fftSamples?: number;
  fftSamplingRate?: number;
  ledHigh?: number;
  log?: boolean;
}

interface ActionConfig {
  title: string;
  icon: string;
  txData: string;
  eolSequence: string;
}
```

### 6.2 项目管理器实现

```typescript
class ProjectManager {
  private currentProject: ProjectConfig | null = null;
  private projectSchema: JSONSchema;
  private modified: boolean = false;
  
  constructor() {
    this.projectSchema = this.loadProjectSchema();
  }
  
  async loadProject(filePath: string): Promise<ProjectConfig> {
    try {
      const fileContent = await fs.readFile(filePath, 'utf8');
      const projectData = JSON.parse(fileContent);
      
      // 验证项目配置
      const validation = this.validateProject(projectData);
      if (!validation.valid) {
        throw new Error(`Invalid project configuration: ${validation.errors.join(', ')}`);
      }
      
      this.currentProject = projectData;
      this.modified = false;
      
      return projectData;
    } catch (error) {
      throw new Error(`Failed to load project: ${(error as Error).message}`);
    }
  }
  
  async saveProject(filePath: string, project?: ProjectConfig): Promise<void> {
    const projectToSave = project || this.currentProject;
    if (!projectToSave) {
      throw new Error('No project to save');
    }
    
    try {
      // 验证项目配置
      const validation = this.validateProject(projectToSave);
      if (!validation.valid) {
        throw new Error(`Invalid project configuration: ${validation.errors.join(', ')}`);
      }
      
      const jsonContent = JSON.stringify(projectToSave, null, 2);
      await fs.writeFile(filePath, jsonContent, 'utf8');
      
      this.currentProject = projectToSave;
      this.modified = false;
    } catch (error) {
      throw new Error(`Failed to save project: ${(error as Error).message}`);
    }
  }
  
  validateProject(project: any): ValidationResult {
    const errors: string[] = [];
    
    try {
      // 基础结构验证
      if (!project.title || typeof project.title !== 'string') {
        errors.push('Project title is required and must be a string');
      }
      
      if (typeof project.decoder !== 'number' || project.decoder < 0 || project.decoder > 3) {
        errors.push('Invalid decoder method');
      }
      
      if (typeof project.frameDetection !== 'number' || project.frameDetection < 0 || project.frameDetection > 3) {
        errors.push('Invalid frame detection method');
      }
      
      // 验证组配置
      if (!Array.isArray(project.groups)) {
        errors.push('Groups must be an array');
      } else {
        project.groups.forEach((group: any, index: number) => {
          const groupErrors = this.validateGroup(group);
          if (groupErrors.length > 0) {
            errors.push(`Group ${index + 1}: ${groupErrors.join(', ')}`);
          }
        });
      }
      
      // 验证动作配置
      if (project.actions && !Array.isArray(project.actions)) {
        errors.push('Actions must be an array');
      } else if (project.actions) {
        project.actions.forEach((action: any, index: number) => {
          const actionErrors = this.validateAction(action);
          if (actionErrors.length > 0) {
            errors.push(`Action ${index + 1}: ${actionErrors.join(', ')}`);
          }
        });
      }
      
      return { valid: errors.length === 0, errors };
    } catch (error) {
      return { valid: false, errors: [`Validation error: ${(error as Error).message}`] };
    }
  }
  
  private validateGroup(group: any): string[] {
    const errors: string[] = [];
    
    if (!group.title || typeof group.title !== 'string') {
      errors.push('Group title is required');
    }
    
    if (!group.widget || typeof group.widget !== 'string') {
      errors.push('Group widget is required');
    }
    
    if (!Array.isArray(group.datasets)) {
      errors.push('Group datasets must be an array');
    } else {
      group.datasets.forEach((dataset: any, index: number) => {
        const datasetErrors = this.validateDataset(dataset);
        if (datasetErrors.length > 0) {
          errors.push(`Dataset ${index + 1}: ${datasetErrors.join(', ')}`);
        }
      });
    }
    
    return errors;
  }
  
  private validateDataset(dataset: any): string[] {
    const errors: string[] = [];
    
    if (!dataset.title || typeof dataset.title !== 'string') {
      errors.push('Dataset title is required');
    }
    
    if (typeof dataset.index !== 'number' || dataset.index < 0) {
      errors.push('Dataset index must be a non-negative number');
    }
    
    if (typeof dataset.min !== 'number' || typeof dataset.max !== 'number') {
      errors.push('Dataset min and max must be numbers');
    }
    
    if (dataset.min >= dataset.max) {
      errors.push('Dataset max must be greater than min');
    }
    
    return errors;
  }
  
  private validateAction(action: any): string[] {
    const errors: string[] = [];
    
    if (!action.title || typeof action.title !== 'string') {
      errors.push('Action title is required');
    }
    
    if (!action.txData || typeof action.txData !== 'string') {
      errors.push('Action txData is required');
    }
    
    return errors;
  }
  
  createNewProject(): ProjectConfig {
    const newProject: ProjectConfig = {
      title: 'New Project',
      decoder: DecoderMethod.PlainText,
      frameDetection: FrameDetection.EndDelimiterOnly,
      frameStart: '$',
      frameEnd: ';',
      frameParser: new FrameParser().getDefaultCode(),
      groups: [],
      actions: []
    };
    
    this.currentProject = newProject;
    this.modified = false;
    
    return newProject;
  }
  
  getCurrentProject(): ProjectConfig | null {
    return this.currentProject;
  }
  
  isModified(): boolean {
    return this.modified;
  }
  
  setModified(modified: boolean): void {
    this.modified = modified;
  }
  
  addGroup(group: GroupConfig): void {
    if (!this.currentProject) {
      throw new Error('No project loaded');
    }
    
    this.currentProject.groups.push(group);
    this.modified = true;
  }
  
  removeGroup(index: number): void {
    if (!this.currentProject) {
      throw new Error('No project loaded');
    }
    
    if (index < 0 || index >= this.currentProject.groups.length) {
      throw new Error('Invalid group index');
    }
    
    this.currentProject.groups.splice(index, 1);
    this.modified = true;
  }
  
  addDataset(groupIndex: number, dataset: DatasetConfig): void {
    if (!this.currentProject) {
      throw new Error('No project loaded');
    }
    
    if (groupIndex < 0 || groupIndex >= this.currentProject.groups.length) {
      throw new Error('Invalid group index');
    }
    
    this.currentProject.groups[groupIndex].datasets.push(dataset);
    this.modified = true;
  }
}

interface ValidationResult {
  valid: boolean;
  errors: string[];
}
```

## 7. 性能优化和监控

### 7.1 解析性能监控

```typescript
class ParsePerformanceMonitor {
  private metrics: PerformanceMetrics = {
    totalFrames: 0,
    successfulParses: 0,
    failedParses: 0,
    averageParseTime: 0,
    maxParseTime: 0,
    minParseTime: Infinity,
    bytesProcessed: 0,
    errorsPerMinute: 0,
    throughput: 0
  };
  
  private recentParseTimes: number[] = [];
  private errorTimestamps: number[] = [];
  private startTime: number = Date.now();
  
  recordParseOperation(duration: number, success: boolean, dataSize: number): void {
    this.metrics.totalFrames++;
    this.metrics.bytesProcessed += dataSize;
    
    if (success) {
      this.metrics.successfulParses++;
      this.updateParseTimeMetrics(duration);
    } else {
      this.metrics.failedParses++;
      this.recordError();
    }
    
    this.updateThroughput();
  }
  
  private updateParseTimeMetrics(duration: number): void {
    this.recentParseTimes.push(duration);
    
    // 保持最近100次解析的记录
    if (this.recentParseTimes.length > 100) {
      this.recentParseTimes.shift();
    }
    
    this.metrics.maxParseTime = Math.max(this.metrics.maxParseTime, duration);
    this.metrics.minParseTime = Math.min(this.metrics.minParseTime, duration);
    
    // 计算平均解析时间
    const sum = this.recentParseTimes.reduce((a, b) => a + b, 0);
    this.metrics.averageParseTime = sum / this.recentParseTimes.length;
  }
  
  private recordError(): void {
    const now = Date.now();
    this.errorTimestamps.push(now);
    
    // 保持最近1分钟的错误记录
    this.errorTimestamps = this.errorTimestamps.filter(
      timestamp => now - timestamp < 60000
    );
    
    this.metrics.errorsPerMinute = this.errorTimestamps.length;
  }
  
  private updateThroughput(): void {
    const elapsedSeconds = (Date.now() - this.startTime) / 1000;
    this.metrics.throughput = this.metrics.bytesProcessed / elapsedSeconds;
  }
  
  getMetrics(): PerformanceMetrics {
    return { ...this.metrics };
  }
  
  reset(): void {
    this.metrics = {
      totalFrames: 0,
      successfulParses: 0,
      failedParses: 0,
      averageParseTime: 0,
      maxParseTime: 0,
      minParseTime: Infinity,
      bytesProcessed: 0,
      errorsPerMinute: 0,
      throughput: 0
    };
    
    this.recentParseTimes = [];
    this.errorTimestamps = [];
    this.startTime = Date.now();
  }
  
  generateReport(): string {
    const metrics = this.getMetrics();
    const successRate = metrics.totalFrames > 0 
      ? (metrics.successfulParses / metrics.totalFrames * 100).toFixed(2)
      : '0';
    
    return `
Performance Report
==================
Total Frames: ${metrics.totalFrames}
Success Rate: ${successRate}%
Average Parse Time: ${metrics.averageParseTime.toFixed(2)}ms
Max Parse Time: ${metrics.maxParseTime.toFixed(2)}ms
Min Parse Time: ${metrics.minParseTime === Infinity ? 'N/A' : metrics.minParseTime.toFixed(2)}ms
Bytes Processed: ${(metrics.bytesProcessed / 1024).toFixed(2)} KB
Throughput: ${(metrics.throughput / 1024).toFixed(2)} KB/s
Errors Per Minute: ${metrics.errorsPerMinute}
    `.trim();
  }
}

interface PerformanceMetrics {
  totalFrames: number;
  successfulParses: number;
  failedParses: number;
  averageParseTime: number;
  maxParseTime: number;
  minParseTime: number;
  bytesProcessed: number;
  errorsPerMinute: number;
  throughput: number;
}
```

## 8. 测试框架

### 8.1 解析器测试套件

```typescript
class ParserTestSuite {
  private testCases: TestCase[] = [];
  
  addTestCase(testCase: TestCase): void {
    this.testCases.push(testCase);
  }
  
  async runTests(parser: FrameParser): Promise<TestResult[]> {
    const results: TestResult[] = [];
    
    for (const testCase of this.testCases) {
      const result = await this.runSingleTest(parser, testCase);
      results.push(result);
    }
    
    return results;
  }
  
  private async runSingleTest(parser: FrameParser, testCase: TestCase): Promise<TestResult> {
    const startTime = Date.now();
    
    try {
      const result = parser.parse(testCase.input);
      const executionTime = Date.now() - startTime;
      
      const passed = this.compareResults(result, testCase.expectedOutput);
      
      return {
        testName: testCase.name,
        passed,
        input: testCase.input,
        expectedOutput: testCase.expectedOutput,
        actualOutput: result,
        executionTime,
        error: null
      };
    } catch (error) {
      return {
        testName: testCase.name,
        passed: false,
        input: testCase.input,
        expectedOutput: testCase.expectedOutput,
        actualOutput: null,
        executionTime: Date.now() - startTime,
        error: (error as Error).message
      };
    }
  }
  
  private compareResults(actual: string[], expected: string[]): boolean {
    if (actual.length !== expected.length) {
      return false;
    }
    
    for (let i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) {
        return false;
      }
    }
    
    return true;
  }
  
  generateTestReport(results: TestResult[]): string {
    const totalTests = results.length;
    const passedTests = results.filter(r => r.passed).length;
    const failedTests = totalTests - passedTests;
    const averageTime = results.reduce((sum, r) => sum + r.executionTime, 0) / totalTests;
    
    let report = `
Test Report
===========
Total Tests: ${totalTests}
Passed: ${passedTests}
Failed: ${failedTests}
Success Rate: ${(passedTests / totalTests * 100).toFixed(2)}%
Average Execution Time: ${averageTime.toFixed(2)}ms

`;
    
    // 详细结果
    results.forEach((result, index) => {
      const status = result.passed ? '✓ PASS' : '✗ FAIL';
      report += `${index + 1}. ${result.testName}: ${status} (${result.executionTime}ms)\n`;
      
      if (!result.passed) {
        report += `   Input: ${result.input}\n`;
        report += `   Expected: [${result.expectedOutput?.join(', ')}]\n`;
        if (result.actualOutput) {
          report += `   Actual: [${result.actualOutput.join(', ')}]\n`;
        }
        if (result.error) {
          report += `   Error: ${result.error}\n`;
        }
        report += '\n';
      }
    });
    
    return report;
  }
  
  // 预定义的测试用例
  static getStandardTestSuite(): ParserTestSuite {
    const suite = new ParserTestSuite();
    
    // 基础逗号分隔测试
    suite.addTestCase({
      name: 'Basic comma separation',
      input: '1,2,3,4,5',
      expectedOutput: ['1', '2', '3', '4', '5']
    });
    
    // 包含空格的测试
    suite.addTestCase({
      name: 'Comma separation with spaces',
      input: '1.5, 2.3, 3.7 , 4.1',
      expectedOutput: ['1.5', '2.3', '3.7', '4.1']
    });
    
    // 空字符串测试
    suite.addTestCase({
      name: 'Empty string',
      input: '',
      expectedOutput: []
    });
    
    // 单个值测试
    suite.addTestCase({
      name: 'Single value',
      input: 'single',
      expectedOutput: ['single']
    });
    
    // 包含特殊字符的测试
    suite.addTestCase({
      name: 'Special characters',
      input: 'hello,world!,@#$%,test',
      expectedOutput: ['hello', 'world!', '@#$%', 'test']
    });
    
    return suite;
  }
}

interface TestCase {
  name: string;
  input: string;
  expectedOutput: string[];
}

interface TestResult {
  testName: string;
  passed: boolean;
  input: string;
  expectedOutput: string[];
  actualOutput: string[] | null;
  executionTime: number;
  error: string | null;
}
```

这个数据解析模块设计提供了完整的数据处理流水线，从原始数据流到结构化数据对象的转换。通过模块化设计，各个组件职责清晰，易于测试和维护。同时提供了强大的扩展性，支持自定义解析器和校验算法，满足各种复杂的数据处理需求。