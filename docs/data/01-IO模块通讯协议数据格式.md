# Serial-Studio IO模块通讯协议数据格式

## 概述

Serial-Studio的IO模块支持多种通讯协议，通过统一的HAL（硬件抽象层）接口实现不同设备的连接和数据传输。本文档详细描述了各种通讯协议的配置参数、数据格式和使用方法。

## 1. 通讯协议类型

### 1.1 支持的总线类型 (BusType)

```cpp
enum class BusType {
    UART,        // 串口通信
    Network,     // 网络通信 (TCP/UDP)
    BluetoothLE, // 蓝牙低功耗通信
    Audio,       // 音频输入设备 (商业版)
    ModBus,      // MODBUS通信 (商业版)
    CanBus,      // CANBUS通信 (商业版)
};
```

## 2. UART串口通讯

### 2.1 配置参数

| 参数名称 | 类型 | 描述 | 默认值 | 可选值 |
|---------|------|------|--------|--------|
| portIndex | quint8 | 串口索引 | 0 | 根据系统可用端口 |
| baudRate | qint32 | 波特率 | 9600 | 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400, 460800, 921600 |
| dataBits | DataBits | 数据位 | Data8 | Data5, Data6, Data7, Data8 |
| parity | Parity | 校验位 | NoParity | NoParity, EvenParity, OddParity, SpaceParity, MarkParity |
| stopBits | StopBits | 停止位 | OneStop | OneStop, OneAndHalfStop, TwoStop |
| flowControl | FlowControl | 流控制 | NoFlowControl | NoFlowControl, HardwareControl, SoftwareControl |
| dtrEnabled | bool | DTR使能 | false | true, false |
| autoReconnect | bool | 自动重连 | true | true, false |

### 2.2 数据格式

**发送数据格式：**
```
原始数据 -> QByteArray -> 串口发送
```

**接收数据格式：**
```
串口接收 -> QByteArray -> 帧检测 -> 数据解析
```

### 2.3 示例配置代码

```cpp
// C++配置示例
IO::Drivers::UART &uart = IO::Drivers::UART::instance();
uart.setBaudRate(115200);
uart.setDataBits(0); // Data8
uart.setParity(0);   // NoParity
uart.setStopBits(0); // OneStop
uart.setFlowControl(0); // NoFlowControl
uart.setDtrEnabled(false);
uart.setAutoReconnect(true);
```

## 3. Network网络通讯

### 3.1 配置参数

| 参数名称 | 类型 | 描述 | 默认值 | 可选值 |
|---------|------|------|--------|--------|
| socketType | SocketType | 套接字类型 | TcpSocket | TcpSocket, UdpSocket |
| remoteAddress | QString | 远程地址 | "127.0.0.1" | 任何有效IP地址或域名 |
| tcpPort | quint16 | TCP端口 | 23 | 1-65535 |
| udpLocalPort | quint16 | UDP本地端口 | 0 | 0-65535 |
| udpRemotePort | quint16 | UDP远程端口 | 53 | 1-65535 |
| udpMulticast | bool | UDP组播 | false | true, false |

### 3.2 TCP数据格式

**连接建立：**
```
客户端模式：连接到指定的remoteAddress:tcpPort
服务器模式：监听指定的tcpPort端口
```

**数据传输：**
```
发送：QByteArray -> TCP流 -> 远程主机
接收：远程主机 -> TCP流 -> QByteArray -> 帧检测
```

### 3.3 UDP数据格式

**数据传输：**
```
发送：QByteArray -> UDP数据报 -> remoteAddress:udpRemotePort
接收：任意地址:udpLocalPort -> UDP数据报 -> QByteArray -> 帧检测
```

**组播配置：**
```cpp
// 启用UDP组播
network.setUdpMulticast(true);
network.setRemoteAddress("224.0.0.1"); // 组播地址范围：224.0.0.0-239.255.255.255
```

### 3.4 示例配置代码

```cpp
// TCP客户端配置
IO::Drivers::Network &network = IO::Drivers::Network::instance();
network.setSocketType(QAbstractSocket::TcpSocket);
network.setRemoteAddress("192.168.1.100");
network.setTcpPort(8080);

// UDP配置
network.setSocketType(QAbstractSocket::UdpSocket);
network.setRemoteAddress("192.168.1.255");
network.setUdpLocalPort(12345);
network.setUdpRemotePort(12346);
network.setUdpMulticast(false);
```

## 4. BluetoothLE蓝牙低功耗通讯

### 4.1 配置参数

| 参数名称 | 类型 | 描述 | 备注 |
|---------|------|------|------|
| deviceIndex | int | 设备索引 | 从扫描到的设备列表中选择 |
| characteristicIndex | int | 特征值索引 | 从服务特征值列表中选择 |
| deviceNames | QStringList | 设备名称列表 | 只读，通过扫描获得 |
| serviceNames | QStringList | 服务名称列表 | 只读，连接设备后获得 |
| characteristicNames | QStringList | 特征值名称列表 | 只读，选择服务后获得 |

### 4.2 连接流程

```
1. 启动设备扫描 -> startDiscovery()
2. 选择设备 -> selectDevice(index)
3. 选择服务 -> selectService(index)  
4. 选择特征值 -> setCharacteristicIndex(index)
5. 建立连接 -> open()
```

### 4.3 数据格式

**BLE数据传输特点：**
- 数据包大小通常限制在20字节以内
- 支持通知(Notification)和指示(Indication)
- 数据以QByteArray格式传输

**发送数据：**
```
QByteArray -> BLE特征值写入 -> 远程设备
```

**接收数据：**
```
远程设备 -> BLE特征值通知 -> QByteArray -> 帧检测
```

### 4.4 示例配置代码

```cpp
// BLE配置示例
IO::Drivers::BluetoothLE &ble = IO::Drivers::BluetoothLE::instance();

// 启动设备扫描
ble.startDiscovery();

// 选择设备（假设选择第一个设备）
ble.selectDevice(0);

// 选择服务（假设选择第一个服务）
ble.selectService(0);

// 选择特征值（假设选择第一个可读写特征值）
ble.setCharacteristicIndex(0);
```

## 5. 数据帧检测模式

### 5.1 帧检测类型 (FrameDetection)

```cpp
enum FrameDetection {
    EndDelimiterOnly     = 0x00, // 仅结束分隔符
    StartAndEndDelimiter = 0x01, // 开始和结束分隔符
    NoDelimiters         = 0x02, // 无分隔符
    StartDelimiterOnly   = 0x03  // 仅开始分隔符
};
```

### 5.2 帧格式定义

#### 5.2.1 EndDelimiterOnly模式
```
数据内容 + 结束分隔符
示例：温度:25.6,湿度:60.2\n
```

#### 5.2.2 StartAndEndDelimiter模式  
```
开始分隔符 + 数据内容 + 结束分隔符
示例：$温度:25.6,湿度:60.2;
```

#### 5.2.3 NoDelimiters模式
```
连续数据流，按固定长度或时间间隔分帧
示例：持续的音频数据流
```

#### 5.2.4 StartDelimiterOnly模式
```
开始分隔符 + 数据内容
示例：#温度:25.6,湿度:60.2
```

### 5.3 校验和支持

支持的校验算法：
- **None**: 无校验
- **XOR**: 异或校验
- **CRC8**: CRC8校验
- **CRC16**: CRC16校验
- **CRC32**: CRC32校验

校验和格式：
```
数据内容 + 校验和 + 结束分隔符
示例：温度:25.6,湿度:60.2*AB\n
```

## 6. 数据解码方式

### 6.1 解码方法 (DecoderMethod)

```cpp
enum DecoderMethod {
    PlainText,   // 纯文本
    Hexadecimal, // 十六进制
    Base64,      // Base64编码
    Binary,      // 二进制
};
```

### 6.2 数据解码示例

#### PlainText模式
```
输入：温度:25.6,湿度:60.2
输出：温度:25.6,湿度:60.2
```

#### Hexadecimal模式
```
输入：48656C6C6F20576F726C64
输出：Hello World
```

#### Base64模式
```
输入：SGVsbG8gV29ybGQ=  
输出：Hello World
```

#### Binary模式
```
输入：0x48 0x65 0x6C 0x6C 0x6F
输出：Hello
```

## 7. 测试数据生成

### 7.1 UART测试数据

```python
# UART测试数据示例
test_data = [
    "$25.6,60.2,1013.25;",  # 温湿度气压数据
    "$1.2,-0.8,9.8;",       # 加速度数据  
    "$45.123,116.456,156;", # GPS数据
]
```

### 7.2 Network测试数据

```python
# TCP/UDP测试数据
tcp_data = b"$sensor1:25.6,sensor2:60.2;"
udp_data = b"GPS:45.123,116.456,156m;"
```

### 7.3 BLE测试数据  

```python
# BLE测试数据（注意20字节限制）
ble_data = [
    b"T:25.6\n",     # 温度数据
    b"H:60.2\n",     # 湿度数据  
    b"P:1013.25\n",  # 压力数据
]
```

## 8. 错误处理

### 8.1 常见错误类型

| 错误类型 | 描述 | 解决方案 |
|---------|------|----------|
| 连接失败 | 设备无法连接 | 检查设备状态、地址、端口配置 |
| 数据超时 | 接收数据超时 | 检查数据发送频率和网络状况 |
| 校验错误 | 数据校验失败 | 检查校验算法配置和数据完整性 |
| 格式错误 | 数据格式不匹配 | 检查帧分隔符和解码方式配置 |

### 8.2 调试建议

1. **启用调试日志**: 在开发阶段启用详细日志输出
2. **数据监控**: 使用Serial Studio的控制台面板监控原始数据
3. **逐步测试**: 从简单的纯文本数据开始，逐步增加复杂性
4. **网络测试**: 使用网络调试工具验证TCP/UDP通信
5. **BLE测试**: 使用BLE调试应用验证设备连接和数据传输

---

*注意：商业版功能（Audio、ModBus、CanBus）需要相应的许可证才能使用。*